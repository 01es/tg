\section{Data Management \& Web Resources}\label{sec:04}

  One of the central differentiators of business applications from other information systems is their paradigm for data processing.
  Data related activities is the most important and at the same time the most vulnerable part of business applications.
  Vulnerability can be explained by the lack of~~``close to perfection'' solutions unlike for some other types of software systems such as word processing or digital painting software.
  Business applications are constantly under the pressure of contradicting requirements.
  On the one hand, there is a need for processing large datasets, while on the other hand business applications should demonstrate good performance and rich functionality.
  The amount of data to be processed always increases, requirements for more diverse functionality occur constantly and the need for high scalability of business applications is ever increasing.
  
  There are several well accepted data processing paradigms currently in use for developing business applications.
  However, there is no single best solution that would satisfy all business requirements.
  It can be observed that most if not all available solutions implement different combinations of data management paradigms, which represent compromises to improve certain specifically targeted characteristics.

  With the increase of the role of the Internet as a communication mechanism for Enterprises as well as the maturity of many Internet technologies, business applications are required to process data not only by directly communicating with databases\footnote{Usually RDBMS.}, but also distributed across the Web resources.
  This introduced an additional layer of complexity where in most cases developers need to switch between paradigms of working with relational databases and Web resources.

  The Trident Genesis platform introduces its own data processing solution by reusing some of existing paradigms in its own unique way to provide a uniform programming model for data processing against both databases and web resources\footnote{Web resources developed using the Trident Genesis platform.}.
  All data CRUD (create, request\footnote{Commonly, ``R'' stands for \emph{read} or \emph{retrieve}, but here we'd like to emphasise a more rich functionality behind the ``R'' in TG as described farther in the text.}, update, delete) operations utilise pure object-oriented approach combined with carefully designed internal DSL called ``Entity Query Language''.
  This means that developers do not operate on database records or web resources directly.
  Instead they are confined to the much higher conceptual level of business domain models and the query language that operates directly on these models.
  
  For example, in order to modify persisted data there is no need to write complex low level queries and translate their result into the business domain model.
  Persisted business entities are requested declaratively, modified by changing their properties at the object level and saved also declaratively.
  The platform fully takes care of handling low technical details for translating declaratively expressed actions into corresponding Web or database related API calls.
  Such development model provides a convenient way to implement business rules related to changes of domain entities such as validation, before and after save logic, which can lead to modification of additional entities if required etc.
  It also fully supports both \emph{remote} and \emph{local}\footnote{The \emph{remote} here means the server-side application, and \emph{local} -- the client-side application running on users' local machines.} data processing, which provides developers with a flexible way to leverage computational resources by controlling how ``thin'' should their business client and server applications be.

  \subsection{Client- \& Server-Side Applications}
  With an advent of multi-tier software architecture, the three-tier architecture became a de-facto standard for developing web-enabled applications.
  The current state and trend in Web development technologies is twofold: on one side there is an ``in-browser HTML'' model, where client applications are served as a web page, on another -- rich client application model, where client applications are fully capable desktop applications.
  Both models have their strengths and weaknesses.

  As mentioned above, the enforced by the platform programming model strives for uniformity. 
  The platform follows the path of reducing the number of concepts and technologies needed for development of business applications.
  One of the key aspects of this, is the use of Java as the only programming language required to develop business applications with TG.
  This is achieved by utilising the RIA paradigm for developing both client and server applications using only the Java programming language.
  
  From a practical perspective of software development this has a significant advantage over the ``in-browser HTML'' model.  
  For example, such important activities as debugging and profiling are performed in a familiar environment of the preferred IDE, where developers think in terms of their primary programming language instead of handling the complexity of context switching between several languages\footnote{E.g. Java for the server application and Java Script for the client application.}.
  At the same time, the end-users of business applications benefit from the power of the fully fledged JVM utilised by the client-side application to provide high performance and excellent usability experience.
  
  The server-side represents a set of loosely coupled Web resources that adhere to principles of the Resource Oriented Architecture.
  This architectural style lends itself very well to develop scalable business applications, which can leverage different deployment infrastructures -- from a single server machine to a cluster of multiple machines and the cloud.
  The provided development model hides the technical complexity of developing Web resources\footnote{Platform supports the development of custom Web resources if required, but such need is unlikely due to rich semantics of the provided domain level abstractions.} by treating all domain entities as such.
  The platform understands the application execution context automatically choosing the appropriate handling mechanism of domain entities either as ordinary Java objects in the local memory or as Web resources residing at the server side.
  
  For example, if the business application attempts to save a domain entity\footnote{It could either be persistent or synthetic entity, which is possible due to the platform's uniform development model.}, the underlying platform mechanism would determine the origin of the request, resulting in either a call to the database for the server-side application or a corresponding Web resource for the client-side application.
  All of this is accompanied by automatic transaction demarcation ensuring referential integrity of the data.

   \begin{figure}[!h]
    \centering    
    \begin{tikzpicture}[>=latex']
      \tikzset{
	  outercore/.style={circle, fill=blue!50!white, inner sep=0em, minimum size=0.6cm},
	  core/.style={circle, shade, ball color=green!50!white, inner sep=0em, minimum size=0.3cm},
	  score/.style={circle, fill=green!50!black, inner sep=0em, minimum size=0.3cm},
	  outer/.style={circle, fill=blue!50!white, inner sep=0em, minimum size=2.3cm},
	  inner/.style={circle, fill=green!50!white, inner sep=0em, minimum size=1.5cm},
	  trans/.style={circle, fill=yellow!50!orange, inner sep=0em, minimum size=2.7cm}
      }

      %-----#1 height, #2 width, #3 aspect, #4 name of the node, #5
      %-----coordinate, #6 label
      \def\aboxl[#1,#2,#3,#4,#5]#6{%
	\node[draw, cylinder, alias=cyl, shape border rotate=90, aspect=#3, %
	minimum height=#1, minimum width=#2, outer sep=-0.5\pgflinewidth, %
	color=orange!60!black, left color=yellow!80, right color=yellow!80!orange, middle
	color=white] (#4) at #5 {};%
	\node at #5 [orange!80!black] {#6};%
	\fill [yellow!30] let \p1 = ($(cyl.before top)!0.5!(cyl.after top)$), \p2 =
	(cyl.top), \p3 = (cyl.before top), \n1={veclen(\x3-\x1,\y3-\y1)},
	\n2={veclen(\x2-\x1,\y2-\y1)} in (\p1) ellipse (\n1 and \n2); }
      
      \begin{scope}[pattern=dots]
	\node (o) at (0, -0.25) [outer, opacity=0.8][postaction={pattern=north west lines,pattern color=blue!20}] {};      	
	\node (i) at (0, -0.25) [inner, opacity=0.8,][postaction={pattern=north west lines,pattern color=green!20}] {} node [below,text=blue!50!black,yshift=-1.7cm] {Client-Side};

	\begin{scope}[scale=0.3]
	  \node (t) at (0,0) [outercore, opacity=0.8][postaction={pattern=north west lines,pattern color=green!20}] {};	
	  \node at (0,0) [core, opacity=0.5][postaction={pattern=north west lines,pattern color=green!20}] {};

	  \node (r) at (1,-1.2) [outercore, opacity=0.8][postaction={pattern=north west lines,pattern color=green!20}] {};	
	  \node at (1,-1.2) [core, opacity=0.5][postaction={pattern=north west lines,pattern color=green!20}] {};

	  \node (l) at (-1,-1.2) [outercore, opacity=0.8][postaction={pattern=north west lines,pattern color=green!20}] {};	
	  \node at (-1,-1.2) [score][postaction={pattern=north west lines,pattern color=green!20}] {};
	\end{scope}
      \end{scope}

      \begin{scope}[xshift=8cm]       
	\node[trans] at (0, -0.25) {} node [above,text=orange!80!black, scale=0.7,yshift=1.7cm] {Transaction Demarcation};;
	\node (o2) at (0, -0.25) [outer, opacity=0.8] {};
	\node (i2) at (0, -0.25) [inner, opacity=0.8] {} node [below,text=blue!50!black,yshift=-1.7cm] {Server-Side};

	\begin{scope}[scale=0.3]
	  \node (t2) at (0,0) [outercore, opacity=0.8] {};	
	  \node (t2c) at (0,0) [core, opacity=0.5] {};

	  \node (r2) at (1,-1.2) [outercore, opacity=0.8] {};	
	  \node (r2c) at (1,-1.2) [core, opacity=0.5] {};

	  \node (l2) at (-1,-1.2) [outercore, opacity=0.8] {};	
	  \node at (-1,-1.2) [score] {};
	\end{scope}	
      \end{scope}     
      \begin{scope}[xshift=3.93cm,yshift=-0.3cm]
	\node[shape=double arrow,draw,minimum height=9cm,scale=0.6] {CRUD Operations};
      \end{scope}
      \begin{scope}[xshift=12cm,yshift=-0.5cm]
	\aboxl[2.0cm,1.5cm,1.6,a1,(0,0)] {DB};
	\node [xshift=-0.6cm, yshift=0.5cm] (mark1) {};
	\node [xshift=-0.6cm, yshift=-0.3cm] (mark2) {};
      \end{scope}


      \fill [very thick, green!50!black,->,out=30,in=160] (t2c.east) edge (mark1.west);      
      \fill [very thick, green!50!black,->,out=-30,in=-160] (r2c.east) edge (mark2.west);
    \end{tikzpicture}   
  \end{figure}


  \subsection{Entity Query Language}
  
  The platform ensures an effective technological support of the object-oriented programming approach, which underpins the provided development model.
  One of the principal solutions incorporated into the platform is \emph{Entity Query Language} -- a declarative query language based on SQL that provides a number of significant enhancements. 
  The primary objective of these enhancements is the support for working with business entities in a natural for object-oriented programming way, which ensures effective and ergonomic means for implementing business solutions.
  
  One of the key benefits of the object-relational paradigm for data management is its clarity and simplicity for developing applications.
  Object-orientation provides excellent readability of algorithms implementing the business logic, significantly reduces the number of programming errors and ensures data integrity at a high level.
  
  Entity Query Language (EQL) represents an internal Java DSL, which embraces the fluent interface concept and object composition to provide a type safe query language that matches the data processing power of SQL, but exceeds it in clarity and expressiveness.
  This provides a natural way to express data processing instructions in terms of the business domain instead of the low level data structures.
  The implementation of EQL as an internal DSL automatically takes advantage of modern Java IDEs, which provide code highlighting, code insight etc.
  This favourably differentiates EQL from alternatives such as Hibernate Query Language where queries are expressed as strings without any semantics for an IDE or compiler to validate them at design time.
  Thus, every EQL query is validated at design/compile time naturally fitting into the Java's statically typed nature.
  
  An example of an EQL query is provided as code listing~\ref{lst:eql}.  
  It calculates the average yearly (over the period from 2009 to 2011) maintenance cost of vehicles manufactured by ``MERCEDES'' and their model names starting with ``315'', ``316'' or ``VITO'', for every sector of division ``NORTH''\footnote{This example is specific to a certain fleet domain and the full comprehension of the query implies good understanding of that domain.}.  

  \lstset{language=Java,morekeywords={val,select,where,prop,eq,and,begin,end,starts_with,any_of_values,values,or,yield_and_group,as,yield,begin_expr,sum_of,div,end_expr,model_as_aggregate,year_of,in},numbers=left, numberstyle=\tiny, basicstyle=\scriptsize, stepnumber=1, numbersep=5pt, keywordstyle=\color{dkgreen}, stringstyle=\color{blue}}
  \begin{code}{EQL Query Example}{lst:eql}
  \begin{lstlisting}
    select(WorkOrder.class).
    where().
    prop("vehicle.model.make.key").eq().val("MERCEDES").and().
    begin().
      prop("vehicle.model.key").starts_with().any_of_values("315", "316").or().
      prop("vehicle.model.key").eq().val("VITO").
    end().and().
    year_of().prop("actualStart").in().values(2009, 2010, 2011).and().
    prop("vehicle.station.zone.sector.division.key").eq().val("NORTH").
    yield_and_group().prop("vehicle.station.zone.sector").as("sector").
    yield().
      begin_expr().
	sum_of().prop("actualCost").div().val(3).
      end_expr().as("averageYearlyMaintenanceCostPerSector").
    model_as_aggregate();
  \end{lstlisting}
  \end{code}
  
  The demonstrated EQL query is interesting in many ways.
  It shows proper support for working at the domain level referencing the nested structure of domain entities, multiple EQL constructs (aggregation, grouping, logical operations) and the capability of working with expressions\footnote{
    Expressions in TG are implemented as an internal DSL for the use by developers as well as external DSL for the use directly from business applications by power users. 
    All arithmetical operations, specially provided functions (e.g. year\_of(date)) and aggregations can be represented as type safe expressions.
  }
  (summation of property actualCost divided by 3).  
  
  Less obvious, but very powerful feature demonstrated in this query, is the ability to produce dynamically composed results that do not necessarily match any of the pre-built domain entity types.
  This capability is critical for many real-life business requirements where some business logic or analysis may require ad-hoc data retrieval without modifying the domain itself.
  The declarative nature of EQL significantly simplifies creation of complex queries with nested sub-queries, grouping and aggregation, which is extremely important for implementing analytical solutions.  

  Entity Query Language fully reuses the metadata associated with domain entity types.
  This facilitates dynamic optimisation of query execution at the databases level, which is possible due to semantic transition between metadata of the domain and SQL.
  For example, if some property of a domain entity, which represents a reference to other domain entity, is declared as required, then the query execution mechanism would recognise such reference as SQL's \emph{INNER JOIN} instead of \emph{OUTER JOIN}, which significantly speeds up query execution.

  The EQL execution mechanism works equally well with small and large datasets by supporting partitioned data loading.
  This does not require any additional work on part of developers -- they just need to provide the query and the system would automatically execute it with the necessary level of granularity.
  It is important that the platform does not rely on any RDBMS vendor specific features such as cursors, which might require keeping resulting datasets open in memory.
  Instead, the EQL execution mechanism automatically enhances queries to retrieve data sequentially.
  This approach naturally fits into the stateless Resources Oriented Architecture of the platform to properly support scalability of TG-based applications.

  Developers working directly with SQL always ensure that only the required data should be returned as the result of query execution.  
  Trident Genesis supports fine-tuning of EQL queries that match flexibility of SQL.
  Unlike, many other existing object-relational technologies that either follow the lazy-loading model\footnote{
  This causes severe performance issues known as ``$n+1$ request'', which is especially dangerous when the technology is used by novice developers.}
  or provide ways to specify fetching as part of queries\footnote{Or even more restrictively -- as part of the object-relational mapping.}, the platform supports a concept of the \emph{explicit fetching strategy}.
  This separates EQL queries, which indicate how to find data, from the fetching models, which indicate what data exactly needs to be returned providing a full control over the resulting object graph initialisation.
  So, depending on business requirements the same EQL query can be executed with different fetch models, which provides a way to optimise the load time and memory footprint.

  As mentioned before, the development model hides many technical details including the data communication mechanism.
  This completely removes the conceptual mismatch between the ways of querying the domain against databases and Web resources.
  Any EQL query can be seamlessly executed as part of either client- or server-side applications.
  Thus, EQL provides a uniform high-level domain oriented communication concept.