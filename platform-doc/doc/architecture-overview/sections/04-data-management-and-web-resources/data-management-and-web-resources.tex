\section{Data Management \& Web Resources}\label{sec:04}

  One of the central differentiators of business applications from other information systems is their paradigm for data processing.
  Data related activities is the most important and at the same time the most vulnerable part of business applications.
  Vulnerability can be explained by the lack of ``close to perfection'' solutions unlike for some other types of software systems such as word processing or digital painting software.
  Business applications are constantly under the pressure of contradicting requirements.
  On the one hand, there is a need for processing large amounts data, while on the other hand business applications should demonstrate good performance and rich functionality.
  The amount of data to be processed always increases, requirements for more diverse functionality occur constantly and the need for high scalability of business applications is ever increasing.
  
  There are several well accepted data processing paradigms currently in use for developing business applications.
  However, there is no single best solution that would satisfy all business requirements.
  It can be observed that most if not all all availalbe solutions implement different combinations of data management paradigms, which represent compromises to improve certain specifically targeted characteristics.

  With the increase of the role of the Internet as a communication mechanism for Enterprises as well as the maturity of many Internet technologies, business applications are required to process data not only by directly communicating with databases\footnote{Usually RDBMS.}, but also distibuted across the Web resources.
  This introduced an additional layer of complexity where in most cases developers need to switch between paradigms of working with relational databases and Web resources.

  The Triden Genesis platform introduces its own data processing solution by reusing some of existing paradigms in its own unique way to provide a uniform programming model for data processing against both databases and web resources\footnote{Web resources developed using the Trident Genesis platform.}.
  All data CRUD (create, request\footnote{Officially, ``R'' stands for \emph{read} or \emph{retrieve}, but here we'd like to emphasise a more rich functionality behind the ``R'' in TG as desctibed farther in the text.}, update, delete) operations utilise pure object-oriented approach combined with carefully design internal DSL called ``Entity Query Language''.
  This means that developers do not operate on database records or web resources directly.
  Instead they are confined to the much higher conceptual level of business domain models and the query language that operates directly on these models.
  
  For example, in order to modify persisted data there is no need to write complex low level queries and translated their result into the business domain model.
  Persisted business entities are requested declaratively, modified by changing their properties at the object level and saved also declaratively.
  The platform fully takes care of handling low technical details for translating decleratively expressed actions into corresponding Web or database related API calls.
  Such development model provides a convenient way to implement business rules ralated to changes of domain entities such as validation, before and after save logic, which can lead to modification of additional entities if required etc.
  It also fully supports both \emph{remote} and \emph{local}\footnote{The \emph{remote} here means the server-side application, and \emph{local} -- the client-side application running on users' local machines.} data processing, which provides developers with a flexible way to leverage computational resources by controlling how ``thin'' should their business client and server applications be.

  \subsection{Server- \& Client-Side Applications}

  \subsection{Entity Query Language}
  
  \lstset{language=Java,morekeywords={val,select,where,prop,eq,and,begin,end,starts_with,any_of_values,values,or,yield_and_group,as,yield,begin_expr,sum_of,div,end_expr,model_as_aggregate,year_of,in},numbers=left, numberstyle=\tiny, basicstyle=\scriptsize, stepnumber=1, numbersep=5pt, keywordstyle=\color{dkgreen}, stringstyle=\color{blue}}
  \begin{code}{Entity Query Example}{label1}
  \begin{lstlisting}
    select(WorkOrder.class).
    where().
    prop("vehicle.model.make.key").eq().val("MERCEDES").and().
    begin().
      prop("vehicle.model.key").starts_with().any_of_values("315", "316").or().
      prop("vehicle.model.key").eq().val("VITO").
    end().and().
    year_of().prop("actualStart").in().values(2009, 2010, 2011).and().
    prop("vehicle.station.zone.sector.division.key").eq().val("NORTH").
    yield_and_group().prop("vehicle.station.zone.sector").as("sector").
    yield().
    begin_expr().
      sum_of().prop("actualCost").div().val(3).
    end_expr().as("averageYearlyMaintenanceCostPerSector").
    model_as_aggregate();
  \end{lstlisting}
  \end{code}
  
  

%  // calculates the average yearly maintenance cost (for the last 3 years) per sectors of NORTH division. Only vehicles of MERCEDES make and models starting from 315 or 316 or VITO model are taken into account.
%         select(WorkOrder.class).
%         where(). //
%         prop("vehicle.model.make.key").eq().val("MERCEDES").and().
%         begin().prop("vehicle.model.key").starts_with().any_of_values("315", "316" ).or().prop("vehicle.model.key").eq().val("VITO").end().and().
%         year_of().prop("actualStart").in().values(2009, 2010, 2011).and().
%         prop("vehicle.station.zone.sector.division.key").eq().val("NORTH").
%         yield_and_group().prop("vehicle.station.zone.sector").as("sector").
%         yield().begin_expr().sum_of().prop("actualCost").div().val(3).end_expr().as("averageYearlyMaintenanceCostPerSector").model_as_aggregate();

