\chapter{Tools}\label{ch02:00}

\myepigraph{The expectations of life depend upon diligence; the mechanic that would perfect his work must first sharpen his tools.}{Confucius}

  The platform can be used for developing software using any IDE for Java such as IntelliJ IDEA or Netbeans.
  However, the recommended IDE for this is Eclipse due to provided set of plugins developed specifically to facilitate TG-based development.
  
\section{Overview of Eclipse Plugins}

  The main features that are provided by the developed plugin pertain to automating creation of fractal objects, main menu items and UI.
  The provided automation is easily comparable to that provided by inbuilt Delphi features such as creation of forms and data modules.
  
  The plugin is distributed in a from of a jar file \texttt{tg-eclipse-plugin\_\textless version\textgreater.jar}.
  It can be installed by placing the jar into Eclipses \texttt{dropins} directory.
  Once installed, the plugin integrates with the \emph{Package Explorer} context menu.
  
  There are three groups of actions that can be invoked from a context menu:
  
  \begin{description}
    \item[\textbf{TG Model Actions.}] Represents actions that facilitate creation of different kinds of entity types.
    Fig.~\ref{img:ch02:00:model-actions} depicts the menu.
    
    \begin{itemize}
     \item \emph{Create Master Entity/Companion Objects\ldots} -- generates a pair of master entity and companion objects with respective DAO and RAO default implementations for the companion object.
     \item \emph{Create One-2-One Entity/Companion Objects\ldots} -- generates a pair of entity and companion objects with respective DAO and RAO default implementations for the companion object: the generated entity models a one-2-one relationship with a master entity, which gets specified during creation.
     \item \emph{Create One-2-Many Entity/Companion Objects\ldots} -- generates a pair of entity and companion objects with respective DAO and RAO default implementations for the companion object; the generated entity models a one-2-many relationship with a master entity, which gets specified during creation.
    \end{itemize}

    \begin{image}{Entity model creation actions.}{\label{img:ch02:00:model-actions}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	    \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-tg-model-actions.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,1.8)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package Explorer}\newline
	  The actions are integrated into the context menu of Package Explorer.
	  \end{minipage}
	};

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(2,-3.8)}] at (5,-2.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Subitem}\newline
	  Three actions for creating different kinds of entity objects.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}
    
    
    \item[\textbf{TG Menu Actions.}] Represents actions that facilitate creation of the application main menu items.
    Fig.~\ref{img:ch02:00:menu-actions} depicts the menu.
    
    \begin{itemize}
     \item \emph{Create Group Menu\ldots} -- generates a menu item that can be used for grouping of sub-items.
     \item \emph{Create Simple Menu} -- generates the most trivial menu item for a selected entity that gets associated with a centre for that entity.
     \item \emph{Create Menu Entry with Custom Command} -- generates a menu items for a selected entity that gets associated with a centre for that entity, and provides a stub for a custom action.
    \end{itemize}

    \begin{image}{Menu Actions.}{\label{img:ch02:00:menu-actions}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	  \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/02-tg-menu-actions.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,1.8)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package Explorer}\newline
	  The actions are integrated into the context menu of Package Explorer.
	  \end{minipage}
	};

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(2,-4.0)}] at (5,-2.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Subitem}\newline
	  Three actions for creating different kinds of application main menu items.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}
    
    \item[\textbf{TG Master Actions.}] Represents actions that facilitate creation of various kinds of entity master forms that are used as a front end for creation and modification of entity instances. 
    Fig.~\ref{img:ch02:00:master-actions} depicts the menu.
    
    \begin{itemize}
     \item \emph{Create Simple Master for Entity} -- generates a pair of UI model and view that represent an simple entity master form; suitable for entities that do not have (or do not require) one-2-many associations.
     \item \emph{Create Compound Master for Entity} -- generates UI (a model and two views) that assumes a master form with a tree menu, where each menu item (except the first) represents some association for a selected during generation entity; only the first item menu item is generated that gets associated with a view for entry and modification of non-collectional entity properties (one can think of it as main entity data).
     \item \emph{Create Compound Master Sub Model/View for Entity (One-2-One)\ldots} -- generates a pair of UI sub-model and sub-view that should be associated with some compound master; this UI pair is generated for an entity that is in one-2-one association to some master entity object; the UI provides means to create and modify instances of the subordinate entity object with automatic association to a corresponding master entity object.
     \item \emph{Create Compound Master Sub Model/View for Entity (One-2-Many)\ldots} -- generates a pair of UI sub-model and sub-view that should be associated with some compound master; this UI pair is generated for an entity that is in one-2-many association to some master entity object; the UI provides means to create and modify multiple instance of the subordinate entity object with automatic association to a corresponding master entity object.
     \item \emph{Create Compound Master Sub Model/View for Entity (One-2-Many Centre-Based)\ldots} -- generates a pair of UI sub-model and sub-view that resembles an entity centre where selection criteria section is configured at the source level; this kind of UI also supports customisation of the toolbar by providing custom actions; the resultant from such model queries are automatically enhanced with a filtering condition to show only instances that are associated with a corresponding master entity object.
     \item \emph{Create Entity Producer with User} -- generates an entity producer that gets used for creation of new entity instances on master forms; the generated producer contains the code for obtaining system user at runtime, which comes handy when new entities should be initialised with the information about their creator.
    \end{itemize}

    \begin{image}{Master Actions.}{\label{img:ch02:00:master-actions}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	  \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/03-tg-master-actions.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,1.8)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package Explorer}\newline
	  The actions are integrated into the context menu of Package Explorer.
	  \end{minipage}
	};

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(2,-2.8)}] at (5,-0.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Subitem}\newline
	  Actions for creating UI artefacts such as models and views for entity master forms, entity producers used by master forms.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}
    
    
  \end{description}

  Some of the actions should be invoked on specific classes or packages, and generate associated with them artefacts without any additional parameters.
  However, other actions bring up wizards that require specific inputs, and only once those inputs are populated, can be used to generated associated artefacts.
  Some of the inputs get populated based on the invocation context (e.g. package name can be populated if the context menu was invoked on a package).
  The following sections delves more into the details about specific plugin actions.

\section{Creation of Entity Objects}
  
  This section covers the first group of actions that are designed to assist developers in creation of entity objects that are the bread and butter of the domain modelling with the platform.

  As has been discussed in section~\ref{ch01:02} all entity objects can be distilled down to three principle kinds:
  
  \begin{itemize}
   \item Master entity;
   \item Subordinate one-2-one entity that gets associated with a single master entity;
   \item Subordinate one-2-many entity where one or more instances get associated with a single master entity.
  \end{itemize}

  In reality the situation could get a lot more complex as any of the one-2-one and one-2-many kinds may act in turn as master entities to other subordinate types. 
  This is, however, only natural if the domain inherently requires such complexity.  
  Thus, there are three actions -- one for creating each kind of an entity object.
  
  \subsection{Creation of Master Entities}
  
  The master entity together with its companion object can be created using action \emph{Create Master Entity/Companion Objects\ldots}.
  Fig.~\ref{img:ch02:00:model-actions-new-master-entity-01} depicts a wizard window that gets displayed upon action invocation.
  It is most natural for this action to be invoked on a package within the pojo-bl application module where an intended entity object should reside.
  This way the plugin automatically populates the package entry as illustrated in Fig.~\ref{img:ch02:00:model-actions-new-master-entity-01}.
  Otherwise, the package should be specified.

  \begin{image}{Create Master Entity/Companion Objects.}{\label{img:ch02:00:model-actions-new-master-entity-01}}
    \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
      \pgftext{%
	  \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-01-new-master-entity.png}
      }%

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,2.0)}] at (-6.5,3.5) 
      {
	\begin{minipage}{3cm}
	\tiny
	\textbf{Source folder}\newline
	Regardless of where the context menu is invoked, the source folder is identified automatically and always points to the pojo-bl module of the application.
	\end{minipage}
      };
      
      \node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.3,1.4)}] at (-6.5,1.0) 
      {
	\begin{minipage}{3cm}
	\tiny
	\textbf{Package name}\newline
	If the action is selected from a context menu that was invoked on a package then the package name gets populated automatically.
	Otherwise it needs to be specified manually or selected for a dialog that is accessible via button \emph{Browse}.
	\end{minipage}
      };
      

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(2.0,1.0)}] at (5.0,3.1) 
      {
	\begin{minipage}{3cm}
	\tiny
	\textbf{Name}\newline
	This is a class name that should adhere to camel case naming convention.
	It is used as the name for a class representing an entity object.
	\end{minipage}
      };      

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(2.0,0.5)}] at (7.0,1.0) 
      {
	\begin{minipage}{4cm}
	\tiny
	\textbf{Superclass}\newline
	All entity objects are descendants of class \texttt{AbstractEntity}.
	The assumed key type for master entity is \texttt{String} with \texttt{Integer} as an option that could be specified one classes are created.	
	\end{minipage}
      };      

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(0,-0.7)}] at (4,-1) 
      {
	\begin{minipage}{4cm}
	\tiny
	\textbf{Options}\newline
	Provides support for customising an entity being generated.
	More details about each option are outlined in the text.
	\end{minipage}
      };
    \end{tikzpicture}  
  \end{image}  
  
  Most of the options in this wizard are described in Fig.~\ref{img:ch02:00:model-actions-new-master-entity-01}.
  However, the provided checkbox options require a little bit more explanation.
  \begin{description}
   \item[\textbf{should have property 'desc'}] -- 
   specifies whether entity object should have the description property; most entities requires or may use such property as comes at no cost; 
   presence or absence of property \texttt{desc} is controlled via annotation \texttt{@DescTitle}; 
   if this annotation is not declared as part of entity object definition then property \texttt{desc} is recognised by the platform as absent;

   \item[\textbf{should be persistent}] -- 
   if a synthesised or a functional entity needs to be created then this option should be unchecked; such entities do not usually have a persistent state; 
   however, if a persistent entity needs to be created then this option should be left on; from our experience the number of persistent entities is significantly greater than that of synthesised or a functional entities, thus by default this option if on;

   \item[\textbf{use mixin for common RAO/DAO code}] -- 
   often methods in RAO and DAO that implement companion object contract have exactly the same implementation\footnote{This happens mainly due to the universal execution model for CRUD operations (including EQL queries) that works seamlessly at both the client and server sides.)}; 
   in order to avoid code duplication to improve system maintainability, it makes sense to place the common for RAO and DAO methods into a single class that could be than reused in both places; 
   the platform provides a convenient support for this in a form of a \emph{\href{http://en.wikipedia.org/wiki/Mixin}{mixin}} -- a class that should contains common methods and has a companion object (an interface) as its constructor argument; such mixin can be naturally mixed into both RAO and DAO implementations by means of composition; 
   if this option is selected then a mixin class would get generated and integrated into the RAO and DAO classes that also get generated as part of entity object creation;

   \item[\textbf{support deletion}] -- 
   many, especially persistent entities, may require deletion support; 
   by default deletion is disabled at the base level of the common companion object ancestor that is provided by the platform, and needs to be enabled explicitly by overriding corresponding methods; 
   in most cases deletion is safe due to automatic management of dependencies between entities, but due to severity of such action by default it is disabled; 
   this option should be selected if support for deletion is required for the entity being created.
  \end{description}
 
  Once all the required inputs are populated, button \emph{Finish} becomes enabled.
  Pressing it leads to the generation of a number of classes and interfaces that together represent an entity object, a companion object, RAO and DAO implementations for a companion object, and a mixin class (depending on options selected).
  At the end, the wizard produces a warning advising the developer to register the generated entity type as part of the application domain.
  This is done by calling static method \texttt{add} with the class for entity object as an argument in the static initialisation block of class \texttt{ApplicationDomain}.
  Every TG-based application is provided with class \texttt{ApplicationDomain}, and the place where new entities should registered becomes obvious once \texttt{ApplicationDomain} is open in the code editor.
  
  In order to describe the generated artefacts let's consider a concrete example based on our illustrative application \emph{collapp} that models a fraction of the rail domain.
  Let the name of the generated master entity be \texttt{Bogie}, and let's also consider that its package is \texttt{fielden.rail} and that all options on the entity wizard have been selected (including deletion and mixin options).
  Fig.~\ref{img:ch02:00:model-actions-new-master-entity-artefacts} depicts a UML diagram that specifies all classes that are generated and their location in terms of packages and application modules.
  
  \begin{image}{Create Master Entity/Companion Objects Artefacts.}{\label{img:ch02:00:model-actions-new-master-entity-artefacts}}
    \begin{tikzpicture}
      \draw[very thick, dashed, color=blue!30, rounded corners] (-2.3, 2.5) rectangle (3.0,-1.5);
      \node[rotate=90,color=blue!50!black] at (-2.6, 1.5) {\small coolapp-dao};
      \begin{umlpackage}[x=0,y=0,fill=blue!30]{fielden-rail}
        \umlemptyclass[x=0,y=0,template={Bogie}]{BogieDao}
      \end{umlpackage}
      
      \draw[very thick, dashed, color=green!30, rounded corners] (4.5, 2.5) rectangle (9.8,-1.5);
      \node[rotate=90,color=green!50!black] at (4.2, 1.5) {\small coolapp-rao};
      \begin{umlpackage}[x=7.0,y=0,fill=green!30]{fielden-rail}
        \umlemptyclass[x=0,y=0,template={Bogie}]{BogieRao}
      \end{umlpackage}

      \draw[very thick, dashed, color=red!30, rounded corners] (-2.0, -2.3) rectangle (9.5,-7.0);
      \node[rotate=90,color=red!50!black] at (-2.3, -3.5) {\small coolapp-pojo-bl};
      \begin{umlpackage}[x=-1.5,y=-5,fill=red!30]{fielden-rail}
        \umlemptyclass[x=1,y=0]{Bogie}
        \umlemptyclass[x=3.5,y=0,width=3cm,template={Bogie},type=companion]{IBogie}
      \end{umlpackage}
      \begin{umlpackage}[x=7.0,y=-5,fill=red!30]{fielden-rail-mixin}
        \umlemptyclass[x=0.2,y=0,type=mixin, width=3cm]{BogieMixin}
      \end{umlpackage}            

      % associations
      \umluniaggreg{BogieMixin}{IBogie}
      \umluniaggreg{BogieRao}{BogieMixin}
      \umluniaggreg[anchors=-30 and 160]{BogieDao}{BogieMixin}
      \umlVHVinherit[anchors=-120 and 60]{BogieRao}{IBogie}
      \umlVHVinherit{BogieDao}{IBogie}
    \end{tikzpicture}
  \end{image}  
  
  The depicted diagram consists of three application modules:
  \begin{description}
   \item[\textbf{coolapp-pojo-bl}] -- contains class \texttt{Bogie} that defines an entity object with the same name and an interface \texttt{IBogie} that defines a corresponding companion object; both are located in the same package \texttt{fielden.rail}; the generated mixin class \texttt{BogieMixin} is placed into a subpackage \texttt{fielden.rail.mixin}; as can be understood from the diagram, it aggregates the companion object;
   \item[\textbf{coolapp-rao}] -- contains class \texttt{BogieRao} that provides RAO implementation for the companion object; it also aggregates the mixin class;
   \item[\textbf{coolapp-dao}] -- contains class \texttt{BogieDao} that provides DAO implementation for the companion object; it also aggregates the mixin class.
  \end{description}

  The concept of a mixin is probably the most complex -- all other aspects of a domain entity implementation has been covered in previous parts.
  Thus, it prompts to address mixins with greater care.
  Please recall that neither module \texttt{coolapp-pojo-bl} is aware of modules \texttt{coolapp-rao} and \texttt{coolapp-dao} nor modules \texttt{coolapp-rao} and \texttt{coolapp-dao} are aware of each other.
  Thus, there is a clean separation between the RAO and DAO implementations.  
  The core functionality that is required by any companion object is implemented by classes \texttt{CommonEntityDao} and \texttt{CommonEntityRao}, which are extended by corresponding companion DAO and RAO implementations (\texttt{BogieDao} and \texttt{BogieRao} in this case).  
  However, both these implementations must adhere to the contract defined by the companion object (\texttt{IBogie} in this case).
  
  When a new method is defined at the companion object then both \texttt{BogieDao} and \texttt{BogieRao} must implement it.
  Often, implementation for domain specific methods that are defied as part of companion objects are identical between the RAO and DAO counterparts.
  So, it only makes sense to have a single implementation that could be reused by both classes.  
  Let's consider that companion object \texttt{IBogie} defines method \texttt{lastMovement} as per listing~\ref{lst:ch02:00:IBogie}, and let's also consider that this method can be implemented identically for RAO and DAO.
  This means that both \texttt{BogieDao} and \texttt{BogieRao} would have code duplication that is very much error prone as someone could later update implementation only in DAO, but not in RAO or wise versa.
  
   \lstset{language=Java,
	  escapechar=\%,
	  numbers=left, numberstyle=\tiny, basicstyle=\scriptsize\color{basiccolor}, stepnumber=1, numbersep=5pt, keywordstyle=\bfseries\color{codefgcolor}, stringstyle=\color{stringcolor}}
  \begin{code}{\texttt{IBogie} definition.}{\label{lst:ch02:00:IBogie}}{codebgcolor}
    \begin{lstlisting}
public interface IBogie extends IEntityDao<Bogie> {
    BogieMovement lastMovement(final Bogie bogie);
}
    \end{lstlisting}
  \end{code}
  
  This is where the concept of a mixin comes handy.
  Instead of duplicating the code, class \texttt{BogieMixin} gets created in the \texttt{coolapp-pojo-bl} module, so that both  \texttt{BogieDao} and \texttt{BogieRao} could reuse it.
  This is a very simple class with no special inheritance requirements.
  Its only concern is to provide implementation for the required methods (\texttt{lastMovement} in this case).
  
  As can be observed from the method definition, its return type is \texttt{BogieMovement}, which identifies another domain entity with its companion \texttt{IBogieMovement}\footnote{In order to keep this example concise we won't present any source for entity \texttt{BogieMovement} -- strictly speaking this is not necessary as it would be very similar to what we're currently discussing.}.
  This means that the implementation of method \texttt{lastMovement} depends on this domain entity (both entity and companion object).
  A special interest here is in the companion object \texttt{IBogieMovement}, which is required in order to make requests about the movement data.
  This means that our mixin would need to aggregate an instance of \texttt{IBogieMovement}.
  
  Listing~\ref{lst:ch02:00:BogieMixin-def} shows the definition for \texttt{BogieMixin}, but without the implementation for method \texttt{lastMovement}.
  As can be observed it contains two fields \texttt{coBogie} and \texttt{coBogieMovement} that get assigned in the constructor~(lines 9--10).
  The constructor can be modified to accept as many arguments as required to provide the necessary functionality.
  Please note that both the fields and arguments are defined in terms of companion object types, which are interfaces.
  The relevant DAO or RAO implementations are provided at the time of mixin construction as discussed later.
  
  Strictly speaking \texttt{BogieMixin} does not require \texttt{coBogie} as only \texttt{coBogieMovement} is used for implementing method \texttt{lastMovement}.
  However, it is a recommend practice to provide mixins with corresponding companion objects as in most cases they do get used, and not providing them early would require later modification to both DAO and RAO implementations in order to pass in an additional constructor argument.
  Also, providing them early does not introduce any difficulty and does not inflict any additional complexity.
  
  %// prefix co stands for Companion Object followed by the entity name
    \begin{code}{\texttt{BogieMixin} definition.}{\label{lst:ch02:00:BogieMixin-def}}{codebgcolor}
    \begin{lstlisting}
public class BogieMixin {

    private final IBogie coBogie; %\tikzref{fields-definitions}{0.5cm}{0.0cm}%
    private final IBogieMovement coBogieMovement; 

    public BogieMixin(
           final IBogie coBogie, %\tikzref{argument-definitions}{0.5cm}{0.0cm}%
           final IBogieMovement coBogieMovement) {
      this.coBogie = coBogie;
      this.coBogieMovement = coBogieMovement;
    }
    
    public BogieMovement lastMovement(final Bogie bogie) { ... }
    
}
    \end{lstlisting}
    \tikznote{fields-definitions_annotation}{fields-definitions}{5cm}{1.0cm}{5cm}{Field definitions}{
           Both fields are immutable and defined as interface values that represent respective companion objects.
           
           The name of the fields follow a naming convention whereby the prefix \texttt{co} stends for Companion Object, followed by the entity name.
    }
    \tikznote{argument-definitions_annotation}{argument-definitions}{5cm}{0.5cm}{4cm}{Argument definitions}{
           Argument definitions resemble the definitions of the fields that they initialise.
    }
    \vspace*{-7px}
  \end{code}
  
  Listing~\ref{lst:ch02:00:BogieMixin-impl} provides a possible implementation for method \texttt{lastMovement}.
  First, a select model is constructed that declares filter conditions for bogie movements.
  Then this model is provided with an object graph population model (aka fetch model) and used to get a single \texttt{BogieMovement} entity that represents the last movement of the specified bogie.
  The fetch model should be specific to the usecase needs where the use of method \texttt{lastMovement} is intended.
  It can be easily foreseen that in order to provide more flexibility, a fetch model could be provided as either a method or a constructor argument.
  
  \begin{code}{Implementation of method \texttt{lastMovement}.}{\label{lst:ch02:00:BogieMixin-impl}}{codebgcolor}
  \begin{lstlisting}
...
public BogieMovement lastMovement(final Bogie bogie) { 
  final EntityResultQueryModel<BogieMovement> select = 
	      select(BogieMovement.class).
	      where().
		prop("bogie").eq().val(bogie).and(). %\tikzref{concrete-bogie}{0.1cm}{0.1cm}%
		notExists(
		  select(BogieMovement.class).where(). 
		  prop("bogie").eq().extProp("bogie").and(). %\tikzref{latest-movement}{0.1cm}{0.2cm}%
		  prop("inDate").gt().extProp("inDate").model()).
	      model();
  return coBogieMovement.getEntity( %\tikzref{fetch-model}{-0.5cm}{-0.3cm}%
         from(select).with(fetchAll(BogieMovement.class)).model());    
}
  ...
  \end{lstlisting}
  \tikznote{concrete-bogie-annotation}{concrete-bogie}{2.8cm}{1.7cm}{4cm}{Where condition 1}{
	  Consider only movements for the specified bogie.
  }
  \tikznote{latest-movement-annotation}{latest-movement}{3.0cm}{1.0cm}{3cm}{Where condition 2}{
	  Consider only those movements that none other exists, which were performed later.
	  This effectively means the condition to select the latest movement.
  }
  \tikznote{fetch-model-annotation}{fetch-model}{3.8cm}{-0.9cm}{4cm}{Fetch model}{
	  The fetch model declares that all non-collectional properties of the resultant \texttt{BogieMovement} instance are to be fetched.
  }
  \vspace*{-7px}
\end{code}
 
  Once the mixin is implemented it needs to be integrated into both RAO and DAO implementations of the companion object.
  Such integration is basically identical for both RAO and DAO, and consists of two basic steps -- mixin instantiation and invocation of its methods for reuse.
  Listings~\ref{lst:ch02:00:BogieDao-mixin} and~\ref{lst:ch02:00:BogieRao-mixin} outline these steps and provide relevant code annotations.
  
  \begin{code}{Mixin reuse in \texttt{BogieDao}.}{\label{lst:ch02:00:BogieDao-mixin}}{codebgcolor}
  \begin{lstlisting}
@EntityType(Bogie.class)
public class BogieDao extends CommonEntityDao<Bogie> implements IBogie {
      
  private final BogieMixin mixin;%\tikzref{mixin-declaration}{0.1cm}{0.1cm}%
    
  @Inject
  protected BogieDao(final IFilter filter, final IBogieMovement coBogieMovement) {%\tikzref{co-argument}{-2.0cm}{0.2cm}%
    super(filter);
    mixin = new BogieMixin(this, coBogieMovement);%\tikzref{mixin-instantiation}{0.1cm}{0.1cm}%
  }

  @Override
  public BogieMovement lastMovement(final Bogie bogie) { 
    return mixin.lastMovement(bogie);%\tikzref{mixin-reuse}{0.1cm}{0.1cm}%
  }
  
  @Override
  @SessionRequired
  public void delete(final Bogie entity) {
    defaultDelete(entity);
  }
                                           %\tikzref{support-deletion}{0.0cm}{0.0cm}%
  @Override
  @SessionRequired
  public void delete(
                 final EntityResultQueryModel<Bogie> model, 
                 final Map<String, Object> paramValues) {
    defaultDelete(model, paramValues);
  }  
}
  \end{lstlisting}
  \tikznote{mixin-declaration-annotation}{mixin-declaration}{3.8cm}{-0.2cm}{4cm}{Mixin declaration}{
    An immutable instance of mixin, which is initialised in the constructor.
  }
  \tikznote{co-argument-annotation}{co-argument}{2.0cm}{2.0cm}{4cm}{\texttt{IBogieMovement} argument}{
    An instance of \texttt{IBogieMovement} as concrete class \texttt{BogieMovementRao} is provided automatically by the injector.
  }
  \tikznote{mixin-instantiation-annotation}{mixin-instantiation}{3.8cm}{-0.5cm}{4cm}{Mixin instantiation}{
    Mixin is instantiated as an ordinary object using operation \texttt{new} and passing in the expected constructor arguments.
  }
  \tikznote{mixin-reuse-annotation}{mixin-reuse}{3.8cm}{-0.5cm}{4cm}{Mixin reuse}{
    Mixin reuse boils down to a simple invocation of method \texttt{lastMovement} that is implemented by the mixin.
  }
  \tikznote{support-deletion-annotation}{support-deletion}{5.0cm}{-1.0cm}{4cm}{Support deletion}{
    Selecting support deletion option leads to generation of two methods in DAO that override the default implementation inherited from CommonEntityDao.
    The default implementation throws \texttt{UnsupportedOperation} exception.
    The RAO implementation does not require such modification as its default deletion support delegates request to a corresponding entity web resource, which in turn delegates the call to DAO.
  }
  \vspace*{-7px}
\end{code}  
  
  \begin{code}{Mixin reuse in \texttt{BogieRao}.}{\label{lst:ch02:00:BogieRao-mixin}}{codebgcolor}
  \begin{lstlisting}
@EntityType(Bogie.class)
public class BogieRao extends CommonEntityRao<Bogie> implements IBogie {
  
  private final BogieMixin mixin;%\tikzref{mixin-declaration}{0.1cm}{0.1cm}%
  
  @Inject
  public BogieRao(final RestClientUtil restUtil, final IBogieMovement coBogieMovement) {%\tikzref{co-argument}{-2.0cm}{0.2cm}%
    super(restUtil);
    mixin = new BogieMixin(this, coBogieMovement);%\tikzref{mixin-instantiation}{0.1cm}{0.1cm}%
  }

  @Override
  public BogieMovement lastMovement(final Bogie bogie) { 
    return mixin.lastMovement(bogie);%\tikzref{mixin-reuse}{0.1cm}{0.1cm}%
  }
}
  
  \end{lstlisting}
  \tikznote{mixin-declaration-annotation}{mixin-declaration}{3.8cm}{0.0cm}{4cm}{Mixin declaration}{
    An immutable instance of mixin, which is initialised in the constructor.
  }
  \tikznote{co-argument-annotation}{co-argument}{0.5cm}{2.0cm}{4cm}{\texttt{IBogieMovement} argument}{
    An instance of \texttt{IBogieMovement} as concrete class \texttt{BogieMovementRao} is provided automatically by the injector.
  }
  \tikznote{mixin-instantiation-annotation}{mixin-instantiation}{3.8cm}{-0.5cm}{4cm}{Mixin instantiation}{
    Mixin is instantiated as an ordinary object using operation \texttt{new} and passing in the expected constructor arguments.
  }
  \tikznote{mixin-reuse-annotation}{mixin-reuse}{3.8cm}{-0.5cm}{4cm}{Mixin reuse}{
    Mixin reuse boils down to a simple invocation of method \texttt{lastMovement} that is implemented by the mixin.
  }
  \vspace*{-7px}
\end{code}  

  It is worth mentioning that due to dependency of mixin \texttt{BogieMixin} on companion object \texttt{IBogieMovement}, there is a need to provide an instance of RAO implementation of \texttt{IBogieMovement} into \texttt{BogieRao} and DAO implementation into \texttt{BogieDao}.
  Fortunately, passing of constructor arguments that are companion objects is trivial due to inherent support of the \emph{injection of control} mechanism by the platform.
  The only requirement for the right instance of \texttt{IBogieMovement} to be injected into \texttt{BogieRao} and \texttt{BogieDao} is to annotate their constructors with annotation \texttt{@Inject} and declare an argument of type \texttt{IBogieMovement}.

  Just as a reminder from the previous part of the book, please recall that constructor argument \texttt{restUtil} in \texttt{BogieRao} and argument \texttt{filter} in \texttt{BogieDao} are standard for all RAO and DAO implementations of companion objects.
  This concludes the discussion of action \emph{Create Master Entity/Companion Objects\ldots} and the artefacts it generates.
 

  \subsection{Creation of Entities that Model One-2-One Association}  
 
  All supported by the platform kinds of associations are discussed in great detail in section~\ref{ch01:02}.
  In essence all domain entities regardless of whether they're master or subordinate have almost identical structure -- all have an entity object, a companion object, its RAO and DAO implementation, and need to be registered with class \texttt{ApplicationDomain} etc.
  
  The most significant difference between the different kinds of entities is in their business key.
  For a one-2-one entity the type of the master entity becomes its business key type.
  Entities that model one-2-one association are designed to be used for composition rather than aggregation, and should be thought as an entity that represents an integral part of its master, nicely segregated in a form of another entity object.
  This means that when the master entity ceases to exist then the associated with it one-2-one entity should also cease from existence.  

  \begin{image}{Create One-2-One Entity/Companion Objects.}{\label{img:ch02:00:model-actions-new-one-2-one-entity}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	    \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-02-new-one-2-one-entity.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,2.2)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Source folder}\newline
	  Regardless of where the context menu is invoked, the source folder is identified automatically and always points to the pojo-bl module of the application.
	  \end{minipage}
	};
	
	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.4,1.5)}] at (-6.5,0.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package name}\newline
	  If the action is selected from a context menu that was invoked on a package then the package name gets populated automatically.
	  Otherwise it needs to be specified manually or selected for a dialog that is accessible via button \emph{Browse}.
	  \end{minipage}
	};
	

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,1.2)}] at (3.0,3.2) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Master Entity Type}\newline
	  This is a name of the class representing an entity object that should be used as a master to the one-2-one class being created.
	  \end{minipage}
	};      
	
	
	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,0.7)}] at (5.0,-0.1) 
	{
	  \begin{minipage}{3.5cm}
	  \tiny
	  \textbf{Name}\newline
	  This is a class name that should adhere to camel case naming convention.
	  It is used as the name for a class representing an entity object.
	  \end{minipage}
	};      

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,0.0)}] at (2.0,-2.1) 
	{
	  \begin{minipage}{4cm}
	  \tiny
	  \textbf{Superclass}\newline
	  All entity objects are descendants of class \texttt{AbstractEntity}.
	  The key for one-2-one entity is always the type of the specified master entity.
	  In this case, class \texttt{Bogie} becomes entity's key.
	  \end{minipage}
	};      

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.4,-1.0)}] at (-6.5,-2) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Options}\newline
	  Provides support for customising an entity being generated.
	  More details about each option are outlined in the text.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}  
  
  Due to compositional relationship between master and one-2-one entities, the plugin requires (see Fig.~\ref{img:ch02:00:model-actions-new-one-2-one-entity}) to specify the master entity at the time of one-2-one entity creation.
  The master entity can be provided once the creation dialog is up.
  However, it is only natural to invoke one-2-one entity creation upon an entity object class in \emph{Package Explorer}.
  This way, the plugin automatically fills in the \emph{Master Entity Type} entry as well as the package name.
  Other than the requirement to enter master entity, the prompts are identical to the dialog for a master entity creation.  
  Please note that as discussed in section~\ref{ch01:02}, the role of the maser entity for a one-2-one entity can be played only by entities that qualify as such (i.e. persistent entities with business key of a non-entity type).  
  
  The depicted in Fig.~\ref{img:ch02:00:model-actions-new-one-2-one-entity} dialog has resulted from an action invoked on class \texttt{Bogie}.
  Entity \texttt{Bogie} is automatically selected to serve as a master entity for a new one-2-one entity being created.
  The provided figure contains relevant annotations that explain the purpose of all inputs.

  As before, let's discuss the generated artefacts using a concrete example.
  Due to the fact that most artefacts are almost identical to those discussed in the previous chapter, we shall concentrate only on the aspects specific to one-2-one entities.
  
  Let's consider a new entity \texttt{BogieTechDetails} that models technical specification for a bogie.
  Each bogie should have its own specific technical specification such as serial number, extended description etc.
  Thus, domain entity \texttt{BogieTechDetails} nicely fits the one-2-one entity kind.
  As can be seen from Fig.~\ref{img:ch02:00:model-actions-new-one-2-one-entity} by default the option to support deletion is unchecked.
  This is a very reasonable choice as there is no a really good reason to delete \texttt{BogieTechDetails} separately from its master entity.
  It is more likely to modify such entity, and delete is only as part of the \texttt{Bogie} deletion process.
  This can be done as part of the implementation for \texttt{delete} methods in class \texttt{BogieDao}.
  
  Listing~\ref{lst:ch02:00:BogieTechDetails} outlines the source of the created entity object \texttt{BogieTechDetails}.
  Its most important aspect is the use of type \texttt{Bogie} as the key type parameter.
  This ensures that the identity of concrete \texttt{Bogie} instances become the identity for corresponding to them \texttt{BogieTechDetails} instances (including the database side of things).

  \begin{code}{One-2-One entity \texttt{BogieTechDetails}.}{\label{lst:ch02:00:BogieTechDetails}}{codebgcolor}
  \begin{lstlisting}
@MapEntityTo
@KeyType(Bogie.class)
@KeyTitle(value = "Tech Details", desc = "Technical bogie details.")
@CompanionObject(IBogieTechDetails.class)
public class BogieTechDetails extends AbstractEntity<Bogie> { %\tikzref{bogie-key-type-parameter}{-1.0cm}{0.1cm}%
...    
}    
  \end{lstlisting}
  \tikznote{bogie-key-type-parameter-annotation}{bogie-key-type-parameter}{1.0cm}{1.5cm}{5cm}{Key type parameter}{
    One-2-one entity has its master type as the key type parameter.
    The same value is specified for annotation \texttt{@KeyType}.
  }
  \vspace*{-7px}  
  \end{code}      
  
  Usually it is desirable to have a one-2-one entity object to be accessible via an instance of its master entity object.
  This can be easily achieved by declaring property of type \texttt{BogieTechDetails} as part of \texttt{Bogie} type definition.
  As discussed earlier in the book, new property can be easily created by using template \texttt{tgprop-entity} in the source of entity \texttt{Bogie}.
  Listing~\ref{lst:ch02:00:Bogie-with-tech-details} outlines a code snippet of the modified \texttt{Bogie} source.

  \begin{notebox}{Why \texttt{@MapTo} is missing?}{\label{nb:mapto-missing-from-one-2-one-prop}}
    Association of the master entity with its one-2-one subordinate entities has a computational nature.
    From the persistence point of view, a table that holds one-2-one entity objects \emph{references} the table for a corresponding master object -- not the other way around.
    Therefore, it is important to remove annotation \texttt{@MapTo} from property declaration in this case.
  \end{notebox}
  
  Incorporation of property \texttt{techDetails} into \texttt{Bogie} makes it automatically available for data analysis and modification as part of the \texttt{Bogie} context.
  This holds true for either graph traversal with EQL, ordinary access of properties on entity instances or using it from an entity centre as part of the client application.
  Of course, it should not be forgotten to register \texttt{BogieTechDetails} as part of the domain in class \texttt{ApplicationDomain}.
  
  \begin{code}{\texttt{Bogie} with \texttt{BogieTechDetails}.}{\label{lst:ch02:00:Bogie-with-tech-details}}{codebgcolor}
  \begin{lstlisting}
@MapEntityTo
@KeyType(String.class)
@KeyTitle(value = "Bogie Code", desc = "A code uniquely representing a bogie.")
@DescTitle("Description")
@CompanionObject(IBogie.class)
public class Bogie extends AbstractEntity<String> { 
...
  @IsProperty %\tikzref{tech-det-prop-no-map-to}{0.0cm}{-0.1cm}%
  @Title(value = "Tech Details", desc = "Techical details of this bogie.")
  private BogieTechDetails techDetails;%\tikzref{tech-det-prop}{-1.0cm}{0.1cm}%

  @Observable
  @EntityExists(BogieTechDetails.class)
  public Bogie setTechDetails(final BogieTechDetails techDetails) {
    this.techDetails = techDetails;
    return this;
  }

  public BogieTechDetails getTechDetails() {
    return techDetails;
  }
...    
}    
  \end{lstlisting}
  \tikznote{tech-det-prop-annotation}{tech-det-prop}{6.0cm}{1.5cm}{5cm}{One-2-one property}{
    Property \texttt{techDetails} represents a composition of entity \texttt{BogieTechDetails} into its master entity \texttt{Bogie}.
  }
  \tikznote{tech-det-prop-no-map-to-annotation}{tech-det-prop-no-map-to}{8.0cm}{-3.0cm}{6cm}{Skip \texttt{@MapTo}}{
    Properties of one-2-one nature should not be declared with annotation \texttt{@MapTo} as their association with the master entity is reversed from the persistence point of view -- a table holding one-2-one entity objects \emph{references} the table for its master object.    
  }    
  \vspace*{-7px}
\end{code}      

    
  \subsection{Creation of Entities that Model One-2-Many Association}  
  
  The one-2-many kind of entities have a composite key, where a corresponding mater entity is always a part of -- one of the composite key members.
  From the entity object definition perspective this is the only principle differentiator of this entity kind from the rest.
  However, semantically one-2-many entities are more rich than one-2-one kind.
  Their association with master entity may have either aggregational or compositional meaning, which depends strictly on the specific nature of the modelled domain.
  
  A good example for compositional association is the purchase order that may have multiple items.
  If a purchase order is removed then it is only natural to remove its items.
  As the same time, in the library domain, books associated with library are not necessarily removed if a library that holds them gets closed.
  Those books could be relocated to another library before their master library closes.
  
  As before, let's consider a concrete example to demonstrate plugin in action and discuss the generated artefacts.
  The \texttt{Bogie} entity is chosen as the master enitity, which is used to create a new one-2-many entity \texttt{WheelsetSlot}.
  Each bogie may have one or more slots.
  Fig.~\ref{img:ch02:00:model-actions-new-one-2-many-entity} depicts a dialog invoked from a context menu on entity \texttt{Bogie}.
  This enityt is then automatically used as the master entity type.
  The provided annotations describe the dialog prompts, which are almost identical to the ones used for one-2-one entity creation.
  
  The new entity \texttt{WheelsetSlot} models a physical part of a bogie that is used for mounting wheelsets onto the bogie.
  Every instance of this entity, represents a concrete physical part and thus needs to be associated with a specific instance of entity \texttt{Bogie}.
  Also, every wheelset slot has a sequential number starting with 1 that represents slot's position on a bogie.
  Together, a bogie and a slot position on that bogie, uniquely identify a concrete wheelset slot.
  Therefore, entity \texttt{WheelsetSlot} has a composite business key, which is modelled with type \texttt{DynamicEntityKey}.
  

  \begin{image}{Create One-2-Many Entity/Companion Objects.}{\label{img:ch02:00:model-actions-new-one-2-many-entity}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	    \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-03-new-one-2-many-entity.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,2.2)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Source folder}\newline
	  Regardless of where the context menu is invoked, the source folder is identified automatically and always points to the pojo-bl module of the application.
	  \end{minipage}
	};
	
	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.4,1.5)}] at (-6.5,0.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package name}\newline
	  If the action is selected from a context menu that was invoked on a package then the package name gets populated automatically.
	  Otherwise it needs to be specified manually or selected for a dialog that is accessible via button \emph{Browse}.
	  \end{minipage}
	};
	

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,1.2)}] at (3.0,3.2) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Master Entity Type}\newline
	  This is a name of the class representing an entity object that should be used as a master to the one-2-many class being created.
	  \end{minipage}
	};      
	
	
	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,0.7)}] at (5.0,-0.1) 
	{
	  \begin{minipage}{3.5cm}
	  \tiny
	  \textbf{Name}\newline
	  This is a class name that should adhere to camel case naming convention.
	  It is used as the name for a class representing an entity object.
	  \end{minipage}
	};      

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,0.0)}] at (2.0,-2.1) 
	{
	  \begin{minipage}{4cm}
	  \tiny
	  \textbf{Superclass}\newline
	  All entity objects are descendants of class \texttt{AbstractEntity}.
	  The key for one-2-many entity has always type \texttt{DynamicEntityKey}.
	  \end{minipage}
	};      

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.4,-1.0)}] at (-6.5,-2) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Options}\newline
	  Provides support for customising an entity being generated.
	  More details about each option are outlined in the text.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}  

    Listing~\ref{lst:ch02:00:WheelsetSlot} outlines the generated source of the \texttt{WheelsetSlot} class.
    The only modification that was done to this class after it was created, pertains to values in annotations \texttt{@KeyTitle}, \texttt{@DescTitle} and \texttt{@Title}.
    This was needed in order to provide more meaningful description of the entity and its properties.
    
  \begin{code}{One-2-many entity \texttt{WheelsetSlot}.}{\label{lst:ch02:00:WheelsetSlot}}{codebgcolor}
  \begin{lstlisting}
@MapEntityTo
@KeyType(DynamicEntityKey.class)
@KeyTitle(value = "Wheelset Slot", desc = "A slot on a bogie for mounting a wheelset.")
@CompanionObject(IWheelsetSlot.class)
@DescTitle(value = "Desc", desc = "Short annotation about this specific wheelset slot.")
public class WheelsetSlot extends AbstractEntity<DynamicEntityKey> {%\tikzref{key-type}{-2.0cm}{0.1cm}%

    @IsProperty
    @Title(value = "Bogie", desc = "Bogie where this slot belongs")
    @MapTo
    @CompositeKeyMember(1)%\tikzref{key-member-1}{0.1cm}{0.0cm}%
    private Bogie bogie;

    @Observable
    @EntityExists(Bogie.class)
    public WheelsetSlot setBogie(final Bogie value) {
        this.bogie = value;
        return this;
    }                        %\tikzref{key-member-1-accessors}{1.0cm}{0.1cm}%

    public Bogie getBogie() {
        return bogie;
    }

}
  \end{lstlisting}
  \tikznote{key-type-annotation}{key-type}{1.5cm}{1.7cm}{7cm}{Key type parameter}{
    All one-2-many entities have \texttt{DynamicEntityKey} as their key type, which represents a composite key that is identified dynamically from class structure.
  }
  \tikznote{key-member-1-annotation}{key-member-1}{6.0cm}{-0.3cm}{9cm}{Master as key member}{
    The master entity (\texttt{Bogie} in this case) is always one of the composite key members.
    Both the property name and its type are determined automatically using the specified master entity type.
    It is suggested to always make master entity to be the first key member, which is governed by value in annotation \texttt{@CompositeKeyMember}.
  }
  \tikznote{key-member-1-accessors-annotation}{key-member-1-accessors}{5.0cm}{-0.7cm}{5cm}{Key member accessors}{
    Accessors for composite key members are ordinary and have nothing special that would differentiate them form any other property accessors.
  }    
  \vspace*{-7px}
\end{code}          
    
    The generated entity includes only one key member, which was determined automatically based on the specified master entity type.
    Any additional members need to be added manually.
    This, however, can be conveniently done using template \texttt{tgprop-composite-key-entity-member} or \texttt{tgprop-composite-key-ordinary-member} in the source of entity \texttt{WheelsetSlot} in the place where a new property should be generated (e.g. underneath the \texttt{bogie} property).
    In our case, it is required to have the second key member \texttt{position} of type \texttt{Integer}.
    Therefore, template \texttt{tgprop-composite-key-ordinary-member} should be used to generate it.
    Listing~\ref{lst:ch02:00:WheelsetSlot-key-2} 
    
   \lstset{firstnumber=13}
  \begin{code}{Second key member for entity \texttt{WheelsetSlot}.}{\label{lst:ch02:00:WheelsetSlot-key-2}}{codebgcolor}
  \begin{lstlisting}
...
    @IsProperty
    @MapTo
    @Title(value = "Position", desc = "Slot's position")
    @CompositeKeyMember(2)%\tikzref{key-member-2}{0.1cm}{0.1cm}%
    private Integer position;

    @Observable
    public WheelsetSlot setPosition(final Integer position) {
	this.position = position;
	return this;
    }                           %\tikzref{key-member-2-accessors}{0.1cm}{0.0cm}%
                                            
    public Integer getPosition() {
	return position;
    }
...
  \end{lstlisting}
  \tikznote{key-member-2-annotation}{key-member-2}{3.5cm}{1.cm}{6cm}{Second key member}{
    Annotation \texttt{@CompositeKeyMember} for the second key member \texttt{position} should specify $2$ as its value.
  }
  \tikznote{key-member-2-accessors-annotation}{key-member-2-accessors}{5.0cm}{-0.7cm}{5cm}{Key member accessors}{
    Accessors for composite key members are ordinary and have nothing special that would differentiate them form any other property accessors.
  }    
  \vspace*{-7px}
\end{code}              
    
    
\section{Creation of Main Menu Items and Entity Centres}  
  
  
\section{Creation Entity Masters}
  
