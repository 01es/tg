\chapter{Tools}\label{ch02:00}

\myepigraph{The expectations of life depend upon diligence; the mechanic that would perfect his work must first sharpen his tools.}{Confucius}

  The platform can be used for developing software using any IDE for Java such as IntelliJ IDEA or Netbeans.
  However, the recommended IDE for this is Eclipse due to provided set of plugins developed specifically to facilitate TG-based development.
  
\section{Overview of Eclipse Plugins}

  The main features that are provided by the developed plugin pertain to automating creation of fractal objects, main menu items and UI.
  The provided automation is easily comparable to that provided by inbuilt Delphi features such as creation of forms and data modules.
  
  The plugin is distributed in a from of a jar file \texttt{tg-eclipse-plugin\_\textless version\textgreater.jar}.
  It can be installed by placing the jar into Eclipses \texttt{dropins} directory.
  Once installed, the plugin integrates with the \emph{Package Explorer} context menu.
  
  There are three groups of actions that can be invoked from a context menu:
  
  \begin{description}
    \item[\textbf{TG Model Actions.}] Represents actions that facilitate creation of different kinds of entity types.
    Fig.~\ref{img:ch02:00:model-actions} depicts the menu.
    
    \begin{itemize}
     \item \emph{Create Master Entity/Companion Objects\ldots} -- generates a pair of master entity and companion objects with respective DAO and RAO default implementations for the companion object.
     \item \emph{Create One-2-One Entity/Companion Objects\ldots} -- generates a pair of entity and companion objects with respective DAO and RAO default implementations for the companion object: the generated entity models a one-2-one relationship with a master entity, which gets specified during creation.
     \item \emph{Create One-2-Many Entity/Companion Objects\ldots} -- generates a pair of entity and companion objects with respective DAO and RAO default implementations for the companion object; the generated entity models a one-2-many relationship with a master entity, which gets specified during creation.
    \end{itemize}

    \begin{image}{Entity model creation actions.}{\label{img:ch02:00:model-actions}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	    \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-tg-model-actions.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,1.8)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package Explorer}\newline
	  The actions are integrated into the context menu of Package Explorer.
	  \end{minipage}
	};

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(2,-3.8)}] at (5,-2.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Subitem}\newline
	  Three actions for creating different kinds of entity objects.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}
    
    
    \item[\textbf{TG Menu Actions.}] Represents actions that facilitate creation of the application main menu items.
    Fig.~\ref{img:ch02:00:menu-actions} depicts the menu.
    
    \begin{itemize}
     \item \emph{Create Group Menu\ldots} -- generates a menu item that can be used for grouping of sub-items.
     \item \emph{Create Simple Menu} -- generates the most trivial menu item for a selected entity that gets associated with a centre for that entity.
     \item \emph{Create Menu Entry with Custom Command} -- generates a menu items for a selected entity that gets associated with a centre for that entity, and provides a stub for a custom action.
    \end{itemize}

    \begin{image}{Menu Actions.}{\label{img:ch02:00:menu-actions}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	  \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/02-tg-menu-actions.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,1.8)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package Explorer}\newline
	  The actions are integrated into the context menu of Package Explorer.
	  \end{minipage}
	};

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(2,-4.0)}] at (5,-2.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Subitem}\newline
	  Three actions for creating different kinds of application main menu items.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}
    
    \item[\textbf{TG Master Actions.}] Represents actions that facilitate creation of various kinds of entity master forms that are used as a front end for creation and modification of entity instances. 
    Fig.~\ref{img:ch02:00:master-actions} depicts the menu.
    
    \begin{itemize}
     \item \emph{Create Simple Master for Entity} -- generates a pair of UI model and view that represent an simple entity master form; suitable for entities that do not have (or do not require) one-2-many associations.
     \item \emph{Create Compound Master for Entity} -- generates UI (a model and two views) that assumes a master form with a tree menu, where each menu item (except the first) represents some association for a selected during generation entity; only the first item menu item is generated that gets associated with a view for entry and modification of non-collectional entity properties (one can think of it as main entity data).
     \item \emph{Create Compound Master Sub Model/View for Entity (One-2-One)\ldots} -- generates a pair of UI sub-model and sub-view that should be associated with some compound master; this UI pair is generated for an entity that is in one-2-one association to some master entity object; the UI provides means to create and modify instances of the subordinate entity object with automatic association to a corresponding master entity object.
     \item \emph{Create Compound Master Sub Model/View for Entity (One-2-Many)\ldots} -- generates a pair of UI sub-model and sub-view that should be associated with some compound master; this UI pair is generated for an entity that is in one-2-many association to some master entity object; the UI provides means to create and modify multiple instance of the subordinate entity object with automatic association to a corresponding master entity object.
     \item \emph{Create Compound Master Sub Model/View for Entity (One-2-Many Centre-Based)\ldots} -- generates a pair of UI sub-model and sub-view that resembles an entity centre where selection criteria section is configured at the source level; this kind of UI also supports customisation of the toolbar by providing custom actions; the resultant from such model queries are automatically enhanced with a filtering condition to show only instances that are associated with a corresponding master entity object.
     \item \emph{Create Entity Producer with User} -- generates an entity producer that gets used for creation of new entity instances on master forms; the generated producer contains the code for obtaining system user at runtime, which comes handy when new entities should be initialised with the information about their creator.
    \end{itemize}

    \begin{image}{Master Actions.}{\label{img:ch02:00:master-actions}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	  \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/03-tg-master-actions.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,1.8)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package Explorer}\newline
	  The actions are integrated into the context menu of Package Explorer.
	  \end{minipage}
	};

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(2,-2.8)}] at (5,-0.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Subitem}\newline
	  Actions for creating UI artefacts such as models and views for entity master forms, entity producers used by master forms.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}
    
    
  \end{description}

  Some of the actions should be invoked on specific classes or packages, and generate associated with them artefacts without any additional parameters.
  However, other actions bring up wizards that require specific inputs, and only once those inputs are populated, can be used to generated associated artefacts.
  Some of the inputs get populated based on the invocation context (e.g. package name can be populated if the context menu was invoked on a package).
  The following sections delves more into the details about specific plugin actions.

\section{Creation of Entity Objects}
  
  This section covers the first group of actions that are designed to assist developers in creation of entity objects that are the bread and butter of the domain modelling with the platform.

  As has been discussed in section~\ref{ch01:02} all entity objects can be distilled down to three principle kinds:
  
  \begin{itemize}
   \item Master entity;
   \item Subordinate one-2-one entity that gets associated with a single master entity;
   \item Subordinate one-2-many entity where one or more instances get associated with a single master entity.
  \end{itemize}

  In reality the situation could get a lot more complex as any of the one-2-one and one-2-many kinds may act in turn as master entities to other subordinate types. 
  This is, however, only natural if the domain inherently requires such complexity.  
  Thus, there are three actions -- one for creating each kind of an entity object.
  
  \subsection{Creation of Master Entities}
  
  The master entity together with its companion object can be created using action \emph{Create Master Entity/Companion Objects\ldots}.
  Fig.~\ref{img:ch02:00:model-actions-new-master-entity-01} depicts a wizard window that gets displayed upon action invocation.
  It is most natural for this action to be invoked on a package within the pojo-bl application module where an intended entity object should reside.
  This way the plugin automatically populates the package entry as illustrated in Fig.~\ref{img:ch02:00:model-actions-new-master-entity-01}.
  Otherwise, the package should be specified.

  \begin{image}{Create Master Entity/Companion Objects.}{\label{img:ch02:00:model-actions-new-master-entity-01}}
    \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
      \pgftext{%
	  \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-01-new-master-entity.png}
      }%

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,2.0)}] at (-6.5,3.5) 
      {
	\begin{minipage}{3cm}
	\tiny
	\textbf{Source folder}\newline
	Regardless of where the context menu is invoked, the source folder is identified automatically and always points to the pojo-bl module of the application.
	\end{minipage}
      };
      
      \node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.3,1.4)}] at (-6.5,1.0) 
      {
	\begin{minipage}{3cm}
	\tiny
	\textbf{Package name}\newline
	If the action is selected from a context menu that was invoked on a package then the package name gets populated automatically.
	Otherwise it needs to be specified manually or selected for a dialog that is accessible via button \emph{Browse}.
	\end{minipage}
      };
      

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(2.0,1.0)}] at (5.0,3.1) 
      {
	\begin{minipage}{3cm}
	\tiny
	\textbf{Name}\newline
	This is a class name that should adhere to camel case naming convention.
	It is used as the name for a class representing an entity object.
	\end{minipage}
      };      

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(2.0,0.5)}] at (7.0,1.0) 
      {
	\begin{minipage}{4cm}
	\tiny
	\textbf{Superclass}\newline
	All entity objects are descendants of class \texttt{AbstractEntity}.
	The assumed key type for master entity is \texttt{String} with \texttt{Integer} as an option that could be specified one classes are created.	
	\end{minipage}
      };      

      \node [overlay, note=annotationbgcolor, callout absolute pointer={(0,-0.7)}] at (4,-1) 
      {
	\begin{minipage}{4cm}
	\tiny
	\textbf{Options}\newline
	Provides support for customising an entity being generated.
	More details about each option are outlined in the text.
	\end{minipage}
      };
    \end{tikzpicture}  
  \end{image}  
  
  Most of the options in this wizard are described in Fig.~\ref{img:ch02:00:model-actions-new-master-entity-01}.
  However, the provided checkbox options require a little bit more explanation.
  \begin{description}
   \item[\textbf{should have property 'desc'}] -- 
   specifies whether entity object should have the description property; most entities requires or may use such property as comes at no cost; 
   presence or absence of property \texttt{desc} is controlled via annotation \texttt{@DescTitle}; 
   if this annotation is not declared as part of entity object definition then property \texttt{desc} is recognised by the platform as absent;

   \item[\textbf{should be persistent}] -- 
   if a synthesised or a functional entity needs to be created then this option should be unchecked; such entities do not usually have a persistent state; 
   however, if a persistent entity needs to be created then this option should be left on; from our experience the number of persistent entities is significantly greater than that of synthesised or a functional entities, thus by default this option if on;

   \item[\textbf{use mixin for common RAO/DAO code}] -- 
   often methods in RAO and DAO that implement companion object contract have exactly the same implementation\footnote{This happens mainly due to the universal execution model for CRUD operations (including EQL queries) that works seamlessly at both the client and server sides.)}; 
   in order to avoid code duplication to improve system maintainability, it makes sense to place the common for RAO and DAO methods into a single class that could be than reused in both places; 
   the platform provides a convenient support for this in a form of a \emph{\href{http://en.wikipedia.org/wiki/Mixin}{mixin}} -- a class that should contains common methods and has a companion object (an interface) as its constructor argument; such mixin can be naturally mixed into both RAO and DAO implementations by means of composition; 
   if this option is selected then a mixin class would get generated and integrated into the RAO and DAO classes that also get generated as part of entity object creation;

   \item[\textbf{support deletion}] -- 
   many, especially persistent entities, may require deletion support; 
   by default deletion is disabled at the base level of the common companion object ancestor that is provided by the platform, and needs to be enabled explicitly by overriding corresponding methods; 
   in most cases deletion is safe due to automatic management of dependencies between entities, but due to severity of such action by default it is disabled; 
   this option should be selected if support for deletion is required for the entity being created.
  \end{description}
 
  Once all the required inputs are populated, button \emph{Finish} becomes enabled.
  Pressing it leads to the generation of a number of classes and interfaces that together represent an entity object, a companion object, RAO and DAO implementations for a companion object, and a mixin class (depending on options selected).
  At the end, the wizard produces a warning advising the developer to register the generated entity type as part of the application domain.
  This is done by calling static method \texttt{add} with the class for entity object as an argument in the static initialisation block of class \texttt{ApplicationDomain}.
  Every TG-based application is provided with class \texttt{ApplicationDomain}, and the place where new entities should registered becomes obvious once \texttt{ApplicationDomain} is open in the code editor.
  
  In order to describe the generated artefacts let's consider a concrete example based on our illustrative application \emph{collapp} that models a fraction of the rail domain.
  Let the name of the generated master entity be \texttt{Bogie}, and let's also consider that its package is \texttt{fielden.rail} and that all options on the entity wizard have been selected (including deletion and mixin options).
  Fig.~\ref{img:ch02:00:model-actions-new-master-entity-artefacts} depicts a UML diagram that specifies all classes that are generated and their location in terms of packages and application modules.
  
  \begin{image}{Create Master Entity/Companion Objects Artefacts.}{\label{img:ch02:00:model-actions-new-master-entity-artefacts}}
    \begin{tikzpicture}
      \draw[very thick, dashed, color=blue!30, rounded corners] (-2.3, 2.5) rectangle (3.0,-1.5);
      \node[rotate=90,color=blue!50!black] at (-2.6, 1.5) {\small coolapp-dao};
      \begin{umlpackage}[x=0,y=0,fill=blue!30]{fielden-rail}
        \umlemptyclass[x=0,y=0,template={Bogie}]{BogieDao}
      \end{umlpackage}
      
      \draw[very thick, dashed, color=green!30, rounded corners] (4.5, 2.5) rectangle (9.8,-1.5);
      \node[rotate=90,color=green!50!black] at (4.2, 1.5) {\small coolapp-rao};
      \begin{umlpackage}[x=7.0,y=0,fill=green!30]{fielden-rail}
        \umlemptyclass[x=0,y=0,template={Bogie}]{BogieRao}
      \end{umlpackage}

      \draw[very thick, dashed, color=red!30, rounded corners] (-2.0, -2.3) rectangle (9.5,-7.0);
      \node[rotate=90,color=red!50!black] at (-2.3, -3.5) {\small coolapp-pojo-bl};
      \begin{umlpackage}[x=-1.5,y=-5,fill=red!30]{fielden-rail}
        \umlemptyclass[x=1,y=0]{Bogie}
        \umlemptyclass[x=3.5,y=0,width=3cm,template={Bogie},type=companion]{IBogie}
      \end{umlpackage}
      \begin{umlpackage}[x=7.0,y=-5,fill=red!30]{fielden-rail-mixin}
        \umlemptyclass[x=0.2,y=0,type=mixin, width=3cm]{BogieMixin}
      \end{umlpackage}            

      % associations
      \umluniaggreg{BogieMixin}{IBogie}
      \umluniaggreg{BogieRao}{BogieMixin}
      \umluniaggreg[anchors=-30 and 160]{BogieDao}{BogieMixin}
      \umlVHVinherit[anchors=-120 and 60]{BogieRao}{IBogie}
      \umlVHVinherit{BogieDao}{IBogie}
    \end{tikzpicture}
  \end{image}  
  
  The depicted diagram consists of three application modules:
  \begin{description}
   \item[\textbf{coolapp-pojo-bl}] -- contains class \texttt{Bogie} that defines an entity object with the same name and an interface \texttt{IBogie} that defines a corresponding companion object; both are located in the same package \texttt{fielden.rail}; the generated mixin class \texttt{BogieMixin} is placed into a subpackage \texttt{fielden.rail.mixin}; as can be understood from the diagram, it aggregates the companion object;
   \item[\textbf{coolapp-rao}] -- contains class \texttt{BogieRao} that provides RAO implementation for the companion object; it also aggregates the mixin class;
   \item[\textbf{coolapp-dao}] -- contains class \texttt{BogieDao} that provides DAO implementation for the companion object; it also aggregates the mixin class.
  \end{description}

  The concept of a mixin is probably the most complex -- all other aspects of a domain entity implementation has been covered in previous parts.
  Thus, it prompts to address mixins with greater care.
  Please recall that neither module \texttt{coolapp-pojo-bl} is aware of modules \texttt{coolapp-rao} and \texttt{coolapp-dao} nor modules \texttt{coolapp-rao} and \texttt{coolapp-dao} are aware of each other.
  Thus, there is a clean separation between the RAO and DAO implementations.  
  The core functionality that is required by any companion object is implemented by classes \texttt{CommonEntityDao} and \texttt{CommonEntityRao}, which are extended by corresponding companion DAO and RAO implementations (\texttt{BogieDao} and \texttt{BogieRao} in this case).  
  However, both these implementations must adhere to the contract defined by the companion object (\texttt{IBogie} in this case).
  
  When a new method is defined at the companion object then both \texttt{BogieDao} and \texttt{BogieRao} must implement it.
  Often, implementation for domain specific methods that are defied as part of companion objects are identical between the RAO and DAO counterparts.
  So, it only makes sense to have a single implementation that could be reused by both classes.  
  Let's consider that companion object \texttt{IBogie} defines method \texttt{lastMovement} as per listing~\ref{lst:ch02:00:IBogie}, and let's also consider that this method can be implemented identically for RAO and DAO.
  This means that both \texttt{BogieDao} and \texttt{BogieRao} would have code duplication that is very much error prone as someone could later update implementation only in DAO, but not in RAO or wise versa.
  
   \lstset{language=Java,
	  escapechar=\%,
	  numbers=left, numberstyle=\tiny, basicstyle=\scriptsize\color{basiccolor}, stepnumber=1, numbersep=5pt, keywordstyle=\bfseries\color{codefgcolor}, stringstyle=\color{stringcolor}}
  \begin{code}{\texttt{IBogie} definition.}{\label{lst:ch02:00:IBogie}}{codebgcolor}
    \begin{lstlisting}
public interface IBogie extends IEntityDao<Bogie> {
    BogieMovement lastMovement(final Bogie bogie);
}
    \end{lstlisting}
  \end{code}
  
  This is where the concept of a mixin comes handy.
  Instead of duplicating the code, class \texttt{BogieMixin} gets created in the \texttt{coolapp-pojo-bl} module, so that both  \texttt{BogieDao} and \texttt{BogieRao} could reuse it.
  This is a very simple class with no special inheritance requirements.
  Its only concern is to provide implementation for the required methods (\texttt{lastMovement} in this case).
  
  As can be observed from the method definition, its return type is \texttt{BogieMovement}, which identifies another domain entity with its companion \texttt{IBogieMovement}\footnote{In order to keep this example concise we won't present any source for entity \texttt{BogieMovement} -- strictly speaking this is not necessary as it would be very similar to what we're currently discussing.}.
  This means that the implementation of method \texttt{lastMovement} depends on this domain entity (both entity and companion object).
  A special interest here is in the companion object \texttt{IBogieMovement}, which is required in order to make requests about the movement data.
  This means that our mixin would need to aggregate an instance of \texttt{IBogieMovement}.
  
  Listing~\ref{lst:ch02:00:BogieMixin-def} shows the definition for \texttt{BogieMixin}, but without the implementation for method \texttt{lastMovement}.
  As can be observed it contains two fields \texttt{coBogie} and \texttt{coBogieMovement} that get assigned in the constructor~(lines 9--10).
  The constructor can be modified to accept as many arguments as required to provide the necessary functionality.
  Please note that both the fields and arguments are defined in terms of companion object types, which are interfaces.
  The relevant DAO or RAO implementations are provided at the time of mixin construction as discussed later.
  
  Strictly speaking \texttt{BogieMixin} does not require \texttt{coBogie} as only \texttt{coBogieMovement} is used for implementing method \texttt{lastMovement}.
  However, it is a recommend practice to provide mixins with corresponding companion objects as in most cases they do get used, and not providing them early would require later modification to both DAO and RAO implementations in order to pass in an additional constructor argument.
  Also, providing them early does not introduce any difficulty and does not inflict any additional complexity.
  
  %// prefix co stands for Companion Object followed by the entity name
    \begin{code}{\texttt{BogieMixin} definition.}{\label{lst:ch02:00:BogieMixin-def}}{codebgcolor}
    \begin{lstlisting}
public class BogieMixin {

    private final IBogie coBogie; %\tikzref{fields-definitions}{0.5cm}{0.0cm}%
    private final IBogieMovement coBogieMovement; 

    public BogieMixin(
           final IBogie coBogie, %\tikzref{argument-definitions}{0.5cm}{0.0cm}%
           final IBogieMovement coBogieMovement) {
      this.coBogie = coBogie;
      this.coBogieMovement = coBogieMovement;
    }
    
    public BogieMovement lastMovement(final Bogie bogie) { ... }
    
}
    \end{lstlisting}
    \tikznote{fields-definitions_annotation}{fields-definitions}{5cm}{1.0cm}{5cm}{Field definitions}{
           Both fields are immutable and defined as interface values that represent respective companion objects.
           
           The name of the fields follow a naming convention whereby the prefix \texttt{co} stends for Companion Object, followed by the entity name.
    }
    \tikznote{argument-definitions_annotation}{argument-definitions}{5cm}{0.5cm}{4cm}{Argument definitions}{
           Argument definitions resemble the definitions of the fields that they initialise.
    }        
  \end{code}
  
  Listing~\ref{lst:ch02:00:BogieMixin-impl} provides a possible implementation for method \texttt{lastMovement}.
  First, a select model is constructed that declares filter conditions for bogie movements.
  Then this model is provided with an object graph population model (aka fetch model) and used to get a single \texttt{BogieMovement} entity that represents the last movement of the specified bogie.
  The fetch model should be specific to the usecase needs where the use of method \texttt{lastMovement} is intended.
  It can be easily foreseen that in order to provide more flexibility, a fetch model could be provided as either a method or a constructor argument.
  
  \begin{code}{Implementation of method \texttt{lastMovement}.}{\label{lst:ch02:00:BogieMixin-impl}}{codebgcolor}
  \begin{lstlisting}
...
public BogieMovement lastMovement(final Bogie bogie) { 
  final EntityResultQueryModel<BogieMovement> select = 
	      select(BogieMovement.class).
	      where().
		prop("bogie").eq().val(bogie).and(). %\tikzref{concrete-bogie}{0.1cm}{0.1cm}%
		notExists(
		  select(BogieMovement.class).where(). 
		  prop("bogie").eq().extProp("bogie").and(). %\tikzref{latest-movement}{0.1cm}{0.2cm}%
		  prop("inDate").gt().extProp("inDate").model()).
	      model();
  return coBogieMovement.getEntity( %\tikzref{fetch-model}{-0.5cm}{-0.3cm}%
         from(select).with(fetchAll(BogieMovement.class)).model());    
}
  ...
  \end{lstlisting}
  \tikznote{concrete-bogie-annotation}{concrete-bogie}{2.8cm}{1.7cm}{4cm}{Where condition 1}{
	  Consider only movements for the specified bogie.
  }
  \tikznote{latest-movement-annotation}{latest-movement}{3.0cm}{1.0cm}{3cm}{Where condition 2}{
	  Consider only those movements that none other exists, which were performed later.
	  This effectively means the condition to select the latest movement.
  }
  \tikznote{fetch-model-annotation}{fetch-model}{3.8cm}{-0.9cm}{4cm}{Fetch model}{
	  The fetch model declares that all non-collectional properties of the resultant \texttt{BogieMovement} instance are to be fetched.
  }    
\end{code}
 
  Once the mixin is implemented it needs to be integrated into both RAO and DAO implementations of the companion object.
  Such integration is basically identical for both RAO and DAO, and consists of two basic steps -- mixin instantiation and invocation of its methods for reuse.
  Listings~\ref{lst:ch02:00:BogieDao-mixin} and~\ref{lst:ch02:00:BogieRao-mixin} outline these steps and provide relevant code annotations.
  
  \begin{code}{Mixin reuse in \texttt{BogieDao}.}{\label{lst:ch02:00:BogieDao-mixin}}{codebgcolor}
  \begin{lstlisting}
@EntityType(Bogie.class)
public class BogieDao extends CommonEntityDao<Bogie> implements IBogie {
      
  private final BogieMixin mixin;%\tikzref{mixin-declaration}{0.1cm}{0.1cm}%
    
  @Inject
  protected BogieDao(final IFilter filter, final IBogieMovement coBogieMovement) {%\tikzref{co-argument}{-2.0cm}{0.2cm}%
    super(filter);
    mixin = new BogieMixin(this, coBogieMovement);%\tikzref{mixin-instantiation}{0.1cm}{0.1cm}%
  }

  @Override
  public BogieMovement lastMovement(final Bogie bogie) { 
    return mixin.lastMovement(bogie);%\tikzref{mixin-reuse}{0.1cm}{0.1cm}%
  }
  
  @Override
  @SessionRequired
  public void delete(final Bogie entity) {
    defaultDelete(entity);
  }
                                           %\tikzref{support-deletion}{0.0cm}{0.0cm}%
  @Override
  @SessionRequired
  public void delete(
                 final EntityResultQueryModel<Bogie> model, 
                 final Map<String, Object> paramValues) {
    defaultDelete(model, paramValues);
  }  
}
  \end{lstlisting}
  \tikznote{mixin-declaration-annotation}{mixin-declaration}{3.8cm}{-0.2cm}{4cm}{Mixin declaration}{
    An immutable instance of mixin, which is initialised in the constructor.
  }
  \tikznote{co-argument-annotation}{co-argument}{2.0cm}{2.0cm}{4cm}{\texttt{IBogieMovement} argument}{
    An instance of \texttt{IBogieMovement} as concrete class \texttt{BogieMovementRao} is provided automatically by the injector.
  }
  \tikznote{mixin-instantiation-annotation}{mixin-instantiation}{3.8cm}{-0.5cm}{4cm}{Mixin instantiation}{
    Mixin is instantiated as an ordinary object using operation \texttt{new} and passing in the expected constructor arguments.
  }
  \tikznote{mixin-reuse-annotation}{mixin-reuse}{3.8cm}{-0.5cm}{4cm}{Mixin reuse}{
    Mixin reuse boils down to a simple invocation of method \texttt{lastMovement} that is implemented by the mixin.
  }
  \tikznote{support-deletion-annotation}{support-deletion}{5.0cm}{-1.0cm}{4cm}{Support deletion}{
    Selecting support deletion option leads to generation of two methods in DAO that override the default implementation inherited from CommonEntityDao.
    The default implementation throws \texttt{UnsupportedOperation} exception.
    The RAO implementation does not require such modification as its default deletion support delegates request to a corresponding entity web resource, which in turn delegates the call to DAO.
  }  
\end{code}  
  
  \begin{code}{Mixin reuse in \texttt{BogieRao}.}{\label{lst:ch02:00:BogieRao-mixin}}{codebgcolor}
  \begin{lstlisting}
@EntityType(Bogie.class)
public class BogieRao extends CommonEntityRao<Bogie> implements IBogie {
  
  private final BogieMixin mixin;%\tikzref{mixin-declaration}{0.1cm}{0.1cm}%
  
  @Inject
  public BogieRao(final RestClientUtil restUtil, final IBogieMovement coBogieMovement) {%\tikzref{co-argument}{-2.0cm}{0.2cm}%
    super(restUtil);
    mixin = new BogieMixin(this, coBogieMovement);%\tikzref{mixin-instantiation}{0.1cm}{0.1cm}%
  }

  @Override
  public BogieMovement lastMovement(final Bogie bogie) { 
    return mixin.lastMovement(bogie);%\tikzref{mixin-reuse}{0.1cm}{0.1cm}%
  }
}
  
  \end{lstlisting}
  \tikznote{mixin-declaration-annotation}{mixin-declaration}{3.8cm}{0.0cm}{4cm}{Mixin declaration}{
    An immutable instance of mixin, which is initialised in the constructor.
  }
  \tikznote{co-argument-annotation}{co-argument}{0.5cm}{2.0cm}{4cm}{\texttt{IBogieMovement} argument}{
    An instance of \texttt{IBogieMovement} as concrete class \texttt{BogieMovementRao} is provided automatically by the injector.
  }
  \tikznote{mixin-instantiation-annotation}{mixin-instantiation}{3.8cm}{-0.5cm}{4cm}{Mixin instantiation}{
    Mixin is instantiated as an ordinary object using operation \texttt{new} and passing in the expected constructor arguments.
  }
  \tikznote{mixin-reuse-annotation}{mixin-reuse}{3.8cm}{-0.5cm}{4cm}{Mixin reuse}{
    Mixin reuse boils down to a simple invocation of method \texttt{lastMovement} that is implemented by the mixin.
  }
\end{code}  

  It is worth mentioning that due to dependency of mixin \texttt{BogieMixin} on companion object \texttt{IBogieMovement}, there is a need to provide an instance of RAO implementation of \texttt{IBogieMovement} into \texttt{BogieRao} and DAO implementation into \texttt{BogieDao}.
  Fortunately, passing of constructor arguments that are companion objects is trivial due to inherent support of the \emph{injection of control} mechanism by the platform.
  The only requirement for the right instance of \texttt{IBogieMovement} to be injected into \texttt{BogieRao} and \texttt{BogieDao} is to annotate their constructors with annotation \texttt{@Inject} and declare an argument of type \texttt{IBogieMovement}.

  Just as a reminder from the previous part of the book, please recall that constructor argument \texttt{restUtil} in \texttt{BogieRao} and argument \texttt{filter} in \texttt{BogieDao} are standard for all RAO and DAO implementations of companion objects.
  This concludes the discussion of action \emph{Create Master Entity/Companion Objects\ldots} and the artefacts it generates.
 

  \subsection{Creation of Entities that Model One-2-One Association}  
 
  All supported by the platform kinds of associations are discussed in great detail section~\ref{ch01:02}.
  In essence all domain entities regardless of whether they're master or subordinate have almost identical structure -- all have an entity object, a companion object, its RAO and DAO implementation, need to be registered with class \texttt{ApplicationDomain} etc.
  
  The most significant difference is in the business key.  
  For one-2-one (and one-2-many for that matter) entity the type of the master entity becomes its business key type.
  Entities that model one-2-one association are designed to be used for composition rather than aggregation.
  This means that they represent an integral part of the master entity -- if the master entity ceases to exist then the associated with it one-2-one (and one-2-many for that matter) entities should also cease to exist.
  
  Due to compositional relationship between master and one-2-one entities, the plugin requires to specify the master entity at the time of one-2-one entity creation.
  The master entity can be provided once the creation dialog is up.
  However, it is only natural to invoke one-2-one entity creation upon an entity object class in \emph{Package Explorer}.
  This way, the plugin automatically fills in the \emph{Master Entity Type} entry as well as the package name.
  As explained in section~\ref{ch01:02}, the role of the maser entity for a one-2-one entity (or one-2-many for that matter) can be played by any kind of entities -- not just the actual master entities as per previous section.
  Other than requirement to enter master entity, the prompts are identical to the dialog for a master entity creation.
  
  Fig.~\ref{img:ch02:00:model-actions-new-one-2-one-entity} depicts the dialog presented once the action was invoked on class \texttt{Bogie}, which was selected to serve as a master entity for a new one-2-one entity being created.
  All of the input prompts are annotated with relevant descriptions that explain their purpose.  
 
  
  \begin{image}{Create One-2-One Entity/Companion Objects.}{\label{img:ch02:00:model-actions-new-one-2-one-entity}}
      \begin{tikzpicture}[remember picture, >=latex', note/.style={rectangle callout, rounded corners = 1pt, fill=annotationbgcolor, drop shadow}]
	\pgftext{%
	    \includegraphics[width=0.6\textwidth]{parts/02-part/chapters/00-tools/images/01-02-new-one-2-one-entity.png}
	}%

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4,2.2)}] at (-6.5,3.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Source folder}\newline
	  Regardless of where the context menu is invoked, the source folder is identified automatically and always points to the pojo-bl module of the application.
	  \end{minipage}
	};
	
	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.4,1.5)}] at (-6.5,0.5) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Package name}\newline
	  If the action is selected from a context menu that was invoked on a package then the package name gets populated automatically.
	  Otherwise it needs to be specified manually or selected for a dialog that is accessible via button \emph{Browse}.
	  \end{minipage}
	};
	

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,1.2)}] at (3.0,3.2) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Master Entity Type}\newline
	  This is a name of the class representing an entity object that should be used as a master to the one-2-one class being created.
	  \end{minipage}
	};      
	
	
	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,0.7)}] at (5.0,-0.1) 
	{
	  \begin{minipage}{3.5cm}
	  \tiny
	  \textbf{Name}\newline
	  This is a class name that should adhere to camel case naming convention.
	  It is used as the name for a class representing an entity object.
	  \end{minipage}
	};      

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(0.0,0.0)}] at (2.0,-2.1) 
	{
	  \begin{minipage}{4cm}
	  \tiny
	  \textbf{Superclass}\newline
	  All entity objects are descendants of class \texttt{AbstractEntity}.
	  The key for one-2-one entity is always the type of the specified master entity.
	  In this case, class \texttt{Bogie} becomes entity's key.
	  \end{minipage}
	};      

	\node [overlay, note=annotationbgcolor, callout absolute pointer={(-4.4,-1.0)}] at (-6.5,-2) 
	{
	  \begin{minipage}{3cm}
	  \tiny
	  \textbf{Options}\newline
	  Provides support for customising an entity being generated.
	  More details about each option are outlined in the text.
	  \end{minipage}
	};
      \end{tikzpicture}  
    \end{image}  
  
  \subsection{Creation of Entities that Model One-2-Many Association}  
  
\section{Creation of Main Menu Items and Entity Centres}  
  
  
\section{Creation Entity Masters}
  
