\chapter{Platform Architecture}\label{ch01:01}

  There two main approaches to describe software architecture -- top-down and bottom-up\footnote{\url{http://en.wikipedia.org/wiki/Top-down_and_bottom-up_design}}.
  In this and the following parts of the book we should utilise the bottom-up approach by discussing the parts of the pazzle, which will be put together in order to construct a final picture of the platform in a form a relatively complex application.

  A high-level platform overview is provided as a separate document, which can be downloaded \href{http://www.fielden.com.ua/trac/pnl-tg/attachment/wiki/WikiStart/architecture-overview.pdf}{separately}.

\section{Domain Driven Design}

  At the heart of the platform's domain orientation is the concept of an \emph{entity type} -- a way to decribe that a business domain entity is.
  In Object-Oriented languages such as Java types are most frequently\footnote{Pribimitives in Java are represented as instances of int, double, float etc., which are also types} represented as classes.
  For exemple, class \texttt{java.lang.String} is a type representing a sequence of characters.
  
  Each type has its definition, which can be thought of as meta-data.
  For example, type \texttt{java.lang.String} has its definition, which allows specification of the actual sequence of characters with their encoding information (e.g. UTF-8).
  Instances of some type represent the actual data (i.e. not meta-data) that has the strucutre defined by their type.
  
  In affect, types define what data can be described.
  The reacher meta-data is the more pricise data definition is possible to obtain.
  Types can also be thought of as sets in a mathematical sense\footnote{Types are also methematical concepts studies by Type Theory, which is less wide spread than Set Theory.}.
  From this point of view, we can say that any type is a set containing all possible instances of a specific data structure.

  Type instances can be considered immutalbe and there are functions that can map instances of some types (or tuple of instances of some, possible different, types) into instances of the same or different types (tuple of types).
  Consider the function for concatenating two strings, which we often simply write as ``Hello '' $+$ ``World'', obraining a new instanse of the string type ``Hello World''.
  Its formal defition is $+:String\times String \rightarrow String$.

\subsection{The Essentials}

  Every \emph{entity type} is implemented in as a Java class that has \emph{AbstractEntity} class as is ancestor.
  \emph{AbstractEntity} is a class that serves as a common ancestor for all entity types. 
  All entity types have a surrogate key \emph{id}, business key \emph{key} and description \emph{desc}. 
  \emph{AbstractEntity} provides implementation for methods \emph{hashCode()}, \emph{equals(Object)}, \emph{toString()} and \emph{compareTo(AbstractEntity)}, which is based on the use of the business key and thus should be suitable in all cases.
  The only exception could be method \emph{toString()}, which developer may want to customise.


  \emph{AbstractEntity} provides a full support for two kinds of business keys
  \begin{description}
    \item[Simple Key] -- String, Integer, another entity type.
    \item[Composite Key] -- can include two or more properties as key members with no restrictions on their type; class \emph{DynamicEntityKey} models the composite key logic.
   \end{description}

 \lstset{language=Java,
	  escapechar=\%,
	  numbers=left, numberstyle=\tiny, basicstyle=\scriptsize\color{basiccolor}, stepnumber=1, numbersep=5pt, keywordstyle=\bfseries\color{codefgcolor}, stringstyle=\color{stringcolor}}
  \begin{code}{Composite key.}{\label{lst:CompositeKey}}{codebgcolor}
    \begin{lstlisting}
@DescTitle("Comment")
@KeyType(DynamicEntityKey.class)
@MapTo
public class VehicleFuelCard extends AbstractEntity<DynamicEntityKey> {
    @IsProperty
    @Title("Vehicle")
    @CompositeKeyMember(1)
    @MapTo("ID_EQDET")
    private Vehicle vehicle;

    @IsProperty
    @UpperCase
    @Title("Card Number")
    @CompositeKeyMember(2)
    @MapTo("CARDNUMBER")
    private String cardNumber;

    @IsProperty
    @Title(value = "Exp. Date", desc = "Expiry Date")
    @CompositeKeyMember(3)
    @MapTo("EXPIRY_DATE")
    private Date expiryDate;

    @IsProperty
    @Required
    @Title(value = "Date Issued", desc = "Date Issued")
    @MapTo
    private Date issuedDate;

   ....................................
}
    \end{lstlisting}
  \end{code}


\subsubsection{Properties}

  All fields in the derived from \emph{AbstractEntity} types annotated with \emph{IsProperty} annotation are automatically recognized as entity properties. The current way of instantiating entities is by using \emph{EnttyFactory}, which relies on application configuration modules (based on Guice) for resolving dependencies used as part of entity instantiation logic.

  One of the essential aspects of entity properties is their meta-state -- each property is associated with an instance of \emph{MetaProperty} type, which is created automatically when an entity is instantiated using \emph{EntityFactory}. 
  \emph{MetaProperty} provides rich support for various property life cycle functions such as tracking property changes, validation results, title, desctiption etc.

  \emph{MetaProperty} instances are created by \emph{IMetaPropertyFactory} implementation bound in the application configuration modules that is used by \emph{EntityFactory}.

  \emph{MetaProperty} instantiation ensures association of the created entity instance with property \emph{Before} and \emph{After} change event handlers, which are defined as annotations on property fields. 
  The platforms provides a set of predefined \emph{Before} event handles, which serve as validators, which are discussed further in the book. 
  
  Each property mutator such as setter must be annotated with \emph{Observable} annotation. 
  Early runtime exception is thrown if the system identifies existence of properties with their mutators without this annotation.

  In order for \emph{Before} and \emph{After} event handlers to be executed upon an attempt to set a property value (i.e. \emph{Before}) and after the value was set {i.e. \emph{After}}, setters should be intercepted. 
  Interceptor \emph{ObservableMutatorInterceptor} handles property value changes including triggering execution of event handlers. 
  Its implementation uses handlers associated with a property during meta-property instantiation. 
  This is another reason to instantiate entities with \emph{EntityFactory}, which ensures appropriate interceptors are using Guice interceptor provided with a module configured to bind this intercepter.

\subsubsection{Dependent Properties}

  The platform provides an elegant way to handle validation and error recovery situations for properties dependent on each other. 
  The dependent properties need to be annotated with annotation \emph{Dependent} that has a list of dependent property names as its argument. 
  The word \emph{dependent} here means that properties depend on some other property. 
  For example, \emph{WorkOrder.actualStart} depends on \emph{WorkOrder.actualFinish} and wise versa, but also \emph{WorkOrder.odometerReading} is dependent on \emph{WorkOrder.actualStart} and wise versa. 
  Thus, property \emph{WorkOrder.actualStart} has two dependent properties that should be revalidated when it is changed -- \emph{actualFinish} and \emph{odometerReading}.
  Listing \ref{sss} presents the described example in code.

  \begin{code}{Dependent properties.}{\label{lst:DependentProperties}}{codebgcolor}
    \begin{lstlisting}

    @IsProperty
    @Title("Actual Start")
    @Dependent({"actualFinish", "odometerReading"})
    @MapTo
    private Date actualStart;

    @IsProperty
    @Title("Actual Finish")
    @Dependent("actualStart")
    @MapTo
    private Date actualFinish;

    @IsProperty
    @Title(value = "Odometer", desc = "Odometer reading")
    @Dependent("actualStart")
    @MapTo
    private Integer odometerReading;
    \end{lstlisting}
  \end{code}


% \section{User Management}
% 
% \section{Configuration Management}
% 
% \section{Single Sign On}
% 
% \section{Security}
% 
% \section{Injection of Control (IoC)}  
