\chapter{UI Construction}\label{ch01:03}

%\section{UX with TG}

%\section{How to Swing}

%\section{Property Editors}

%\section{Entity Grid Inspector}

%\section{Actions in action}

%\section{Trees as Menus}

%\section{Constructing Entity Centres}

\section{Constructing Entity Masters}

  The notion of an \emph{entity master} refers to UI that provides a way of creating new and modifying existing entity instances.
  Regardless of its complexity, all entity masters contain property editors and a predefined set of actions such as \emph{New}, \emph{Edit}, \emph{Save}, \emph{Cancel} and \emph{Refresh}.
  The type and behaviour of property editors depends on the type the associated with them entity properties.
  Thus, during development we do not directly work with UI components, but instead with their abstractions, referring to them by property name.
  For example, having a UI model (this is discussed a bit farther in the text) we can simply request a collection of all property editors for an entity instance.
  
  The resultant collection would contain UI controls that are bound to properties of a corresponding entity instance.
  This way any change to the property value by user from UI gets automatically propagated to the property via its setter, validation mechanism etc.
  And vice versa, any programmatic change to the property by invoking its setter gets automatically reflected in the UI.
  Listing~\ref{lst:PropertiesMap} illustrates a process of obtaining an instance of \texttt{IPropertyEditor} by property name, and access to the actual underlying Swing component that represents the editor from UI perspective.
  Naturally, the obtained editor can be added to some UI container such as \texttt{JPanel} or \texttt{JFrame}.
  This approach streamlines UI development to the task of component layouting, which will be discussed later in this chapter in greater detail.
  
  
  \lstset{language=Java,
	  escapechar=\%,
	  numbers=left, numberstyle=\tiny, basicstyle=\scriptsize\color{basiccolor}, stepnumber=1, numbersep=5pt, keywordstyle=\bfseries\color{codefgcolor}, stringstyle=\color{stringcolor}}
  \begin{code}{One-to-One association.}{\label{lst:PropertiesMap}}{codebgcolor}
    \begin{lstlisting}
    ...
IPropertyEditor myPropertyEditor = model.getEditors().get("myProperty");
JComponent actualComponent = myPropertyEditor.getEditor();
    ...
    \end{lstlisting}
  \end{code}
  
  
  Each entity object, if required to be created or changed, should be provided with its own entity master implementation. 
  An instance of \texttt{EntityMasterManager} should be created at the client application startup time, which should be used for obtaining an instance of entity master by an instance of entity object.
  It ensures that only one instance of entity master exists for any particular instance of an entity object, and either creates a new entity master instance or brings to front and existing one when handling a request to show an entity master.
  
  As a convenience, the application template generated by Maven archetype, provide class \texttt{EntityMasterManagerConfig} with method \texttt{createEntityMasterFactory} that produces an instance of \texttt{EntityMasterManager}.
  Therefore, if an entity master is created it only needs to be associated with a corresponding entity type in order to get wired into the UI framework (this, for example, allow calling masters by means of double-click on entities in Entity Centres etc.).
  
  As mentioned in previous chapters, the platform employs the Model-View-Presenter (MVP) pattern for building UI.
  Thus, each entity master has at least one model and a view associated with that model.  
  In order to automate the routine task of creating UI, the platform offers a number of UI models that can be used as the basis for building custom, entity specific models and views.
  The rest of the chapter discusses specific models and their application for building simple and compound entity masters.
  
\subsection{Simple Masters}
  Simple master refers to masters for simple entities that may fit editors for all their properties on a single view such as panel.
  Simple entities often model so called \emph{reference data} or \emph{table codes}.
  Often such entities have just a handful of properties that can be conveniently represented on a single view.
  That's where simple masters are applicable.
  
  Structurally, simple master consists of four main components:
  
  \begin{description}
   \item[\textbf{Model.}] A class, usually derived from \texttt{UmMasterWithCrudAndUpdater<EntityObjectType, EntityCompanionType>}, representing UI model for the master.
   Here \texttt{Um} stands for \emph{UI Model}, \texttt{CrudAndUpdater} indicates that model provide essential CRUD operations with feedback loop to the view (this is the updater part).
   The first type parameter is an entity object type the model is designed for, the second -- a type of a corresponding companion object.
   Both entity and companion objects are passed into the model's constructor.
   \item[\textbf{View.}] A class, usually derived from \texttt{BaseNotifPanel<UmMasterType>}, which represents a container holding property editors, the action buttons and the notification panel at the top. 
   It specifies what UI master model it expects at type parameter and requires for the model instance to be provided into its constructor. 
   This is where developers define the layout of property editors on the master.
   \item[\textbf{Frame.}] This is really just a class, usually derived from \texttt{BaseFrame}, that holds the view as on its own it cannot be displayed.   
   \item[\textbf{Factory.}] A descendent from \texttt{IEntityMasterFactory<Entity\-Object\-Type, Entity\-Companion\-Type>} responsible for master instantiation.   
   It is used by the internal platform mechanism to instantiate entity masters.
  \end{description}
  

  The \textbf{model} is the central component of the master structure. 
  All other components revolve around it.
  The following list specifies the major pieces required for model construction.
  These pieces are passed into the model's class constructor.
  \begin{description}
   \item[\textbf{Entity producer.}] An instance of a class implementing contract \texttt{IEntityProducer<EntityObjectType>}.
   It is responsible for creation of new entity object instances, which happens when user chooses action \emph{New}.
   This contract provides a convenient way to abstract specific details of entity instantiation away from UI code.
   Each entity object type should have its own producer implementation, which gets registered with \texttt{EntityMasterManager}.
   If custom instantiation is not required then a default producer provided automatically without the need to register it.
   \item[\textbf{Cache.}] An instance of a class implementing contract \texttt{IEntityMasterCache} that represents a global cache for all master instances for different entity objects.
   A default cache implementation is provided automatically and requires no action from developers to use it.
   It could be argued in such case there is no need to expose it, but we felt that it is always good to provide extension points with reasonable defaults.
   Thus, a custom case implementation can be provided in case the default is not sufficient.
   The client-side application IoC module controls the biding of the \texttt{IEntityMasterCache} contract.
   \item[\textbf{Entity Object.}] An instance of an entity object for which the master is being created.
   \item[\textbf{Companion Object.}] An instance of a companion object of the entity for which the master is being created.
   \item[\textbf{Value matcher factory.}] An instance implementing contract \texttt{IValueMatcherFactory} used for instantiating property editors.
   A default implementation is provided automatically.
   \item[\textbf{View owner.}] All entity masters are created as a user action on an entity centre.
   This makes entity centres act like the owners of the produced from them masters.
   Theoretically there could be other kinds of master owners.
   Therefore, the master ownership is abstracted into contract \texttt{IUmViewOwner}.
   Naturally entity centres implement this contract.
   It has only one method \texttt{notifyEntityChange}, which is invoked when entity is modified on the master.
   This provides a convenient way for the owner to react to the entity modification (e.g. entity centres update the row in the resultant grid corresponding to the entity instance).
  \end{description}
  
  
  \textbf{TODO}..............................
  
\subsection{Compound Masters}

  Compound masters should be used to represent a complex entity that consists of One-2-Many and One-2-One associations.
  The sole purpose to build a compound master is to have most if not all aspects of an entity editable in one place.
  Due to entity complexity caused by large number of properties and their complexity, it is necessary to logically split entity UI representation into several views.
  For example, entity \texttt{Wagon} has some primary properties such as its number and class.
  These can be grouped together on one view.
  At the same time its property \texttt{slots: Set<BogieSlot>}, which is a One-2-Many association, might be best represented on a separate view.
  Similarly, a One-2-One association such as property \texttt{techDetails: WagonTechDetails} is also best represented on a separate view.
  
  Such separation has dual purpose.
  On the one hand, user has clear visual separation between different aspect of the same entity while preserving everything as part of a single master view.
  On the other hand, this provide a way to optimise the fetch model in such way that not visible properties are not loaded until necessary, which helps reducing both database and network load.
  
  An important details here is that each master is associated with a particular instance of an entity object.
  The main view is associated directly with an entity, while other views are associated with complex properties (or set of properties) of the same entity instance.
  
  Structurally, compound masters are similar to simple masters.
  As the name suggests, instead of one model/view pair there are two and more such pairs.
  Each pair is associated with a tree menu item, which is located on the left side of each compound master view.
  Usually, the master model is associated with both the master view and the default view (aka main view).
  The master view holds the tree menu and the panel where menu specific views are displayed.
  

%\section{Configuration Management}


