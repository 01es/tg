\chapter{UI Construction}\label{ch01:03}

%\section{UX with TG}

%\section{How to Swing}

%\section{Property Editors}

%\section{Entity Grid Inspector}

%\section{Actions in action}

%\section{Trees as Menus}

%\section{Constructing Entity Centres}

\section{Constructing Entity Masters}

  The notion of an \emph{entity master} refers to UI that provides a way of creating new and modifying existing entity instances.
  Regardless of its complexity, all entity masters contain property editors and a predefined set of actions such as \emph{New}, \emph{Edit}, \emph{Save}, \emph{Cancel} and \emph{Refresh}.
  The type and behaviour of property editors depends on the type the associated with them entity properties.
  Thus, during development we do not directly work with UI components, but instead with their abstractions, referring to them by property name.
  For example, having a UI model (this is discussed a bit farther in the text) we can simply request a collection of all property editors for an entity instance.
  
  The resultant collection would contain UI controls that are bound to properties of a corresponding entity instance.
  This way any change to the property value by user from UI gets automatically propagated to the property via its setter, validation mechanism etc.
  And vice versa, any programmatic change to the property by invoking its setter gets automatically reflected in the UI.
  Listing~\ref{lst:PropertiesMap} illustrates a process of obtaining an instance of \texttt{IPropertyEditor} by property name, and access to the actual underlying Swing component that represents the editor from UI perspective.
  Naturally, the obtained editor can be added to some UI container such as \texttt{JPanel} or \texttt{JFrame}.
  This approach streamlines UI development to the task of component layouting, which will be discussed later in this chapter in greater detail.
  
  
  \lstset{language=Java,
	  escapechar=\%,
	  numbers=left, numberstyle=\tiny, basicstyle=\scriptsize\color{basiccolor}, stepnumber=1, numbersep=5pt, keywordstyle=\bfseries\color{codefgcolor}, stringstyle=\color{stringcolor}}
  \begin{code}{One-to-One association.}{\label{lst:PropertiesMap}}{codebgcolor}
    \begin{lstlisting}
    ...
IPropertyEditor myPropertyEditor = model.getEditors().get("myProperty");
JComponent actualComponent = myPropertyEditor.getEditor();
    ...
    \end{lstlisting}
  \end{code}
  
  
  Each entity object, if required to be created or changed, should be provided with its own entity master implementation. 
  An instance of \texttt{EntityMasterManager} should be created at the client application startup time, which should be used for obtaining an instance of entity master by an instance of entity object.
  It ensures that only one instance of entity master exists for any particular instance of an entity object, and either creates a new entity master instance or brings to front and existing one when handling a request to show an entity master.
  
  As a convenience, the application template generated by Maven archetype, provide class \texttt{EntityMasterManagerConfig} with method \texttt{createEntityMasterFactory} that produces an instance of \texttt{EntityMasterManager}.
  Therefore, if an entity master is created it only needs to be associated with a corresponding entity type in order to get wired into the UI framework (this, for example, allow calling masters by means of double-click on entities in Entity Centres etc.).
  
  As mentioned in previous chapters, the platform employs the Model-View-Presenter (MVP) pattern for building UI.
  Thus, each entity master has at least one model and a view associated with that model.  
  In order to automate the routine task of creating UI, the platform offers a number of UI models that can be used as the basis for building custom, entity specific models and views.
  The rest of the chapter discusses specific models and their application for building simple and compound entity masters.
  
\subsection{Simple Masters}
  Simple master refers to masters for simple entities that may fit editors for all their properties on a single view such as panel.
  Simple entities often model so called \emph{reference data} or \emph{table codes}.
  Often such entities have just a handful of properties that can be conveniently represented on a single view.
  That's where simple masters are applicable.
  
  Structurally, simple master consists of four main components:
  
  \begin{description}
   \item[\textbf{Model.}] A class, usually derived from \texttt{UmMasterWithCrudAndUpdater<EntityObjectType, EntityCompanionType>}, representing UI model for the master.
   Here \texttt{Um} stands for \emph{UI Model}, \texttt{CrudAndUpdater} indicates that model provide essential CRUD operations with feedback loop to the view (this is the updater part).
   The first type parameter is an entity object type the model is designed for, the second -- a type of a corresponding companion object.
   Both entity and companion objects are passed into the model's constructor.
   \item[\textbf{View.}] A class, usually derived from \texttt{BaseNotifPanel<UmMasterType>}, which represents a container holding property editors, the action buttons and the notification panel at the top. 
   It specifies what UI master model it expects at type parameter and requires for the model instance to be provided into its constructor. 
   This is where developers define the layout of property editors on the master.
   \item[\textbf{Frame.}] This is really just a class, usually derived from \texttt{BaseFrame}, that holds the view as on its own it cannot be displayed.   
   \item[\textbf{Factory.}] A descendent from \texttt{IEntityMasterFactory<Entity\-Object\-Type, Entity\-Companion\-Type>} responsible for master instantiation.   
   It is used by the internal platform mechanism to instantiate entity masters.
  \end{description}
  

  \textbf{TODO}..............................
  
\subsection{Compound Masters}

  Compound masters should be used to represent a complex entity that consists of One-2-Many and One-2-One associations.
  The sole purpose to build a compound master is to have most if not all aspects of an entity editable in one place.
  Due to entity complexity caused by large number of properties and their complexity, it is necessary to logically split entity UI representation into several views.
  For example, entity \texttt{Wagon} has some primary properties such as its number and class.
  These can be grouped together on one view.
  At the same time its property \texttt{slots: Set<BogieSlot>}, which is a One-2-Many association, might be best represented on a separate view.
  Similarly, a One-2-One association such as property \texttt{techDetails: WagonTechDetails} is also best represented on a separate view.
  
  Such separation has dual purpose.
  On the one hand, user has clear visual separation between different aspect of the same entity while preserving everything as part of a single master view.
  On the other hand, this provide a way to optimise the fetch model in such way that not visible properties are not loaded until necessary, which helps reducing both database and network load.
  
  An important details here is that each master is associated with a particular instance of an entity object.
  The main view is associated directly with an entity, while other views are associated with complex properties (or set of properties) of the same entity instance.
  
  Structurally, compound masters are similar to simple masters.
  As the name suggests, instead of one model/view pair there are two and more such pairs.
  Each pair is associated with a tree menu item, which is located on the left side of each compound master view.
  Usually, the master model is associated with both the master view and the default view (aka main view).
  The master view holds the tree menu and the panel where menu specific views are displayed.
  

%\section{Configuration Management}


