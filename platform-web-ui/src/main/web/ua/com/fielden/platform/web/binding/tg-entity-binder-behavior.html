<link rel="import" href="/resources/polymer/polymer/polymer.html">

<script>
    (function () {
    	Polymer.TgBehaviors = Polymer.TgBehaviors || {};
    	Polymer.TgBehaviors.TgEntityBinderBehavior = {
    		// TODO PUBLIC API: attributes="preRetrieved"
    		// TODO PUBLIC API: attributes="preRetrieved"
    		// TODO PUBLIC API: attributes="preRetrieved"
    		// TODO PUBLIC API: attributes="preRetrieved"
    		// TODO PUBLIC API: attributes="preRetrieved"
    		// TODO PUBLIC API: attributes="preRetrieved"
    		
    		properties: {
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	////////////////////////////////////////// EXTERNAL PROPERTIES //////////////////////////////////////////
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	// These mandatory properties must be specified in attributes, when constructing descendant elements.  //
            	// No default values are allowed in this case.														   //
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	
                /**
                 * The state for the entity master.
                 *
                 * The master can be only in two states: EDIT and VIEW. The state EDIT
                 * allows user to edit properties and use some actions (as it was defined in Java API with 'enabledWhen').
                 *
                 * The state VIEW allows user to review the entity properties and do some actions (as it was defined in
                 * Java API with 'enabledWhen').
                 *
                 * The initial state can be VIEW or EDIT.
                 */
                currentState: {
                	type: String
                    // reflectToAttribute: true -- why is this needed?
                },
                
                /**
                 * Universal identifier of this element instance (used for pub / sub communication).
                 *
                 * Should be given from the outside of the element.
                 */
                uuid: {
                	type: String
                },
                
                /**
                 * Custom callback that will be invoked after successfull retrieval.
                 */
                postRetrieved: {
                	type: Function                	
                },
                
                /**
                 * Custom callback that will be invoked after successfull validation.
                 */
                postValidated: {
                	type: Function                	
                },
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	//////////////////////////////////////////// INNER PROPERTIES ///////////////////////////////////////////
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	// These properties derive from other properties and are considered as 'private' -- need to have '_'   //
            	//   prefix and default values specified in 'value' specificator of the property definition (or,       //
            	//   alternatively, computing function needs to be specified). 									       //
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	
            	/**
            	 * The current fully-fledged entity, that is used to create '_currBindingEntity' and '_originalBindingEntity'.
            	 */
  	            _currEntity: {
  	            	type: Object,
  	            	value: null
  	            },
  	            
  	            /**
  	             * Represents the view of original entity for binding.
  	             */
  	            _originalBindingEntity: {
  	            	type: Object,
  	            	value: null
  	            },

             	/////////////////////////////////////////////////////////////////////////////////////////////////////////
             	//////////////////////////////// INNER PROPERTIES, THAT GOVERN CHILDREN /////////////////////////////////
             	/////////////////////////////////////////////////////////////////////////////////////////////////////////
             	// These properties derive from other properties and are considered as 'private' -- need to have '_'   //
             	//   prefix. 																				           //
             	// Also, these properties are designed to be bound to children element properties -- it is necessary to//
             	//   populate their default values in ready callback (to have these values populated in children)!     //
             	/////////////////////////////////////////////////////////////////////////////////////////////////////////
             	
             	/**
             	 * Governs children editors by 'turning on' refresh cycle mode.
             	 *
             	 * 'ACTIVATED' and null are the only permitted values. 
             	 */
                _refreshCycleMode: {
                	type: String,
                	observer: '_refreshCycleModeChanged'
                },
                
                /**
                 * Represents the view of current entity for binding.
                 */
                _currBindingEntity: {
                	type: Object
                },

                /**
                 * '_createModifiedPropertiesHolder' function, that is designated for binding.
                 */
                _createModifiedPropertiesHolder: {
                	type: Function,
                	value: function () {
                		return (function () {
                            var mph = this.extractModifiedPropertiesHolder(this._currBindingEntity, this._originalBindingEntity);
                            return this._reset(mph);
                        }).bind(this);
                	}
                },
                
                /**
                 * Default implementation for postValidated callback.
                 */
                _postValidatedDefault: {
                	type: Function,
                	value: function () {
                		return (function (entityAndCustomObject) {
                            var validatedEntity = entityAndCustomObject[0];
                            var customObject = this.$.reflector.customObject(entityAndCustomObject);
                        	
                            var msg = this.toastMsg("Validation", validatedEntity);
                            this.openToast(validatedEntity, msg, !validatedEntity.isValid() || validatedEntity.isValidWithWarning(), msg, false);

                            var newBindingEntity = this.onEntityReceived(validatedEntity);
                            // custom external action
                            this.postValidated(validatedEntity, newBindingEntity, customObject);
                        }).bind(this);
                	}
                },
                
                /**
                 * Default implementation for unsuccessful postValidated callback.
                 */
                _postValidatedDefaultError: {
                	type: Function,
                	value: function () {
                		return (function (errorResult) {
                        	// This function will be invoked after server-side error appear.
                        	// 'tg-action' will augment this function with its own 'afterExecution' logic (spinner stopping etc.).                	
                        	console.warn("SERVER ERROR: ", errorResult);
                        }).bind(this);
                	}
                },
                
                /**
                 * Default implementation for postRetrieved callback.
                 */
                _postRetrievedDefault: {
                	type: Function,
                	value: function () {
                		return (function (entityAndCustomObject) {
                            var entity = this.onPreRetrieved(entityAndCustomObject[0]);
                            var customObject = this.$.reflector.customObject(entityAndCustomObject);

                            var newBindingEntity = this.onEntityReceived(entity);
                            
                            this.onDescendantRetrieved(entity, newBindingEntity, customObject);
                            // custom external action
                            this.postRetrieved(entity, newBindingEntity, customObject);
                        }).bind(this);
                	}
                },
                
                /**
                 * Default implementation for unsuccessful postRetrieved callback.
                 */
                _postRetrievedDefaultError: {
                	type: Function,
                	value: function () {
                		return (function (errorResult) {
                        	// This function will be invoked after server-side error appear.
                        	// 'tg-action' will augment this function with its own 'afterExecution' logic (spinner stopping etc.).                	
                        	console.warn("SERVER ERROR: ", errorResult);
                        }).bind(this);
                	}
                },
                
                /**
                 * Default implementation for unsuccessful postSearched callback.
                 */
                _postSearchedDefaultError: {
                	type: Function,
                	value: function () {
                		return (function (errorResult) {
                        	// This function will be invoked after server-side error appear.
                        	// 'tg-action' will augment this function with its own 'afterExecution' logic (spinner stopping etc.).                	
                        	console.warn("SERVER ERROR: ", errorResult);
                        }).bind(this);
                	}
                },
                
                /**
                 * This is the standard processor for 'core-response's and is applicable for all
                 *   responses that contain java Result inside 'e.detail.response'.
                 *
                 * In case when result is not successful (i.e. has 'ex' inside) the toast message is shown 
                 *   and 'customErrorHandlerFor(result)' is invoked.
                 *
                 * In case when result is successful -- 'customHandlerFor(result.instance)' is invoked.
                 *
                 *
                 * This is the function, that is designated for binding.
                 */
                _processResponse: {
                	type: Function,
                	value: function () {
                		return (function(e, name, customHandlerFor, customErrorHandlerFor) {
                        	console.log(name, ": core-response: status = ", e.detail.xhr.status, ", e.detail.response = ", e.detail.response);
                            if (e.detail.xhr.status === 200) {
                            	var deserialisedResult = this.$.serialiser.deserialise(e.detail.response);
                            	
                            	if (this.$.reflector.isError(deserialisedResult)) {
                            		// throw the toast message about the server-side error
                                    var msg = this.toastMsgForError(deserialisedResult);
                                    this.openToastForError(this.$.reflector.exceptionMessage(deserialisedResult.ex), msg);
                            		// continue with custom error handling of the error result
                                    customErrorHandlerFor(deserialisedResult);
                            	} else if (this.$.reflector.isWarning(deserialisedResult)) {
                            		// TODO how warnings should be handled?
                            		console.warn(this.toastMsgForError(deserialisedResult));
                            	} else {
                            		// continue with normal handling of the result's instance
            	                    customHandlerFor(deserialisedResult.instance);
                            	}
                            } else {
                            	console.warn(name, ": core-response: non-200-status = ", e.detail.xhr.status, ", e.detail.response = ", e.detail.response);
                            }
                        }).bind(this);
                	}
                },
                
                /**
                 * Starts the process of entity validation (based on _currBindingEntity).
                 *
                 * This function is designated for binding.
                 */
                validate: {
                	type: Function,
                	value: function () {
                		return (function () {
                            console.log("_validate");
                            var self = this;

                            var holder = self.extractModifiedPropertiesHolder(self._currBindingEntity, self._originalBindingEntity);
                            // NOTE: no need to check whether the hasModified(holder) === true -- because the error recovery should happen!
                            // (if the entity was not modified -- _validate(holder) will start the error recovery process)

                            // cancel previous validation before starting new one! The results of previous validation are irrelevant!
                            self.validator().abortValidationIfAny();
                            self.validator().validate(self._reset(holder));
                        }).bind(this);
                	}
                },
                
                /**
                 * The function that explicitly says that validation is skipped.
                 *
                 * This function is designated for binding.
                 */
                doNotValidate: {
                	type: Function,
                	value: function () {
                		return (function () {
                            console.log("do not validate");
                        }).bind(this);
                	}
                },
                
                /**
                 * Starts the process of entity retrieval (based on current entityid).
                 *
                 * This function is designated for binding.
                 */
                retrieve: {
                	type: Function,
                	value: function () {
                		return (function (context) {
                        	if (context) {
                                var ser = this.$.serialiser.serialise(context);
                                this.ajaxRetriever().body = JSON.stringify(ser);
                        	}
                            this.ajaxRetriever().go();
                            this._startRefreshCycleModeForEditors();
                        }).bind(this);
                	}
                }
    		},
            
            /**
             * Initialisation block. It has all children web components already initialised.
             */
            ready: function () {
                var self = this;
                
                this._resetRefreshCycleModeForEditors(); // init the value for '_refreshCycleMode'
                this._currBindingEntity = null; // TODO previously, was {} -- empty object. Please, use more safe form ('null'). And check, if 'null' is appropriately working with editors.

                self.ajaxRetriever().addEventListener('core-response', function (e) {
                	self._processResponse(e, "retrieve", function (entityAndCustomObject) {
                		self._postRetrievedDefault(entityAndCustomObject);
                	}, function (errorResult) {
                		self._postRetrievedDefaultError(errorResult);
                	});
                });
            },

            ///////////// toast related //////////////////
            /**
             * Opens the toast with some message and with indication whether progress is started.
             */
            openToast: function (entity, toastMsg, hasMoreInfo, moreInfo, showProgress) {
                this.$.toastGreeting.text = toastMsg;
                this.$.toastGreeting.hasMore = hasMoreInfo;
                this.$.toastGreeting.msgText = moreInfo;
                this.$.toastGreeting.showProgress = showProgress;
                if (hasMoreInfo) {
                    if (!entity.isValid()) {
                        this.$.toastGreeting.msgHeading = "Error";
                    } else if (entity.isValidWithWarning()) {
                        this.$.toastGreeting.msgHeading = "Warning";
                    } else {
                        this.$.toastGreeting.msgHeading = "Info";
                    }
                }
                this.$.toastGreeting.opened = true;
            },

            /**
             * Opens the toast with some error message including full 'moreInfo' message.
             */
            openToastForError: function (toastMsg, moreInfo) {
                this.$.toastGreeting.text = toastMsg;
                this.$.toastGreeting.hasMore = true;
                this.$.toastGreeting.msgText = moreInfo;
                this.$.toastGreeting.showProgress = false;
             	this.$.toastGreeting.msgHeading = "Error";
                this.$.toastGreeting.opened = true;
            },
            
            toastMsgForError: function (errorResult) {
            	var ex = errorResult.ex;
             return this.$.reflector.stackTrace(ex);
            },
            
            toastMsg: function (actionName, entity) {
                if (!entity.isValid()) {
                    return entity.firstFailure().message;
                } else if (entity.isValidWithWarning()) {
                    return entity.firstWarning().message;
                } else {
                    return actionName + " completed successfully.";
                }
            },
            //////////////////////////////////////////////

            /**
             * The core-ajax component for entity retrieval.
             */
            ajaxRetriever: function () {
                throw "ajaxRetriever: not implemented";
            },

            /**
             * The tg-entity-validator component for entity validation.
             */
            validator: function () {
                throw "validator: not implemented";
            },

            //////////////////////////////////////// RETRIEVAL ////////////////////////////////////////
            /**
             * Default implementation for onPreRetrieved callback.
             */
            onPreRetrieved: function (entity) {
                return entity;
            },
            
            onDescendantRetrieved: function(entity, newBindingEntity, customObject) {
            },
            
            //////////////////////////////////////// VALIDATION ////////////////////////////////////////
            _reset: function (modifiedPropertiesHolder) {
                delete modifiedPropertiesHolder['@modified']; // remove it not to serialise this purely technical property
                return modifiedPropertiesHolder;
            },

            extractModifiedPropertiesHolder: function (bindingEntity, _originalBindingEntity) {
                var modPropHolder = {
                    "@modified": false
                };
                var self = this;
                if (self.$.reflector.isEntity(bindingEntity)) {
                    modPropHolder["id"] = bindingEntity["id"];
                    modPropHolder["version"] = bindingEntity["version"];

                    bindingEntity.traverseProperties(function (propertyName) {
                        var value = bindingEntity.get(propertyName);
                        var originalValue = _originalBindingEntity.get(propertyName);
                        // VERY IMPORTANT: the property is considered to be 'modified'
                        //                 in the case when its value does not equal to original value.
                        // 
                        //                 The "modified" property is marked by existence of "val" sub-property.
                        //
                        //                 All modified properties will be applied on the server upon the validation prototype.
                        if (!self.$.reflector.equalsEx(value, originalValue)) {
                            // the property is 'modified'
                            modPropHolder[propertyName] = {
                                "val": value,
                                "origVal": originalValue
                            };
                            modPropHolder["@modified"] = true;
                        } else {
                            // the property is 'unmodified'
                            modPropHolder[propertyName] = {
                                "origVal": originalValue
                            };
                        }
                    });
                }
                console.log("       extractModifiedPropertiesHolder: modPropHolder", modPropHolder);
                return modPropHolder;
            },

            _idConvert: function (id) {
                return id === null ? "new" : ("" + id);
            },

            _refreshCycleModeChanged: function (newValue, oldValue) {
                // console.log("_refreshCycleModeChanged", newValue, oldValue);
            },

            /**
             * Initialises a special state for the editors called "refresh cycle". In this state
             * the editors promotes their values through the chain: entity => editingValue (commit) => commValue => acceptedValue.
             *
             * If the state is simple -- the value promotes through the next chain: editingValue (commit) => commValue => acceptedValue =>
             * => entity prop value (validate) => new entity prop.
             */
            _startRefreshCycleModeForEditors: function () {
                this._refreshCycleMode = "ACTIVATED";
            },

            _resetRefreshCycleModeForEditors: function () {
                this._refreshCycleMode = null;
            },

            //////////////////////////////////////// BINDING & UTILS ////////////////////////////////////////
            /**
             * Provides default action after fresh entity has been received. Rebinds the entity.
             */
            onEntityReceived: function (entity) {
                var self = this;
                // After the entity has received, potentially its id has been updated:
                if (self._idConvert(entity.id) !== self.entityid) {
                    self.entityid = self._idConvert(entity.id);
                }
                // extract previous version of modified properties holder, to merge it with new version of validated entity for invalida properties!
                var previousModifiedPropertiesHolder = self.extractModifiedPropertiesHolder(self._currBindingEntity, self._originalBindingEntity);
                self._reset(previousModifiedPropertiesHolder);
                // New entity should be promoted to the local cache:
                self._currEntity = entity;
                // before the next assignment -- the editors should be already prepared for "refresh cycle" (for Retrieve and Save actions)
                self._currBindingEntity = self._extractBindingView(self._currEntity, previousModifiedPropertiesHolder);
                self._originalBindingEntity = self._extractOriginalBindingView(self._currEntity);

                this._resetRefreshCycleModeForEditors();

                console.log("       onEntityReceived: _currBindingEntity + _originalBindingEntity", self._currBindingEntity, self._originalBindingEntity);
                return self._currBindingEntity;
            },

            _extractBindingView: function (entity, previousModifiedPropertiesHolder) {
                var self = this;
                bindingView = self.$.reflector.newEntity(entity.type().fullClassName());
                bindingView["id"] = entity["id"];
                bindingView["version"] = entity["version"];
                // this property of the bindingView will hold the reference to fully-fledged entity, 
                //   this entity can be used effectively to process 'dot-notated' properties (for e.g. retrieving the values) 
                bindingView["@@origin"] = entity;

                entity.traverseProperties(function (propertyName) {
                    if (self.$.reflector.isError(entity.prop(propertyName).validationResult())) {
                        if (typeof previousModifiedPropertiesHolder[propertyName].val === 'undefined') {
                            // EDGE-CASE: if the value becomes invalid not because the action done upon this property -- 
                            //   but because the action on other property -- the previous version of modifiedPropsHolder will not hold
                            //   invalid 'attempted value' -- but originalVal exists for this case!
                            bindingView[propertyName] = previousModifiedPropertiesHolder[propertyName].origVal;
                        } else {
                            bindingView[propertyName] = previousModifiedPropertiesHolder[propertyName].val;
                        }

                        bindingView["@" + propertyName + "_error"] = entity.prop(propertyName).validationResult();
                    } else {
                    	bindingView[propertyName] = self.$.reflector.convert(entity.get(propertyName));

                        var value = entity.get(propertyName);
                        if (self.$.reflector.isEntity(value)) {
                            bindingView["@" + propertyName + "_desc"] = self.$.reflector.convert(value.get("desc"));
                        }

                        if (self.$.reflector.isWarning(entity.prop(propertyName).validationResult())) {
                            bindingView["@" + propertyName + "_warning"] = entity.prop(propertyName).validationResult();
                        }
                        if (entity.prop(propertyName).isRequired()) {
                            bindingView["@" + propertyName + "_required"] = true;
                        } else {
                            bindingView["@" + propertyName + "_required"] = false;
                        }
                        if (entity.type().prop(propertyName).isUpperCase()) {
                            bindingView["@" + propertyName + "_uppercase"] = true;
                        }
                    }
                    
                    bindingView["@" + propertyName + "_editable"] = entity.prop(propertyName).isEditable();

                    if (typeof bindingView[propertyName] === 'undefined' || bindingView[propertyName] === undefined) {
                        throw "Illegal value exception: the property [" + propertyName + "] can not be assigned as [" + bindingView[propertyName] + "].";
                    }
                });

                // console.log("       entity + bindingView", entity, bindingView);
                return bindingView;
            },

            _extractOriginalBindingView: function (entity) {
                var self = this;
                var originalBindingView = self.$.reflector.newEntityEmpty();

                originalBindingView["_type"] = entity["_type"];
                originalBindingView["id"] = entity["id"];
                originalBindingView["version"] = entity["version"];

                entity.traverseProperties(function (propertyName) {
                    originalBindingView[propertyName] = self.$.reflector.convert(entity.getOriginal(propertyName));
                });

                // console.log("       entity + originalBindingView", entity, bindingView);
                return originalBindingView;
            }
        };
    })();
</script>