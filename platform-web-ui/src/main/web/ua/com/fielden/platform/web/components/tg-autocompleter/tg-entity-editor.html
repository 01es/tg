<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/resources/polymer/polymer/layout.html">

<link rel="import" href="/resources/polymer/core-input/core-input.html">
<link rel="import" href="/resources/polymer/paper-shadow/paper-shadow.html">
<link rel="import" href="/resources/polymer/core-overlay/core-overlay.html">
<link rel="import" href="/resources/polymer/core-selector/core-selector.html">
<link rel="import" href="/resources/polymer/core-icon-button/core-icon-button.html">
<link rel="import" href="/resources/polymer/core-icons/core-icons.html">
<link rel="import" href="/resources/polymer/paper-item/paper-item.html">
<link rel="import" href="/resources/polymer/paper-ripple/paper-ripple.html">
<link rel="import" href="/resources/polymer/paper-input/paper-input-decorator.html">
<link rel="import" href="/resources/polymer/paper-button/paper-button.html">
<link rel="import" href="/resources/polymer/core-transition/core-transition.html">
<link rel="import" href="/resources/polymer/core-transition/core-transition-css.html">
<link rel="import" href="/resources/polymer/core-tooltip/core-tooltip.html">
<link rel="import" href="/resources/polymer/paper-spinner/paper-spinner.html">
<link rel="import" href="/resources/components/lodash-lib.html">

<link rel="import" href="/resources/editors/tg-editor.html">
<link rel="import" href="/resources/master/actions/tg-property-action.html">
<link rel="import" href="/resources/polymer/core-ajax/core-ajax.html">
<link rel="import" href="/resources/serialisation/tg-serialiser.html">

<core-style id="search-icon-decorator">
    core-icon-button /deep/ core-icon[role="img"] { fill: {{g.paperInput.labelColor}}; }
    <!-- -->
    core-icon-button:hover /deep/ core-icon, #decorator[focused] /deep/ core-icon { fill: {{g.paperInput.focusedColor}}; }
    <!-- -->
    .invalid core-icon-button /deep/ core-icon { fill : {{g.paperInput.invalidColor}}; }
    <!-- -->
    paper-spinner { width: 1.0em; height:1.0em; }
    <!-- -->
    paper-spinner.blue::shadow .circle { border-color: {{g.paperInput.focusedColor}}; }
    <!-- -->
    .invalid paper-spinner { width: 1.0em; height:1.0em; border-color : {{g.paperInput.invalidColor}}; }
</core-style>

<polymer-element name="tg-entity-editor" attributes="composite" extends="tg-editor">
    <template>
        <!-- CSS -->
        <core-style ref="search-icon-decorator"></core-style>
        <link rel="stylesheet" href="tg-entity-editor.css">

        <!-- request related components -->
        <tg-serialiser id="serialiser"></tg-serialiser>
        <core-ajax id="ajaxSearcher" url="/users/{{user}}/autocompletion/{{entitytype}}/{{property}}" method="POST" handleas="json"></core-ajax>

        <!-- structure of representation -->
        <div id="all" relative>
            <paper-input-decorator id="decorator" label="{{propTitle}}" floatingLabel value="{{editingValue}}" isInvalid="{{_msgType(entity, propertyName, editorValidationMsg) === 'ERROR'}}" error="{{_msgType(entity, propertyName, editorValidationMsg) === 'ERROR' ? _msg(entity, propertyName, editorValidationMsg) : ''}}" disabled?="{{_isDisabled(currentState)}}">
                <div layout horizontal>
                    <div id="input-container" flex>
                        <!-- if tooltip is empty then the core-tooltip is not shown -->
                        <core-tooltip position="bottom" style="width:100%" disabled="{{!tooltip}}">
                            <input is="core-input" id="input" on-input="{{onInput}}" value="{{editingValue}}" committedValue="{{commValue}}" disabled?="{{_isDisabled(currentState)}}">
                            <span class="autocompleter-tooltip" tip>
                                {{tooltip}}
                            </span>
                        </core-tooltip>
                    </div>
                    <div id="icon">
                        <template if="{{isSearching}}">
                            <paper-spinner id="spinner" active="{{isSearching}}" class="blue" alt="searching"></paper-spinner>
                        </template>
                        <template if="{{!isSearching}}">
                            <core-icon-button class="search-button" on-click="{{onInput}}" icon="search"></core-icon-buton>
                        </template>
                    </div>
                    <div id="action_icon" hidden?="{{!action}}">
                        <tg-property-action user="{{action.user}}" entitytype="{{action.entitytype}}" preAction="{{action.preAction}}" postActionSuccess="{{action.postActionSuccess}}" postActionError="{{action.postActionError}}" enabledStates="{{action.enabledStates}}" longDesc="{{action.longDesc}}" shortDesc="{{action.shortDesc}}" icon="{{action.icon}}" currentState="{{currentState}}"></tg-property-action>
                    </div>
                </div>
            </paper-input-decorator>

            <core-overlay id="overlay" class="tg-snatchback" autoFocusDisabled on-core-overlay-open-completed="{{suggestionsOpened}}">
                <paper-shadow z="1">
                    <!-- list of suggestions, each item can be selected with space (TODO) -->
                    <div class="tg-snatchback-suggestions">
                        <core-selector id="suggestions" valueattr="value" class="tg-snatchback-suggestions" on-core-select="{{onSelectItem}}">
                            <template repeat="{{v in matchedValues}}">
                                <paper-item class="tg-item" value="{{v.key}}" noink layout vertical>
                                    <!-- font-size:0 is a hack to enforce no space between the highlighted and not highlighted part of the key value -->
                                    <div flex style="font-size: 0">
                                        <template repeat="{{s in matchedParts(v.key)}}">
                                            <template if="{{s.matched}}">
                                                <span class="key-value key-value-highlighted">{{s.part}}</span>
                                            </template>
                                            <template if="{{!s.matched}}">
                                                <span class="key-value">{{s.part}}</span>
                                            </template>
                                        </template>
                                    </div>
                                    <div class="desc-value" flex three>{{v.desc}}</div>
                                </paper-item>
                            </template>
                        </core-selector>
                    </div>
                    <!-- toolbar -->
                    <div id="toolbar" style="border-top: thin solid #ccc; padding: 8px;" layout horizontal justified center>
                        <div id="paginator" layout horizontal center>
                            <core-icon-button class="tg-snatchback-button" icon="chevron-left"></core-icon-button>
                            <core-icon-button class="tg-snatchback-button" icon="chevron-right"></core-icon-button>
                        </div>
                        <div id="okCancel" layout horizontal center>
                            <paper-button class="tg-snatchback-button" on-click="{{onCancelClick}}" dismissive>Cancel</paper-button>
                            <paper-button class="tg-snatchback-button" on-click="{{onOkClick}}" affirmative default>Ok</paper-button>
                        </div>
                    </div>
                </paper-shadow>
            </core-overlay>

            <shadow></shadow>
            <p>$.input.committedValue: {{$.input.committedValue}}</p>

        </div>
    </template>

    <script>
        (function () {
            function escapeRegExp(str) {
                return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
            }

            function replaceAll(find, replace, str) {
                // 'g' is the flag for global match,
                // 'i' is the flag to ignore the case during matching
                return str.replace(new RegExp(escapeRegExp(find), 'g', 'i'), replace);
            }

            Polymer('tg-entity-editor', {
                /* 
                 * Indicates what kind of entity value is expected for the bound property -- with simple or composite key.
                 * This effect the way found values are rendered in the overlay with suggested values.
                 */
                composite: false,
                /*
                 * Should contain a text to be displayed as an editor tooltip.
                 * The tooltip does not get displayed if the value is empty (or null for that matter).
                 */
                tooltip: "",
                /*
                 * A helper flag to driver the internal editor logic.
                 */
                isSearching: false,

                /**
                 * The bound to this editor property of the bound entity should be of String type.
                 * Therefore, it is expected that the passed in value is either a null or a String.
                 */
                convertToString: function (value) {
                    return value === null ? "" : "" + value;
                },

                /**
                 * The bound to this editor property of the bound entity should be of String type.
                 * Therefore, the string value from the editor should either be taken as is if it is not empty,
                 * or converted to null due to the fact that there should be no empty string representing an entity key.
                 */
                convertFromString: function (strValue) {
                    return strValue === '' ? null : strValue;
                },

                /* 
                 * The selected item in the list of found entities, presented in the overlay.
                 */
                selectedItem: null,

                /*
                 * Handles selection/deselection
                 */
                onSelectItem: function (event) {
                    var key = event.detail.item.getAttribute("value");
                    console.log('selected item in overlay: ', event.detail.isSelected, ' ', key);
                    if (event.detail.isSelected) {
                        this.selectedItem = _.find(this.matchedValues, function (obj) {
                            return obj.key === key;
                        });
                    } else {
                        this.selectedItem = null;
                    }
                    console.log('this.selectedItems: ', this.selectedItem);
                },

                /* 
                 * Regular expression to search for and highlight found matches
                 */
                searchQuery: "",

                /* Returns an array of parts of a string that corresponds to a key (or desc) property value of the returned entity, 
                   split by matching and non-matching portions;
                   This function is used to identify parts of the string that need to be highlighted when present to the user.
                */
                matchedParts: function matchedParts(str) {
                    var parts = [];
                    // if all is matched then return a single value
                    if ("\\w*" == this.searchQuery) {
                        parts.push({
                            part: str,
                            matched: true
                        });
                        return parts;
                    } else if ('' == this.searchQuery) {
                        return parts;
                    }

                    // otherwise split 
                    var searchExp = new RegExp(this.searchQuery, 'g', 'i');
                    var match;
                    var startIndex = 0;
                    while ((match = searchExp.exec(str)) !== null) {
                        if (match.index > startIndex) { // match is not from the start, so need to record thing before as not matched
                            var part = {
                                part: str.substring(startIndex, match.index),
                                matched: false
                            };
                            parts.push(part);
                            //console.log(part);
                        }

                        // record the matched part
                        var part = {
                            part: str.substring(match.index, searchExp.lastIndex),
                            matched: true
                        };
                        parts.push(part);
                        //console.log(part);

                        startIndex = searchExp.lastIndex;

                    }
                    // check if there is an unmatched part at the end
                    if (startIndex < str.length) {
                        var part = {
                            part: str.substring(startIndex, str.length),
                            matched: false
                        };
                        parts.push(part);
                        //console.log(part);
                    }
                    // return the result
                    return parts;
                },

                /* A position of the start of the search string the input value. */
                replaceFromIndex: 0,
                /* A position of the end of the search string the input value. */
                replaceToIndex: 0,

                /* 
                 * The function that actually perform the search and opensup the overlay with matched values.
                 */
                search: function () {
                    this.isSearching = true;
                    // need to implement the actuall search 
                    // what is the query string?
                    var inputText = this.$.input.value;
                    console.log('raw search query (to be send to server): ', inputText);

                    // prep this.searchQuery for highlighting of the matching parts in the search result
                    if (!inputText) {
                        this.searchQuery = ""
                    } else {
                        this.searchQuery = replaceAll('*', '\\w*', inputText);
                    }
                    console.log('searchQuery as RegEx: ', this.searchQuery);

                    // clear selection in the overlay, which could have been left there from last search
                    if (this.$.suggestions.selected) {
                        this.$.suggestions.selected.length = 0;
                    }
                    // also need to remove matched values from the last search
                    // in preparation for new search result
                    while (this.matchedValues.length > 0) {
                        this.matchedValues.pop();
                    }

                    // collect new matching values
                    if (this.searchQuery) {
                        // prepare the AJAX request based on the raw search string
                        paramsHolder["___searchString"] = inputText;
                        var serialisedSearchQuery = this.$.serialiser.serialise(paramsHolder);

                        this.$.ajaxSearcher.body = JSON.stringify(ser);
                        this.$.ajaxSearcher.go();
                    }

                },

                onFound: function (entities) {
                    console.log("# of found entities: ", entities.length);
                    // TODO: Need to handle entities some how
                    //       Potentially additional conversion is required
                    for (var index = 0; index < entities.length; index++) {
                        console.log(entities[index].key);
                        this.matchedValues.push(entities[index]);
                    }

                    // once we found the matching values show them, but only if there are some
                    if (!this.$.overlay.opened && this.matchedValues.length > 0) {
                        this.$.overlay.style.position = 'absolute';
                        this.$.overlay.style.top = this.$.decorator.offsetHeight + 'px';
                        this.$.overlay.style.width = this.$.decorator.offsetWidth + 'px';
                        this.$.overlay.toggle();
                    } else if (this.$.overlay.opened && this.matchedValues.length == 0) {
                        this.$.overlay.toggle();
                    }
                    this.isSearching = false;
                },

                /* A timer callback object, which is used to implement typing delay before initiating the search. */
                startSearchTimerCallback: null,
                /* a callback to reack to an input event to trigger search */
                onInput: function () {
                    // a new search is about to begin
                    this.isSearching = true;
                    // clear any search request in already in progress
                    abortSearch();
                    // clear timeout if there is one
                    if (this.startSearchTimerCallback) {
                        clearTimeout(this.startSearchTimerCallback);
                    }

                    // in case the editor was just cleared from value, set property description as tooltip
                    if (!this.$.input.value) {
                        this.tooltip = "TODO: Property desc should be displayed in case of an empty input.";
                    }
                    this.startSearchTimerCallback = setTimeout(this.search.bind(this), 300);
                },

                /* 
                 * A handler of the overlay open event.
                 * Gets invoked when the overlay is fully open.
                 * TODO: Most likely it needs to be removed, but it could be useful for something... not sure what (}-:<
                 */
                suggestionsOpened: function () {

                },

                /* to store matching values */
                matchedValues: [],

                /**
                 * Cancels any active search request.
                 */
                abortSearch: function () {
                    this.$.ajaxSearcher.abort();
                },

                ready: function () {
                    var self = this;

                    self.$.ajaxSearcher.addEventListener('core-response', function (e) {
                        // TODO: check to make sure the result is an expected one... array of entities....
                        var foundEntities = self.$.serialiser.deserialise(e.detail.response).instance;
                        // TODO: Need to convert matched entities to a more suiteable representation
                        self.onFound(foundEntities);
                    });
                },

                /* 
                 * Handles overlay's button Ok click, which confirms selection and assigns it to the input field.
                 */
                onOkClick: function () {
                    // clear tooltip text
                    this.tooltip = "";
                    if (this.selectedItem) {
                        // TODO need to check if this works....
                        this.tooltip = this.selectedItem.desc;
                    }

                    console.log("tooltip:", this.tooltip);


                    var selectedItemToStr = this.selectedItem.key;

                    this.selectedItem = null;

                    if (selectedItemToStr) {
                        this.$.input.value = selectedItemToStr;
                    }

                    this.$.overlay.close();
                    this.$.input.focus();
                    // let's highlight the inseted values
                    this.$.input.selectionStart = this.replaceFromIndex;
                    this.$.input.selectionEnd = this.$.input.selectionStart + selectedItemToStr.length;
                },

                /* 
                 * Handles overlay's button Cancel click.
                 */
                onCancelClick: function () {
                    this.$.overlay.close();
                    this.$.input.focus();
                },

            });
        })();
    </script>
</polymer-element>