<link rel="import" href="/app/tg-element-loader.html">
<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/resources/polymer/iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="/resources/polymer/iron-icons/iron-icons.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">
<link rel="import" href="/resources/polymer/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/resources/components/postal-lib.html">
<link rel="import" href="/resources/components/tg-toast.html">

<dom-module id="tg-custom-action-dialog">
    <style>
        :host {
            display: block;
            background: white;
            color: black;
            padding: 0px;
            overflow: auto;
            /* this is to make host scorable when needed */
            box-shadow: rgba(0, 0, 0, 0.24) -2.3408942051048403px 5.524510324047423px 12.090680100755666px 0px, rgba(0, 0, 0, 0.12) 0px 0px 12px 0px;
        }
        paper-icon-button {
            position: absolute;
            top: 0;
            right: 0;
            color: var(--paper-deep-orange-300);
            --iron-icon-height: 18px;
            --iron-icon-width: 18px;
        }
        paper-icon-button:hover {
            color: var(--paper-deep-orange-600);
        }
    </style>

    <template>
        <tg-element-loader id="elementLoader"></tg-element-loader>
        <tg-toast id="toaster"></tg-toast>
        <paper-icon-button icon="icons:cancel" on-tap="closeDialog"></paper-icon-button>
    </template>
</dom-module>
<script>
    (function () {
        Polymer({

            is: "tg-custom-action-dialog",

            behaviors: [Polymer.IronOverlayBehavior],

            listeners: {
                'iron-overlay-opened': '_dialogOpened',
                'iron-overlay-closed': '_dialogClosed'
            },

            properties: {
                isRunning: {
                    type: Boolean,
                    readOnly: true
                },

                /* Postal subscription to events that trigger dialog closing.
                 * It gets populated in _showDialog and unsubscrived on dialog closed.
                 */
                _subscriptions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _closeEventChannel: {
                    type: String
                },

                _closeEventTopics: {
                    type: Array
                },
                
                /** 
                 * An object that caches already loaded, created and already represented by this dialog elements.
                 * It is used as an optimisation technique to prevent repeated instantiation of elements.
                 * Properties represent element names and their values -- element instances.
                 */
                _cachedElements: {
                	type: Object,
                	value: function () { return {}; }
                }
            },

            ready: function () {
                this.noAutoFocus = false;
                this.noCancelOnOutsideClick = true;
                this.noCancelOnEscKey = true;

                //Initialising the action runner
                this.currentActionRunning = null;
            },

            closeDialog: function () {
                this.close();
            },

            _handleCloseEvent: function (data, envelope) {
                this.closeDialog();
            },
            
            /** A convenient method that return a Promise that resolves to an element instaces from cache or from the element loader. */
            _getElement: function (customAction) {
            	var self = this;
            	
            	if (self._cachedElements.hasOwnProperty(customAction.elementName)) {
            		console.log("Reusing cached element:", customAction.elementName);
            		var element = self._cachedElements[customAction.elementName];
            		self.$.elementLoader.insert(element);
            		return Promise.resolve(element);
            	} else {
            		self.$.elementLoader.import = customAction.componentUri;
                	self.$.elementLoader.elementName = customAction.elementName;
                	self.$.elementLoader.attrs = customAction.attrs;
                	return self.$.elementLoader.reload();
            	}
            },

            /*
             * customAction -- an action that was actioned by user and may require showing a diglog (e.g. with master)
             * closeEventChannel -- a channel that is provided from the outside and is used to publish for listening to event that should leade to closing of this dialog.
             * closeEventTopics -- event topics that should be listened to on the channel to close this dialog.
             */
            showDialog: function (customAction, closeEventChannel, closeEventTopics) {
                if (this.opened === true) {
                    this.$.toaster.text = 'Please close the currently open dialog.';
                    this.$.toaster.hasMore = true;
                    this.$.toaster.msgText = 'Any operation on the currently open dialog should be completed and the dialog closed before opening anyother dialog.';
                    this.$.toaster.showProgress = false;
                    this.$.toaster.show();
                    console.log("The dialog is already opened and should be closed be being used again.");
                } else {
                    var self = this;
                    if (!self.currentRunningAction) {
                    	self._getElement(customAction)
                            .then(function (element) {
                            	self._cachedElements[customAction.elementName] = element;
                            	
                                self._closeEventChannel = closeEventChannel;
                                self._closeEventTopics = closeEventTopics;
                                self._setIsRunning(true);
                                self.currentRunningAction = customAction;
								
                                var promise = self.currentRunningAction._onExecuted(null, element, null);
                                if (promise) {
                                	return promise
                                	.then(function () {self._showMaster();})
                                	.catch(function () {self.currentRunningAction = null;});
                                } else {
                                    return Promise.resolve()
                                    .then(function () {self._showMaster();})
                                    .catch(function () {self.currentRunningAction = null;});
                                }
                            })
                            .catch(function (error) {
                                self.$.toaster.text = 'There was an error displaying the dialog.';
                                self.$.toaster.hasMore = true;
                                self.$.toaster.msgText = 'There was an error displaying the dialog.<br><br> \
	                                                      <b>Error cause:</b><br>' + error.message;
                                self.$.toaster.showProgress = false;
                                self.$.toaster.show();
                            });
                    }
                }
            },

            _showMaster: function (e) {
            	if (this.currentRunningAction._masterComponent.noUI === true) {
            	    this.currentRunningAction = null;
                }

                if (this.currentRunningAction && (!this.currentRunningAction._masterComponent.hasOwnProperty('noUI') || this.currentRunningAction._masterComponent.noUI === false)) {
                    var self = this;
                    // if there would be a master UI then need to subscribe for this dialog closing messages
                    if (self._closeEventChannel && self._closeEventTopics && self._closeEventTopics.length > 0) {
                        self._subscriptions = [];
                        for (var index = 0; index < self._closeEventTopics.length; index++) {
                            self._subscriptions.push(
                                postal.subscribe({
                                    channel: self._closeEventChannel,
                                    topic: self._closeEventTopics[index],
                                    callback: self._handleCloseEvent.bind(self)
                                }));
                        }
                    }
                    
                    if (this.$.elementLoader.prefDim) {
                    	var prefDim = this.$.elementLoader.prefDim;
                    	this.style.width = prefDim.width() + prefDim.unit;
                        this.style.height = prefDim.height() + prefDim.unit;
                    } else {
                        this.style.width = "auto";
                        this.style.height = "auto";
                    }
                    this.updateStyles();
                    this.refit();
                    // let's open the dialog with magical async...
                    // this ensures that the dialog is opened after its relocation to body and after all layouting is done
                    this.async(function () {
                        this.open();
                    }.bind(this), 100);
                }
            },

            _dialogOpened: function (e, detail, source) {
                this.currentRunningAction = null;
                this._setIsRunning(false);
            },

            _dialogClosed: function () {
                // if there are current subscriptions they need to be unsubscribed
                // due to dialog being closed
                for (var index = 0; index < this._subscriptions.length; index++) {
                    postal.unsubscribe(this._subscriptions[index]);
                }
                this._subscriptions.length = 0;
            }
        });
    })();
</script>