<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/polymer/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="/resources/polymer/iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="/resources/polymer/iron-selector/iron-selector.html">
<link rel="import" href="/resources/polymer/iron-fit-behavior/iron-fit-behavior.html">

<link rel="import" href="/resources/polymer/paper-styles/color.html">
<link rel="import" href="/resources/polymer/paper-item/paper-item.html">

<link rel="import" href="/resources/components/lodash-lib.html">
<link rel="import" href="/resources/editors/tg-highlighting-behavior.html">
<link rel="import" href="/resources/editors/tg-dom-stamper.html">

<dom-module id="tg-menu-list">
    <template>
        <style>
            :host {
                display: block;
                background: white;
                overflow: auto;
                /* this is to make host scorable when needed */
                box-shadow: rgba(0, 0, 0, 0.24) -2.3408942051048403px 5.524510324047423px 12.090680100755666px 0px, rgba(0, 0, 0, 0.12) 0px 0px 12px 0px;
            }
            .menu-item {
                padding: 6px;
                min-width: 100px;
            }
            
            .menu-item:not(:first-of-type){
                border-top: 1px solid #e3e3e3;
            }

            .menu-item:hover {
                cursor: pointer;
                background: var(--paper-blue-50);
                color: var(--paper-blue-500);
            }
            .menu-item:hover .dim {
                color: var(--paper-blue-300);
            }
            .menu-item.iron-selected {
                background: var(--paper-blue-500);
                color: var(--paper-blue-50);
            }
            .menu-item.iron-selected .dim {
                color: var(--paper-blue-100);
            }
            .primary {
                font-size: 10pt;
                padding-bottom: 3px;
            }
            .secondary {
                font-size: 8pt;
            }
            .dim {
                color: gray;
            }
            .truncate {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        </style>
        <iron-selector id="selector" tabindex="0">
            <!-- begin of dom-repeat -->
            <template is="dom-repeat" items="[[_flatMenu]]" as="menuItem">
                <div class="menu-item">
                    <div class="layout vertical" style$="[[_calcMenuItemStyle(menuItem)]]">
                        <tg-dom-stamper class="primary truncate" dom-text="[[_highlightValue(menuItem, 'title', phraseToHighlight)]]"></tg-dom-stamper>
                        <tg-dom-stamper class="secondary dim truncate" dom-text="[[_highlightValue(menuItem, 'description', phraseToHighlight)]]"></tg-dom-stamper>
                    </div>
                </div>
            </template>
            <!-- end of dom-repeat -->
        </iron-selector>
    </template>

</dom-module>

<script>
    (function () {
        var flattenMenu = function (menu, parent) {
            return menu.reduce(function (reduced, menuItem) {
                return reduced.concat(createMenuEntry(menuItem, parent));
            }, []);
        };
        var createMenuEntry = function (menuItem, parent) {
            var res = [];
            var parentMenuItem = {
                title: menuItem.key,
                description: menuItem.desc,
                parent: parent
            };
            if (menuItem.menu && menuItem.menu.length > 0 || menuItem.view) {
                res.push(parentMenuItem);
                if (menuItem.menu && menuItem.menu.length > 0) {
                    res = res.concat(flattenMenu(menuItem.menu, parentMenuItem));
                }
            }
            return res;
        };
        Polymer({
            is: 'tg-menu-list',

            behaviors: [Polymer.IronOverlayBehavior, Polymer.TgBehaviors.TgHighlightingBehavior],

            properties: {
                /**
                 * The menu to flatten. This menu should contain 'key' and 'desc' proprties key for title and desc for description of menu item also
                 */
                menu: {
                    type: Array,
                    observer: "_menuChanged"
                },
                /**
                 * The phrase to search among menu list.
                 */
                phraseToHighlight: {
                    type: String,
                    value: ""
                },

                /**
                 * The function that retrives boundClientRect and offsetHeight from tg-menu-search-input component.
                 */
                retrieveContainerSizes: {
                    type: Function
                },

                /**
                 * An array of flattened menu item hierarchical list
                 */
                _flatMenu: Array,
            },

            ready: function () {
                this.noAutoFocus = true;
                this.alwaysOnTop = true;
            },

            selectNext: function () {
                if (isNaN(selector.selected)) {
                    this.selectFirstVisisble();
                } else {
                    this.$.selector.selectNext();
                }
                this._scrollToSelected();
            },

            selectPrev: function () {
                if (isNaN(selector.selected)) {
                    this.selectLastVisisble();
                } else {
                    this.$.selector.selectPrevious();
                }
                this._scrollToSelected();
            },

            selectFirstVisisble: function () {
                var menuItems = this.querySelectorAll(".menu-item");
                var menuItem, itemIndex;
                for (itemIndex = 0; itemIndex < menuItems.length; itemIndex++) {
                    menuItem = menuItems[itemIndex];
                    if (menuItem.offsetTop + menuItem.offsetHeight > this.scrollTop) {
                        this.$.selector.select(itemIndex);
                        return;
                    }
                }
                this.$.selector.select(0);
            },

            selectLastVisisble: function () {
                var menuItems = this.querySelectorAll(".menu-item");
                var menuItem, itemIndex;
                for (itemIndex = menuItems.length - 1; itemIndex >= 0; itemIndex--) {
                    menuItem = menuItems[itemIndex];
                    if (menuItem.offsetTop < this.scrollTop + this.clientHeight) {
                        this.$.selector.select(itemIndex);
                        return;
                    }
                }
                this.$.selector.select(menuItems.length - 1);
            },
            
            _scrollToSelected: function () {
                var selector = this.$.selector;
                var menuItem;
                if (!isNaN(selector.selected)) {
                    menuItem = this.querySelectorAll(".menu-item")[selector.selected];
                    if (menuItem.offsetTop + menuItem.offsetHeight < this.scrollTop || menuItem.offsetTop > this.scrollTop + this.clientHeight ||
                        menuItem.offsetTop < this.scrollTop  || menuItem.offsetTop + menuItem.offsetHeight > this.scrollTop + this.clientHeight) {
                        if (menuItem.offsetTop < this.scrollTop) {
                            this.scrollTop = menuItem.offsetTop;
                        } else {
                            this.scrollTop += (menuItem.offsetTop + menuItem.offsetHeight) - (this.scrollTop + this.clientHeight);
                        }
                    }
                }
            },

            clearSelection: function () {
                //The call for clear method on _selection object 
                this.$.selector._selection.clear()
                this.$.selector.selected = NaN;
            },

            getSelectedMenuItemPath: function () {
                var selector = this.$.selector;
                var menuItem, menuItemPath;
                if (!isNaN(selector.selected)) {
                    menuItem = this._flatMenu[selector.selected];
                    menuItemPath = menuItem.title;
                    while (menuItem.parent) {
                        menuItemPath = menuItem.parent.title + "/" + menuItemPath;
                        menuItem = menuItem.parent;
                    }
                    return menuItemPath;
                }
                return "";
            },

            isSelected: function () {
                return !isNaN(this.$.selector.selected);
            },

            /* Iron reseze event listener for correct resizing and positioning of an open result overlay. */
            refit: function () {
                var clientRectAndOffsetHeight = this.retrieveContainerSizes();
                var rect = clientRectAndOffsetHeight[0]; // container.getBoundingClientRect();//getClientRects()[0];
                var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;

                var top = rect.top + scrollTop + clientRectAndOffsetHeight[1]; // container.offsetHeight;//rect.bottom + scrollTop;
                var left = rect.left; // + scrollLeft;
                var right = rect.right;
                var width = rect.width;

                this.style.position = 'absolute';
                this.style.top = top + 'px';

                // let's try to accomodate the width of the overlay so that in case 
                // the input field is narrow, but there is additional window width available to the
                // left or right of the input, it would be used.
                var minWidth = 200;
                this.style['min-width'] = minWidth + 'px'; // set mid-width, which is important for shifting overlay to the left
                var visibleWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                var spaceToRightWindowSide = (visibleWidth - right) + width;
                this.style['max-width'] = spaceToRightWindowSide + 'px';
                // is there sufficient space to the right?
                if (spaceToRightWindowSide >= minWidth) {
                    this.style.left = left + 'px';
                    // ideally the overlay width should be the same as the intput's
                    // but, if it gets too narrow the min-widht would fix it
                    this.style.width = width + 'px';
                } else {
                    // otherwise, move the overlay to the left side, but not beyond
                    var adjustment = 5; // minor adjustment to make the overlay fully visible
                    var newLeft = (visibleWidth - (minWidth + adjustment));
                    if (newLeft > 0) {
                        this.style.left = newLeft + 'px';
                    } else {
                        this.style.left = adjustment + 'px';
                    }
                }

                // let's try also to determine the best height depending on the window height and 
                // the current vertical location of the element
                var visibleHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                this.style['max-height'] = (visibleHeight - top - 10) + 'px'; // 10 pixels is an arbitrary adjustment
                this.style['min-height'] = '50px';
            },

            _menuChanged: function (newValue, oldValue) {
                this._flatMenu = flattenMenu(newValue);
            },

            /**
             * Returns the highlighted text representation of the menu item to be shown in title or description.
             */
            _highlightValue: function (menuItem, propName, phraseToHighlight) {
                return phraseToHighlight === '' ?
                    menuItem[propName] :
                    this._matchedParts(menuItem[propName], phraseToHighlight).reduce(function (html, part) {
                        return html + (part.matched ? '<span style="background-color: #ffff46;">' + part.part + '</span>' : part.part);
                    }, "");
            },

            _calcMenuItemStyle: function (menuItem) {
                var margin = 0;
                var marginInc = 16;
                var parent = menuItem.parent;
                while (parent) {
                    margin += marginInc;
                    parent = parent.parent;
                }
                return "margin-left: " + margin + "px";
            }
        });
    })();
</script>