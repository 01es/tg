<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/polymer/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/components/d3-lib.html">

<dom-module id="d3-chart-spike">

    <template>
        <style>
            :host {
                @apply(--layout-vertical);

            }
            svg {
                @apply(--layout-flex);

            }
            .background {
                fill: #DDD;
            }
            .grid path,
            .grid line {
                fill: none;
                stroke: #fff;
            }
            .bar {
                fill: steelblue;
            }
            .bar:hover {
                fill: brown;
            }
        </style>

        <!-- local DOM for your element -->

        <svg id="chart" class="bar-chart"></svg>
        <!-- data bindings in local DOM -->
    </template>

    <script>
        (function () {
            // Holds the default margins for bar chart.
            const defaultMargin = {
                top: 20,
                right: 20,
                bottom: 30,
                left: 40
            };
            //The following two functions create domain values for x axis and y axis accordingly.
            const xDomain = data => data.map(d => d.name);
            const yDomain = data => [0, d3.max(data, d => d.value)];
            // Two following two functions create scales for x axis and y axis accordingly.
            const xScale = (w, data) => {
                return d3.scaleBand()
                    .rangeRound([0, w])
                    .padding(0.1) // could by configurable 
                    .domain(xDomain(data));
            };
            const yScale = (h, data) => {
                return d3.scaleLinear()
                    .range([h, 0])
                    .domain(yDomain(data));
            };
            //Configures bars according to xscale, yscale, height of the chart. Also adds appropriate listeners and tooltips to the bars if they are defined. 
            const bar = (selection, x, y, h, tooltipCallback, clickCallback) => {
                let selectedBar = selection
                    .attr("x", d => x(d.name))
                    .attr("y", d => y(d.value))
                    .attr("height", d => h - y(d.value))
                    .attr("width", x.bandwidth());
                if (tooltipCallback) {
                    selectedBar.attr("tooltip-text", tooltipCallback);
                }
                if (clickCallback) {
                    selectedBar.on("dblclick", clickCallback);
                }
            };

            d3.barChart = (container) => {
                let width = defaultMargin.right + defaultMargin.left;
                let height = defaultMargin.bottom + defaultMargin.top;
                let margin = defaultMargin;
                let data = [];
                let tooltipCallback = d => d.name + ": " + d.value;
                let dblclickCallback = d => alert("you clicked " + d.name + ": " + d.value);
                let currentTransform = d3.zoomIdentity;

                //Drawing the chart 
                const w = width - margin.left - margin.right;
                const h = height - margin.bottom - margin.top;
                //Create x and y scales for grid and axis.
                let x = xScale(w, data);
                let y = yScale(h, data);
                //Creating grid that should be modifiable
                const yGrid = d3.axisLeft(y).tickSize(-w).tickFormat("");
                //Createing x and y axis they also should be modifiable.
                const xAxis = d3.axisBottom(x);
                const yAxis = d3.axisLeft(y).ticks(10, "%");
                // Create a clip path so that zoomed or panned parts would be cut of
                const clipPath = d3.select(container)
                    .append('defs')
                    .append("clipPath").attr("id", "chart-area")
                    .append("rect").attr("width", w).attr("height", h);
                //Create the chart area
                const g = d3.select(container).append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                //Draw background
                const background = g.append("rect")
                    .attr("class", "background")
                    .attr("width", w)
                    .attr("height", h);
                //Draw y grid
                const yGridGroup = g.append("g")
                    .attr("class", "grid y-grid")
                    .call(yGrid);
                //Draw containr that will contain bar chart and it's markers and should be clipped with clip-path
                const graphContainer = g.append("g").attr("clip-path", "url(#chart-area)").append("g").attr("class", "chart-container");
                //Create zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([1, 10])
                    .on("zoom", () => {
                        currentTransform = d3.event.transform;
                        yAxisGroup.call(yAxis.scale(currentTransform.rescaleY(y)));
                        yGridGroup.call(yGrid.scale(currentTransform.rescaleY(y)));
                        graphContainer.attr("transform", "translate(0, " + currentTransform.y + ")scale(1, " + currentTransform.k + ")");
                    });
                g.call(zoom).on("dblclick.zoom", null);
                //Draw bars
                graphContainer.selectAll(".bar")
                    .data(data)
                    .enter().append("rect").attr("class", "bar")
                    .call(bar, x, y, h, tooltipCallback, dblclickCallback);
                //TODO paint markers.
                //Draw x axis
                const xAxisGroup = g.append("g")
                    .attr("class", "axis x-axis")
                    .attr("transform", "translate(0," + h + ")")
                    .call(xAxis);
                //Draw y axis
                const yAxisGroup = g.append("g")
                    .attr("class", "axis y-axis")
                    .call(yAxis);

                const updateChart = () => {
                    const lw = width - margin.left - margin.right;
                    const lh = height - margin.bottom - margin.top;

                    x = xScale(lw, data);
                    y = yScale(lh, data);

                    clipPath.attr("width", lw).attr("height", lh);
                    g.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                    background.attr("width", lw).attr("height", lh);
                    yGridGroup.call(yGrid.scale(y).tickSize(-lw));
                    xAxisGroup.attr("transform", "translate(0," + lh + ")").call(xAxis.scale(x));
                    yAxisGroup.call(yAxis.scale(y));
                    //TODO update markers here.
                    const barsData = graphContainer.selectAll(".bar").data(data).call(bar, x, y, lh);
                    barsData.enter().append("rect").attr("class", "bar").call(bar, x, y, lh, tooltipCallback, dblclickCallback);
                    barsData.exit().remove();
                    // Rescale grid along y axis and also rescale y axis.
                    yGridGroup.call(yGrid.scale(currentTransform.rescaleY(y)));
                    yAxisGroup.call(yAxis.scale(currentTransform.rescaleY(y)));
                };



                const chart = {
                    width: w => {
                        if (w > 0) {
                            width = w;
                            updateChart();
                            return chart;
                        } else {
                            return width;
                        }
                    },
                    height: h => {
                        if (h > 0) {
                            height = h;
                            updateChart();
                            return chart;
                        } else {
                            return height;
                        }
                    },
                    margin: m => {
                        if (m) {
                            margin = {
                                top: m.hasOwnProperty("top") ? m.top : defaultMargin.top,
                                bottom: m.hasOwnProperty("bottom") ? m.bottom : defaultMargin.bottom,
                                right: m.hasOwnProperty("right") ? m.right : defaultMargin.right,
                                left: m.hasOwnProperty("left") ? m.left : defaultMargin.left
                            };
                            updateChart();
                            return chart;
                        } else {
                            return margin;
                        }
                    },
                    data: d => {
                        if (d) {
                            data = d;
                            updateChart();
                            return chart;
                        } else {
                            return data;
                        }
                    },
                    tooltip: callback => {
                        if (callback) {
                            tooltipCallback = callback;
                            g.selectAll(".bar").attr("tooltip-text", tooltipCallback);
                            return chart;
                        } else {
                            return tooltipCallback;
                        }
                    },
                    dblclick: callback => {
                        if (callback) {
                            dblclickCallback = callback;
                            g.selectAll(".bar").on("dblclick", dblclickCallback);
                            return chart;
                        } else {
                            return dblclickCallback;
                        }
                    }
                };

                return chart;
            };

            // element registration
            Polymer({
                is: "d3-chart-spike",

                // add properties and methods on the element's prototype

                properties: {
                    // Declare properties for the element's public API
                    data: {
                        type: Array,
                        observer: "_dataChanged"
                    },

                    tooltipCallback: {
                        type: Function,
                        observer: "_tooltipCallbackChanged"
                    },

                    dblclickCallback: {
                        type: Function,
                        observer: "_dblclickCallbackChanged"
                    },

                    _chart: Object
                },

                behaviors: [Polymer.IronResizableBehavior, Polymer.TgBehaviors.TgTooltipBehavior],

                ready: function () {
                    this._chart = d3.barChart(this.$.chart);
                    if (this.data) {
                        this._chart.data(this.data);
                    }
                    if (this.tooltipCallback) {
                        this._chart.tooltipCallback(this.tooltipCallback);
                    }
                    if (this.dblclickCallback) {
                        this._chart.dblclickCallback(this.dblclickCallback);
                    }
                    this.scopeSubtree(this.$.chart, true);
                    this.addEventListener("iron-resize", this._resizeEventListener.bind(this));
                },

                attached: function () {
                    this._waitForDimensions(0);
                },

                _waitForDimensions: function (time) {
                    this.async(function () {
                        if (this.offsetWidth && this.offsetHeight && this._cahrt) {
                            this._chart.width(this.offsetWidth).height(this.offsetHeight);
                        } else {
                            this._waitForDimensions(100);
                        }
                    }, time);
                },

                _dataChanged: function (newData, oldData) {
                    if (this._chart) {
                        this._chart.data(newData);
                    }
                },

                _tooltipCallbackChanged: function (newCallback, oldCallback) {
                    if (this._chart) {
                        this._chart.tooltipCallback(newCallback);
                    }
                },

                _dblclickCallbackChanged: function (newCallback, oldCallback) {
                    if (this._chart) {
                        this._chart.dblclickCallback(newCallback);
                    }
                },

                _resizeEventListener: function (event, details) {
                    if (this._chart) {
                        this._chart.width(this.offsetWidth).height(this.offsetHeight);
                    }
                }
            });
        })();
    </script>

</dom-module>