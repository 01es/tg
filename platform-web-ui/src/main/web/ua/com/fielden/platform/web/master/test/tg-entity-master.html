<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>entity-master basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
	<script src="/resources/polymer/web-component-tester/browser.js"></script>
	<script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
	<script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
	
	<link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
  
    <link rel="import" href="/app/tg-reflector.html">
    <link rel="import" href="/master_ui/Test_TgPersistentEntityWithProperties"> <!-- ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties -->
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>
	<test-fixture id="MasterFixture">
    	<template>
   		    <tg-TgPersistentEntityWithProperties-master 
		    	id="master" 
		    	entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
		    	entity-id="new" 
		    	current-state="EDIT">
    		</tg-TgPersistentEntityWithProperties-master>
    	</template>
	</test-fixture>

	<script>
		suite('retrieval', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		
		    test('works for new entity', function(done) {
				master.postRetrieved = function(entity, bindingEntity, customObject) {
				    assert.strictEqual(entity.type().fullClassName(), "ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties", "The type of entity response is not correct.");
				    assert.strictEqual(entity.id, null, "The id of entity is not correct.");
				    assert.strictEqual(entity.version, 0, "The version of entity is not correct.");
				
				    // properties:
				    assert.strictEqual(typeof entity.get("integerProp"), "object", "The entity response property is not correct.");
				    assert.strictEqual(entity.get("integerProp"), null, "The entity response property is not correct.");
				
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // try {
				    //     entity.get("desc");
				    //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
				    // }
				    // catch (ex) {
				    //     if (ex instanceof chai.AssertionError) {
				    //         throw ex;
				    //     }
				    //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
				    // }
				
				    // try {
				    //     entity.get("key");
				    //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
				    // }
				    // catch (ex) {
				    //     if (ex instanceof chai.AssertionError) {
				    //         throw ex;
				    //     }
				    //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
				    // }
				
				    // instance meta-properties
				    assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "The entity response instance prop should be not changedFromOriginal.");
				    assert.strictEqual(entity.prop("integerProp").validationResult(), null, "The entity response instance prop should have empty validation result.");
				    assert.strictEqual(entity.prop("integerProp").isRequired(), false, "The entity response instance prop should be not required.");
				    assert.strictEqual(entity.prop("integerProp").isEditable(), true, "The entity response instance prop should be editable.");
				    assert.strictEqual(entity.prop("integerProp").isVisible(), true, "The entity response instance prop should be visible.");
				
				    // binding value ok?
				    assert.strictEqual(typeof bindingEntity.get("integerProp"), "object", "Binding property should be initialised.");
				    assert.strictEqual(bindingEntity.get("integerProp"), null, "Binding property should be string entity representation.");
				
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY PRODUCER: /////////////////////////////////
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    // value ok?
				    assert.ok(entity.get("producerInitProp"), "The property should be initialised.");
				    assert.instanceOf(entity.get("producerInitProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
				    assert.strictEqual(entity.get("producerInitProp").get("key"), "DEFAULT_KEY", "The entity response property should be entity instance with appropriate key.");
				
				    // value is changed?
				    assert.strictEqual(entity.prop("producerInitProp").isChangedFromOriginal(), true, "Instance meta-prop should be not changedFromOriginal.");
				
				    // value validationresult?
				    assert.strictEqual(entity.prop("producerInitProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
				
				    // binding value ok?
				    assert.ok(bindingEntity.get("producerInitProp"), "Binding property should be initialised.");
				    assert.strictEqual(bindingEntity.get("producerInitProp"), "DEFAULT_KEY", "Binding property should be string entity representation.");
				
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY CLASS DEFINITION: /////////////////////////
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    // value ok?
				    assert.ok(entity.get("domainInitProp"), "The property should be initialised.");
				    assert.strictEqual(entity.get("domainInitProp"), "ok", "The entity response property should be correct.");
				
				    // value is changed?
				    assert.strictEqual(entity.prop("domainInitProp").isChangedFromOriginal(), true, "Instance meta-prop should be not changedFromOriginal.");
				
				    // value validationresult?
				    assert.strictEqual(entity.prop("domainInitProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
				
				    // binding value ok?
				    assert.ok(bindingEntity.get("domainInitProp"), "Binding property should be initialised.");
				    assert.strictEqual(bindingEntity.get("domainInitProp"), "ok", "Binding property should be string entity representation.");
				
				    done();
				};
				
				master.retrieve();
		    });
		    
		    test('works for new persisted entity', function(done) {
		    	master.entityId = '4';
		    	
	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.type().fullClassName(), "ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties", "The type of entity response is not correct.");
	                assert.strictEqual(entity.id, 4, "The id of entity response is not correct.");
	                assert.strictEqual(entity.version, 0, "The version of entity response is not correct.");

	                // properties:
	                assert.strictEqual(entity.get("integerProp"), 43, "The entity response property is not correct.");

	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // try {
	                //     entity.get("desc");
	                //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
	                // }
	                // catch (ex) {
	                //     if (ex instanceof chai.AssertionError) {
	                //         throw ex;
	                //     }
	                //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
	                // }

	                // try {
	                //     entity.get("key");
	                //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
	                // }
	                // catch (ex) {
	                //     if (ex instanceof chai.AssertionError) {
	                //         throw ex;
	                //     }
	                //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
	                // }

	                // instance meta-properties
	                assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "The entity response instance prop should be not changedFromOriginal.");
	                assert.strictEqual(entity.prop("integerProp").validationResult(), null, "The entity response instance prop should have empty validation result.");
	                assert.strictEqual(entity.prop("integerProp").isRequired(), false, "The entity response instance prop should be not required.");
	                assert.strictEqual(entity.prop("integerProp").isEditable(), true, "The entity response instance prop should be editable.");
	                assert.strictEqual(entity.prop("integerProp").isVisible(), true, "The entity response instance prop should be visible.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 43, "Binding property should be string entity representation.");

	                done();
	            };

	            master.retrieve();
		    });
		});
		
		suite('validation', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		
		    test('works for property', function(done) {
		    	master.entityId = '4';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("integerProp"), 43, "Property value remain the same (validation did not succeed).");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("integerProp").isChangedFromOriginal(), false, "Instance meta-prop should be NOT changedFromOriginal.");

	                // value validationresult?
	                assert.ok(validatedEntity.prop("integerProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
	                assert.strictEqual(validatedEntity.prop("integerProp").validationResult().message, "Value '10000' is greater than the maximum limit of 9999.", "Property has incorrect validation result message.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 10000, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("integerProp"), 43, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("integerProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 43, "Binding property should be string entity representation.");

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("integerProp", 10000);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for integer property', function (done) {
		    	master.entityId = '4';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("integerProp"), 98, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("integerProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("integerProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 98, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("integerProp"), 43, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("integerProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 43, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("integerProp", 98);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for bigDecimal property', function (done) {
		    	master.entityId = '8';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("bigDecimalProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("bigDecimalProp"), 46.5, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("bigDecimalProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("bigDecimalProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("bigDecimalProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("bigDecimalProp"), 46.5, "Property value should be correct.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("bigDecimalProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("bigDecimalProp"), 23.0, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("bigDecimalProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("bigDecimalProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("bigDecimalProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("bigDecimalProp"), 23.0, "Property value should be correct.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("bigDecimalProp", 46.5);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for boolean property', function (done) {
		    	master.entityId = '10';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.strictEqual(validatedEntity.get("booleanProp"), false, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("booleanProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("booleanProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("booleanProp"), false, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("booleanProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("booleanProp"), true, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("booleanProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("booleanProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("booleanProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("booleanProp"), true, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("booleanProp", false);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for date property', function (done) {
		    	master.entityId = '11';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("dateProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("dateProp"), 10000, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("dateProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("dateProp"), 10000, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("dateProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("dateProp"), 9999, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("dateProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("dateProp"), 9999, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("dateProp", 10000);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for entity property', function (done) {
		    	master.entityId = '5';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("entityProp"), "The property should be initialised.");
	                assert.instanceOf(validatedEntity.get("entityProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
	                assert.strictEqual(validatedEntity.get("entityProp").get("key"), "KEY1", "The entity response property should be entity instance with appropriate key.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("entityProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("entityProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("entityProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("entityProp"), "KEY1", "Binding property should be string entity representation.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("entityProp"), "The property should be initialised.");
	                assert.instanceOf(entity.get("entityProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
	                assert.strictEqual(entity.get("entityProp").get("key"), "KEY3", "The entity response property should be entity instance with appropriate key.");

	                // value is changed?
	                assert.strictEqual(entity.prop("entityProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("entityProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("entityProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("entityProp"), "KEY3", "Binding property should be string entity representation.");

	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("entityProp", "KEY1");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for money property', function (done) {
		    	master.entityId = '7';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("moneyProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("moneyProp").amount, 46.0, "Property value amount should be correct.");
	                assert.strictEqual(validatedEntity.get("moneyProp").currency, "USD", "Property value currency should be correct.");
	                assert.strictEqual(validatedEntity.get("moneyProp").taxPercent, 20, "Property value taxPercent should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("moneyProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("moneyProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("moneyProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("moneyProp").amount, 46.0, "Property value amount should be correct.");
	                assert.strictEqual(bindingEntity.get("moneyProp").currency, "USD", "Property value currency should be correct.");
	                assert.strictEqual(bindingEntity.get("moneyProp").taxPercent, 20, "Property value taxPercent should be correct.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("moneyProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("moneyProp").amount, 23.0, "Property value amount should be correct.");
	                assert.strictEqual(entity.get("moneyProp").currency, "USD", "Property value currency should be correct.");
	                assert.strictEqual(entity.get("moneyProp").taxPercent, null, "Property value taxPercent should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("moneyProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("moneyProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("moneyProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("moneyProp").amount, 23.0, "Property value amount should be correct.");
	                assert.strictEqual(bindingEntity.get("moneyProp").currency, "USD", "Property value currency should be correct.");
	                assert.strictEqual(bindingEntity.get("moneyProp").taxPercent, null, "Property value taxPercent should be correct.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("moneyProp", { "amount" : 46.0, "currency" : "USD", "taxPercent" : 20 });

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for string property', function (done) {
		    	master.entityId = '9';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("stringProp"), "okok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("stringProp"), "ok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "okok");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for any property for new entity', function (done) {
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                assert.strictEqual(validatedEntity.id, null, "The id of entity is not correct.");
	                // value ok?
	                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("stringProp"), "okok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.id, null, "The id of entity is not correct.");

	                // value ok?
	                assert.strictEqual(entity.get("stringProp"), null, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("stringProp"), null, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "okok");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for any property into missing value', function (done) {
		    	master.entityId = '11';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.strictEqual(validatedEntity.get("dateProp"), null, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("dateProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("dateProp"), null, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("dateProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("dateProp"), 9999, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("dateProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("dateProp"), 9999, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("dateProp", null);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for any property simultaneously', function (done) {
		    	master.entityId = '9';
		    	
	            var postValidatedCount = 0;

	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                postValidatedCount = postValidatedCount + 1;
	                if (postValidatedCount > 2) {
	                    assert.fail("", "", "The validation should occur only twice.")
	                }

	                if (postValidatedCount === 1) {
		                // value ok?
		                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
		                assert.strictEqual(validatedEntity.get("stringProp"), "6", "Property value should be correct.");
	
		                // value is changed?
		                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
	
		                // value validationresult?
		                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
	
		                // binding value ok?
		                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
		                assert.strictEqual(bindingEntity.get("stringProp"), "6", "Binding property should be correct number.");
	                } else if (postValidatedCount === 2) {
		                // value ok?
		                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
		                assert.strictEqual(validatedEntity.get("stringProp"), "5", "Property value should be correct.");
	
		                // value is changed?
		                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
	
		                // value validationresult?
		                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
	
		                // binding value ok?
		                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
		                assert.strictEqual(bindingEntity.get("stringProp"), "5", "Binding property should be correct number.");
	
		                done();
	                }
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("stringProp"), "ok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "1");
	                master.validate();

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "2");
	                master.validate();

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "3");
	                master.validate();

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "4");
	                master.validate();

	                master.async(function () {
		                // ACTUAL PROPERTY CHANGE
	                	console.log('	change to 5');
		                master._currBindingEntity.set("stringProp", "5");
		                master.validate();
	                }, 55);

	                //master.async(function () {
		            // ACTUAL PROPERTY CHANGE
		            console.log('	change to 6');
		            bindingEntity.set("stringProp", "6");
		            master.validate();
	                //}, 25);
	            };

	            master.retrieve();
		    });
		});
		
		suite('saving', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		    
		    test('works for new entity', function (done) {
	            master.postSaved = function(potentiallySavedEntity, bindingEntity) {
	                assert.isNotNull(potentiallySavedEntity.id, "Entity id should be not null.");
	                assert.strictEqual(potentiallySavedEntity.version, 0, "Entity version should be the same.");
	             
	                // value ok?
	                assert.ok(potentiallySavedEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(potentiallySavedEntity.get("stringProp"), "okok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(potentiallySavedEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(potentiallySavedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.id, null, "Entity id should be null.");
	                assert.strictEqual(entity.version, 0, "Entity version should be initial.");
	                // value ok?
	                assert.strictEqual(entity.get("stringProp"), null, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("stringProp"), null, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE            
	                bindingEntity.set("requiredValidatedProp", 30);
	                bindingEntity.set("key", "KEY_TO_PASS_VALIDATION_BEFORE_SAVE_" + (new Date()).getTime());
	                bindingEntity.set("stringProp", "okok");

	                master.save();
	            };

	            master.retrieve();
		    });
		    
		    test('works for existing entity', function (done) {

	            master.postSaved = function(potentiallySavedEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedEntity.id, "Entity id should be not null.");
                    assert.strictEqual(potentiallySavedEntity.version, 0, "Entity version should be 0.");
             
                    // value ok?
                    assert.ok(potentiallySavedEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedEntity.get("stringProp"), "ok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be correct number.");

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.set("stringProp", "okok");
                    
                    // kick in the second save and thus the second part of this test 
                    this.postSaved = this.postSavedForExisting;
                    this.save();
	            }.bind(master);
	            
	            master.postSavedForExisting = function (potentiallySavedEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedEntity.id, "Entity id should remain not null.");
                    assert.strictEqual(potentiallySavedEntity.version, 1, "Entity version should be increased.");
             
                    // value ok?
                    assert.ok(potentiallySavedEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedEntity.get("stringProp"), "okok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

                    done();  
	            }.bind(master);

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "ok");
	                bindingEntity.set("requiredValidatedProp", 30);
	                bindingEntity.set("key", "KEY_" + (new Date()).getTime());

	                master.save();
	            };

	            master.retrieve();
		    });
		    
		    test('works for existing entity after validation', function (done) {
	            var postSavedFirst = true;

	            master._postSaverLoadingFinished = function() {
	                if (postSavedFirst === true) {
	                    postSavedFirst = false;
	                    master.validate();
	                }
	            };

	            master.postSaved = function(potentiallySavedEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedEntity.id, "Entity id should be not null.");
                    assert.strictEqual(potentiallySavedEntity.version, 0, "Entity version should be 0.");
             
                    // value ok?
                    assert.ok(potentiallySavedEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedEntity.get("stringProp"), "ok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be correct number.");

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.set("stringProp", "okok");
                    
                 	// kick in validation and thus the second part of this test
                    this.postSaved = this.postSavedForExisting;
                    this.validate();
	            }.bind(master);
	            
	            master.postSavedForExisting = function(potentiallySavedEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedEntity.id, "Entity id should remain not null.");
                    assert.strictEqual(potentiallySavedEntity.version, 1, "Entity version should be increased.");
             
                    // value ok?
                    assert.ok(potentiallySavedEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedEntity.get("stringProp"), "okok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

                    done();  
	            }.bind(master);

	            master.postValidated = function(validatedEntity, newBindingEntity, customObject) {
                    assert.isNotNull(validatedEntity.id, "Entity id should be not null.");
                    assert.strictEqual(validatedEntity.version, 0, "Entity version should be 0.");
             
                    // value ok?
                    assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(validatedEntity.get("stringProp"), "okok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(newBindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(newBindingEntity.get("stringProp"), "okok", "Binding property should be correct.");
	            	
	                master.save();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "ok");
	                bindingEntity.set("requiredValidatedProp", 30);
	                bindingEntity.set("key", "KEY_" + (new Date()).getTime());

	                master.save();
	            };

	            master.retrieve();
		    });
		});
		
		suite('merging', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		    
		    test('works for stale entity', function (done) {
		    	master.entityId = '13';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                assert.strictEqual(validatedEntity.version, 1, "Entity version should be increased.");

	                ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(validatedEntity.get("nonConflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("nonConflictingProp"), "modified", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("nonConflictingProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("nonConflictingProp"), "modified", "Binding property should be correct number.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.ok(validatedEntity.prop("conflictingProp").validationResult(), "Instance meta-prop should have non-empty warning result.");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Warning");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult().message, "The property has been recently changed by other user.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "persistently modified", "Binding property should be correct number.");

	                done();
	            };

	            master.preRetrieved = function(entity) {
	                entity.version = 0;
	                entity.set("conflictingProp", "initial");
	                return entity;
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.version, 0, "Entity version should be original.");

	                ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(entity.get("nonConflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("nonConflictingProp"), "initial", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("nonConflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("nonConflictingProp"), "initial", "Binding property should be string entity representation.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(entity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("conflictingProp"), "initial", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "initial", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("nonConflictingProp", "modified");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for stale entity with conflict', function (done) {
		    	master.entityId = '13';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                assert.strictEqual(validatedEntity.version, 1, "Entity version should be increased.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.ok(validatedEntity.prop("conflictingProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Result");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult().message, "The property has been recently changed by other user. Please revert property value to resolve conflict.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "modified", "Binding property should be correct number.");

	                done();
	            };

	            master.preRetrieved = function(entity) {
	                entity.version = 0;
	                entity.set("conflictingProp", "initial");
	                return entity;
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.version, 0, "Entity version should be original.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(entity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("conflictingProp"), "initial", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "initial", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("conflictingProp", "modified");

	                master.validate();
	            };

	            master.retrieve();
		    });
		});
	</script>
</body>

</html>