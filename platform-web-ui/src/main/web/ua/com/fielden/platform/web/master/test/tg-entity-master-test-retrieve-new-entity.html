<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>entity-master basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
	<script src="/resources/polymer/web-component-tester/browser.js"></script>
	<script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
	<script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
	
	<link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
  
    <link rel="import" href="/tg-reflector">
    <link rel="import" href="/master_ui/Test_TgPersistentEntityWithProperties"> <!-- ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties -->
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>
	<test-fixture id="MasterFixture">
    	<template>
   		    <tg-TgPersistentEntityWithProperties-master 
		    	id="master" 
		    	entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
		    	entity-id="new" 
		    	current-state="EDIT">
    		</tg-TgPersistentEntityWithProperties-master>
    	</template>
	</test-fixture>

	<script>
		suite('<tg-entity-master>', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		
		    test('can retrieve new entity', function(done) {
		    	
				master.postRetrieved = function(entity, bindingEntity, customObject) {
				    assert.strictEqual(entity.type().fullClassName(), "ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties", "The type of entity response is not correct.");
				    assert.strictEqual(entity.id, null, "The id of entity is not correct.");
				    assert.strictEqual(entity.version, 0, "The version of entity is not correct.");
				
				    // properties:
				    assert.strictEqual(typeof entity.get("integerProp"), "object", "The entity response property is not correct.");                
				    assert.strictEqual(entity.get("integerProp"), null, "The entity response property is not correct.");                
				
				
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // try {
				    //     entity.get("desc");
				    //     assert.fail("", "", "The unfetched property for entity should throw an exception.");                    
				    // }
				    // catch (ex) {                   
				    //     if (ex instanceof chai.AssertionError) {
				    //         throw ex;
				    //     }
				    //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");                       
				    // }
				
				    // try {
				    //     entity.get("key");
				    //     assert.fail("", "", "The unfetched property for entity should throw an exception.");                    
				    // }
				    // catch (ex) {                   
				    //     if (ex instanceof chai.AssertionError) {
				    //         throw ex;
				    //     }
				    //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");                       
				    // }
				
				    // instance meta-properties
				    assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "The entity response instance prop should be not changedFromOriginal.");
				    assert.strictEqual(entity.prop("integerProp").validationResult(), null, "The entity response instance prop should have empty validation result.");
				    assert.strictEqual(entity.prop("integerProp").isRequired(), false, "The entity response instance prop should be not required.");
				    assert.strictEqual(entity.prop("integerProp").isEditable(), true, "The entity response instance prop should be editable.");
				    assert.strictEqual(entity.prop("integerProp").isVisible(), true, "The entity response instance prop should be visible.");
				
				    // binding value ok?
				    assert.strictEqual(typeof bindingEntity.get("integerProp"), "object", "Binding property should be initialised.");                
				    assert.strictEqual(bindingEntity.get("integerProp"), null, "Binding property should be string entity representation.");
				
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY PRODUCER: /////////////////////////////////
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    // value ok?
				    assert.ok(entity.get("producerInitProp"), "The property should be initialised.");                
				    assert.instanceOf(entity.get("producerInitProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
				    assert.strictEqual(entity.get("producerInitProp").get("key"), "DEFAULT_KEY", "The entity response property should be entity instance with appropriate key.");
				
				    // value is changed?
				    assert.strictEqual(entity.prop("producerInitProp").isChangedFromOriginal(), true, "Instance meta-prop should be not changedFromOriginal.");
				
				    // value validationresult?
				    assert.strictEqual(entity.prop("producerInitProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
				
				    // binding value ok?
				    assert.ok(bindingEntity.get("producerInitProp"), "Binding property should be initialised.");                
				    assert.strictEqual(bindingEntity.get("producerInitProp"), "DEFAULT_KEY", "Binding property should be string entity representation.");
				
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY CLASS DEFINITION: /////////////////////////
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    // value ok?
				    assert.ok(entity.get("domainInitProp"), "The property should be initialised.");                
				    assert.strictEqual(entity.get("domainInitProp"), "ok", "The entity response property should be correct.");
				
				    // value is changed?
				    assert.strictEqual(entity.prop("domainInitProp").isChangedFromOriginal(), true, "Instance meta-prop should be not changedFromOriginal.");
				
				    // value validationresult?
				    assert.strictEqual(entity.prop("domainInitProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
				
				    // binding value ok?
				    assert.ok(bindingEntity.get("domainInitProp"), "Binding property should be initialised.");                
				    assert.strictEqual(bindingEntity.get("domainInitProp"), "ok", "Binding property should be string entity representation.");
				
				    done();
				};
				
				master.retrieve();
		    });
		});
	</script>
</body>

</html>