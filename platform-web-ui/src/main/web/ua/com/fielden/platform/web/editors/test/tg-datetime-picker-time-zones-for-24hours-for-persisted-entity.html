<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tg-datetime-picker tests for time-zone-aware properties</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    
    <script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
    <script src="/resources/polymer/web-component-tester/browser.js"></script>
    <script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
    <script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
    
    <link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
    
    <link rel="import" href="/app/tg-reflector.html">
    <link rel="import" href="/resources/reflection/tg-date-utils.html">
    <link rel="import" href="/master_ui/ua.com.fielden.platform.sample.domain.TgEntityWithTimeZoneDates">
</head>

<body>
    <tg-reflector id="reflector"></tg-reflector>
    <test-fixture id="MasterFixture">
        <template>
            <tg-TgEntityWithTimeZoneDates-master 
                id="master" 
                entity-type="ua.com.fielden.platform.sample.domain.TgEntityWithTimeZoneDates" 
                entity-id="new" 
                current-state="EDIT">
            </tg-TgEntityWithTimeZoneDates-master>
        </template>
    </test-fixture>

    <script>
        suite('UTC property value approximates from', function() {
            var master, reflector;

            setup(function() {
                master = fixture('MasterFixture');
                master.entityId = '79';
                reflector = document.querySelector('#reflector');
            });
            
            var correctlyApproximates = function (done, targetEditingValueInUtc, approximatedEditingValueInUtc, approximatedEditingValueInLocal, concreteAcceptedMillis, laterDuplicatedDaylightSavingHour) {
                var ed = master.$.editor_4_dateProp;
                var edUtc = master.$.editor_4_datePropUtc;

                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(edUtc._editingValue, approximatedEditingValueInUtc, "_editingValue should be correct.");
                    assert.strictEqual(edUtc._commValue, approximatedEditingValueInUtc, "_commValue should be correct.");
                    assert.strictEqual(ed._editingValue, approximatedEditingValueInLocal, "_editingValue should be correct.");
                    assert.strictEqual(ed._commValue, approximatedEditingValueInLocal, "_commValue should be correct.");
                    
                    var acceptedValue = edUtc._acceptedValue;
                    assert.isNotNull(acceptedValue, "_acceptedValue should be non-empty.");
                    if (concreteAcceptedMillis) {
                        assert.strictEqual(acceptedValue, concreteAcceptedMillis, "_acceptedValue should be correct.");
                    }
                    if (laterDuplicatedDaylightSavingHour === true) {
                        assert.strictEqual(edUtc._acceptedValue, ed._acceptedValue + 3600000, "_acceptedValue for UTC date should be the same as for local date + 1 hour (duplicate hour).");
                    } else {
                        assert.strictEqual(edUtc._acceptedValue, ed._acceptedValue, "_acceptedValue should be the same for UTC and local date mirrors (non-duplicate hour).");
                    }

                    assert.strictEqual(validatedEntity.get("dateProp"), acceptedValue, "'dateProp' value should be the same as acceptedValue.");
                    assert.strictEqual(bindingEntity.get("dateProp"), acceptedValue, "Binding 'dateProp' value should be the same as acceptedValue.");
                    assert.strictEqual(validatedEntity.get("datePropUtc"), acceptedValue, "'datePropUtc' value should be the same as acceptedValue.");
                    assert.strictEqual(bindingEntity.get("datePropUtc"), acceptedValue, "Binding 'datePropUtc' value should be the same as acceptedValue.");

                    done();
                };

                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    var localisedMomentOf9999 = _millisDateRepresentation(9999); /* 01/01/1970 11:00:09.999 in Melbourne locale (UTC+11:00) */
                    assert.strictEqual(ed._editingValue, localisedMomentOf9999, "_editingValue should be non-empty on start.");
                    assert.strictEqual(ed._commValue, localisedMomentOf9999, "_commValue should be non-empty on start.");
                    // FIXME at this stage there is no clear indication of why this check fails under some conditions, - please investigate.
                    //   The case if following:
                    //    a) Error: _acceptedValue should be non-empty on start.: expected -3590001 to equal 9999
                    //    b) Australia / Melbourne locale in developer OS which affects both server and client applications.
                    //    c) Mac OS, Chrome browser.
                    // assert.strictEqual(ed._acceptedValue, 9999, "_acceptedValue should be non-empty on start.");
                    var utcMomentOf9999 = _millisDateRepresentation(9999, 'UTC'); /* 01/01/1970 00:00:09.999 in UTC (UTC+00:00) */
                    assert.strictEqual(edUtc._editingValue, utcMomentOf9999, "_editingValue should be non-empty on start.");
                    assert.strictEqual(edUtc._commValue, utcMomentOf9999, "_commValue should be non-empty on start.");
                    // FIXME at this stage there is no clear indication of why this check fails under some conditions, - please investigate.
                    //   The case if following:
                    //    a) Error: _acceptedValue should be non-empty on start.: expected -3590001 to equal 9999
                    //    b) Australia / Melbourne locale in developer OS which affects both server and client applications.
                    //    c) Mac OS, Chrome browser.
                    // assert.strictEqual(edUtc._acceptedValue, 9999, "_acceptedValue should be non-empty on start.");

                    assert.strictEqual(entity.get('dateProp'), 9999, "'property' value should be non-empty on start.");
                    assert.strictEqual(bindingEntity.get('dateProp'), 9999, "Binding 'property' value should be non-empty on start.");
                    assert.strictEqual(entity.get('datePropUtc'), 9999, "'property' value should be non-empty on start.");
                    assert.strictEqual(bindingEntity.get('datePropUtc'), 9999, "Binding 'property' value should be non-empty on start.");

                    edUtc._editingValue = targetEditingValueInUtc;
                    edUtc.commit();
                    assert.strictEqual(edUtc._editingValue, approximatedEditingValueInUtc, "_editingValue should be already approximated.");
                    
                    assert.strictEqual(edUtc._editorValidationMsg, null, 'Editor should not have error.');
                };

                master.retrieve();
            };
            
            test('[01/01/1970 00:00:05.555] to local [01/01/1970 10:00:05.555]', function (done) {
                correctlyApproximates(done, '01/01/1970 00:00:05.555', '01/01/1970 00:00:05.555', '01/01/1970 10:00:05.555', 5555);
            });
            
            test('[01/01/1972 00:00:05.555] to local [01/01/1972 11:00:05.555]', function (done) {
                correctlyApproximates(done, '01/01/1972 00:00:05.555', '01/01/1972 00:00:05.555', '01/01/1972 11:00:05.555');
            });
            
            // return from DST
            test('[06/04/2013 15:30] to local [07/04/2013 02:30]', function (done) {
                correctlyApproximates(done, '06/04/2013 15:30', '06/04/2013 15:30', '07/04/2013 02:30', 1365262200000);
            });
            
            test('[06/04/2013 16:15] to local [07/04/2013 02:15] for the later duplicate daylight saving hour', function (done) {
                correctlyApproximates(done, '06/04/2013 16:15', '06/04/2013 16:15', '07/04/2013 02:15', 1365264900000, true);
            });
            
            test('[06/04/2013 17:15] to local [07/04/2013 03:15]', function (done) {
                correctlyApproximates(done, '06/04/2013 17:15', '06/04/2013 17:15', '07/04/2013 03:15', 1365268500000);
            });
            
            // go to DST
            test('[05/10/2013 15:30] to local [06/10/2013 01:30]', function (done) {
                correctlyApproximates(done, '05/10/2013 15:30', '05/10/2013 15:30', '06/10/2013 01:30', 1380987000000);
            });
            
            test('[05/10/2013 16:30] to local [06/10/2013 03:30]', function (done) {
                correctlyApproximates(done, '05/10/2013 16:30', '05/10/2013 16:30', '06/10/2013 03:30', 1380990600000);
            });
            
            test('[05/10/2013 17:30] to local [06/10/2013 04:30]', function (done) {
                correctlyApproximates(done, '05/10/2013 17:30', '05/10/2013 17:30', '06/10/2013 04:30', 1380994200000);
            });
            
            // weird values -- check complex approximations to work in UTC zone
            test('[9/9/7 9:5 : 34  .  567  ] to local [09/09/2007 09:05:34.567]', function(done) {
                correctlyApproximates(done, '9/9/7 9:5 : 34  .  567  ', '09/09/2007 09:05:34.567', '09/09/2007 19:05:34.567');
            });
        });
        
        suite('LOCAL property value approximates from', function() {
            var master, reflector;

            setup(function() {
                master = fixture('MasterFixture');
                master.entityId = '79';
                reflector = document.querySelector('#reflector');
            });

            var correctlyApproximatesFromLocal = function (done, targetEditingValueInLocal, approximatedEditingValueInLocal, approximatedEditingValueInUtc, concreteAcceptedMillis) {
                var ed = master.$.editor_4_dateProp;
                var edUtc = master.$.editor_4_datePropUtc;

                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(edUtc._editingValue, approximatedEditingValueInUtc, "_editingValue should be correct.");
                    assert.strictEqual(edUtc._commValue, approximatedEditingValueInUtc, "_commValue should be correct.");
                    assert.strictEqual(ed._editingValue, approximatedEditingValueInLocal, "_editingValue should be correct.");
                    assert.strictEqual(ed._commValue, approximatedEditingValueInLocal, "_commValue should be correct.");
                    
                    var acceptedValue = edUtc._acceptedValue;
                    assert.isNotNull(acceptedValue, "_acceptedValue should be non-empty.");
                    if (concreteAcceptedMillis) {
                        assert.strictEqual(acceptedValue, concreteAcceptedMillis, "_acceptedValue should be correct.");
                    }
                    assert.strictEqual(edUtc._acceptedValue, ed._acceptedValue, "_acceptedValue should be the same for UTC and local date mirrors.");

                    assert.strictEqual(validatedEntity.get("dateProp"), acceptedValue, "'dateProp' value should be the same as acceptedValue.");
                    assert.strictEqual(bindingEntity.get("dateProp"), acceptedValue, "Binding 'dateProp' value should be the same as acceptedValue.");
                    assert.strictEqual(validatedEntity.get("datePropUtc"), acceptedValue, "'datePropUtc' value should be the same as acceptedValue.");
                    assert.strictEqual(bindingEntity.get("datePropUtc"), acceptedValue, "Binding 'datePropUtc' value should be the same as acceptedValue.");

                    done();
                };

                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    var localisedMomentOf9999 = _millisDateRepresentation(9999); /* 01/01/1970 11:00:09.999 in Melbourne locale (UTC+11:00) */
                    assert.strictEqual(ed._editingValue, localisedMomentOf9999, "_editingValue should be non-empty on start.");
                    assert.strictEqual(ed._commValue, localisedMomentOf9999, "_commValue should be non-empty on start.");
                    // FIXME at this stage there is no clear indication of why this check fails under some conditions, - please investigate.
                    //   The case if following:
                    //    a) Error: _acceptedValue should be non-empty on start.: expected -3590001 to equal 9999
                    //    b) Australia / Melbourne locale in developer OS which affects both server and client applications.
                    //    c) Mac OS, Chrome browser.
                    // assert.strictEqual(ed._acceptedValue, 9999, "_acceptedValue should be non-empty on start.");
                    var utcMomentOf9999 = _millisDateRepresentation(9999, 'UTC'); /* 01/01/1970 00:00:09.999 in UTC (UTC+00:00) */
                    assert.strictEqual(edUtc._editingValue, utcMomentOf9999, "_editingValue should be non-empty on start.");
                    assert.strictEqual(edUtc._commValue, utcMomentOf9999, "_commValue should be non-empty on start.");
                    // FIXME at this stage there is no clear indication of why this check fails under some conditions, - please investigate.
                    //   The case if following:
                    //    a) Error: _acceptedValue should be non-empty on start.: expected -3590001 to equal 9999
                    //    b) Australia / Melbourne locale in developer OS which affects both server and client applications.
                    //    c) Mac OS, Chrome browser.
                    // assert.strictEqual(edUtc._acceptedValue, 9999, "_acceptedValue should be non-empty on start.");

                    assert.strictEqual(entity.get('dateProp'), 9999, "'property' value should be non-empty on start.");
                    assert.strictEqual(bindingEntity.get('dateProp'), 9999, "Binding 'property' value should be non-empty on start.");
                    assert.strictEqual(entity.get('datePropUtc'), 9999, "'property' value should be non-empty on start.");
                    assert.strictEqual(bindingEntity.get('datePropUtc'), 9999, "Binding 'property' value should be non-empty on start.");

                    ed._editingValue = targetEditingValueInLocal;
                    ed.commit();
                    assert.strictEqual(ed._editingValue, approximatedEditingValueInLocal, "_editingValue should be already approximated.");
                    
                    assert.strictEqual(ed._editorValidationMsg, null, 'Editor should not have error.');
                };

                master.retrieve();
            };
            
            // return from DST
            test('[07/04/2013 02:30] to UTC [06/04/2013 15:30]', function (done) {
                correctlyApproximatesFromLocal(done, '07/04/2013 02:30', '07/04/2013 02:30', '06/04/2013 15:30', 1365262200000);
            });
            
            // TODO there is no way at this stage to get UTC date 06/04/2013 16:15 from local
            
            test('[07/04/2013 03:15] to UTC [06/04/2013 17:15]', function (done) {
                correctlyApproximatesFromLocal(done, '07/04/2013 03:15', '07/04/2013 03:15', '06/04/2013 17:15', 1365268500000);
            });
            
            // go to DST
            test('[06/10/2013 01:30] to UTC [05/10/2013 15:30]', function (done) {
                correctlyApproximatesFromLocal(done, '06/10/2013 01:30', '06/10/2013 01:30', '05/10/2013 15:30', 1380987000000);
            });
            
            test('[06/10/2013 02:30] to UTC [05/10/2013 16:30]', function (done) {
                // interesting case -- value immediately aproximates from "unexisting" time 2:30 to 3:30
                correctlyApproximatesFromLocal(done, '06/10/2013 02:30', '06/10/2013 03:30', '05/10/2013 16:30', 1380990600000);
            });
            
            test('[06/10/2013 03:30] to UTC [05/10/2013 16:30]', function (done) {
                correctlyApproximatesFromLocal(done, '06/10/2013 03:30', '06/10/2013 03:30', '05/10/2013 16:30', 1380990600000);
            });
        });
    </script>
</body>
</html>