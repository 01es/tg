<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>entity-master conflict resolution tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    
    <script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
    <script src="/resources/polymer/web-component-tester/browser.js"></script>
    <script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
    <script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
    
    <link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
    
    <link rel="import" href="/app/tg-reflector.html">
    <link rel="import" href="/resources/reflection/tg-date-utils.html">
    <link rel="import" href="/master_ui/ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties"> <!-- Test_TgPersistentEntityWithProperties -->
</head>

<body>
    <tg-reflector id="reflector"></tg-reflector>
    <test-fixture id="MasterFixture">
        <template>
            <tg-TgPersistentEntityWithProperties-master 
                id="master" 
                entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
                entity-id="new" 
                current-state="EDIT">
            </tg-TgPersistentEntityWithProperties-master>
        </template>
    </test-fixture>
    <test-fixture id="AuxiliaryMasterFixture">
        <template>
            <tg-TgPersistentEntityWithProperties-master 
                id="auxiliaryMaster" 
                entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
                entity-id="new" 
                current-state="EDIT">
            </tg-TgPersistentEntityWithProperties-master>
        </template>
    </test-fixture>
    
    <script>
        suite('conflict resolution:', function() {
            var master, auxiliaryMaster, reflector, originalVersion;
            
            var _editProperties = function (master, property, propEditingValue) {
                master.$['editor_4_' + property]._editingValue = propEditingValue;
                master.$['editor_4_' + property].commit();
            };
            
            setup(function() {
                master = fixture('MasterFixture');
                auxiliaryMaster = fixture('AuxiliaryMasterFixture');
                reflector = document.querySelector('#reflector');
            });
            
            test('non-conflicting property resolves fully after first validation cycle and warning dissapears during consequent validation cycles', function (done) {
                master.entityId = '16';
                auxiliaryMaster.entityId = '16';
                
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(validatedEntity.version, originalVersion + 1, "Entity version should be increased.");
                    
                    ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
                    // value ok?
                    assert.ok(validatedEntity.get("nonConflictingProp"), "Property value should be initialised.");
                    assert.strictEqual(validatedEntity.get("nonConflictingProp"), "modified", "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(validatedEntity.prop("nonConflictingProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
                    
                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
                    
                    // binding value ok?
                    assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("nonConflictingProp"), "modified", "Binding property should be correct.");
                    
                    ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
                    // value ok?
                    assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
                    assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");
                    
                    // value validationresult?
                    assert.ok(validatedEntity.prop("conflictingProp").validationResult(), "Instance meta-prop should have non-empty warning result.");
                    assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Warning");
                    assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult().message, "The property has been recently changed by other user.");
                    
                    // binding value ok?
                    assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("conflictingProp"), "persistently modified", "Binding property should be correct number.");
                    
                    master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                        assert.strictEqual(validatedEntity.version, originalVersion + 1, "Entity version should be increased.");
                        
                        ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
                        // value ok?
                        assert.ok(validatedEntity.get("nonConflictingProp"), "Property value should be initialised.");
                        assert.strictEqual(validatedEntity.get("nonConflictingProp"), "modified twice", "Property value should be correct.");
                        
                        // value is changed?
                        assert.strictEqual(validatedEntity.prop("nonConflictingProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
                        
                        // value validationresult?
                        assert.strictEqual(validatedEntity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
                        
                        // binding value ok?
                        assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
                        assert.strictEqual(bindingEntity.get("nonConflictingProp"), "modified twice", "Binding property should be correct.");
                        
                        ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
                        // value ok?
                        assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
                        assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");
                        
                        // value is changed?
                        assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");
                        
                        // value validationresult?
                        assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result -- warning about conflict should have been dissapeared.");
                        
                        // binding value ok?
                        assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
                        assert.strictEqual(bindingEntity.get("conflictingProp"), "persistently modified", "Binding property should be correct.");
                        
                        // REVERT THE STATE AND FINISH THE TEST
                        auxiliaryMaster._validationPromiseChanged = function (newValidationPromise, oldValidationPromise) {
                            newValidationPromise.then(function(value) {
                                auxiliaryMaster.save().then(function () {
                                    done();
                                });
                            });
                        };
                        
                        auxiliaryMaster.retrieve().then(function () {
                            _editProperties(auxiliaryMaster, 'conflictingProp', 'initial');
                        });
                    };
                    
                    // perform second validation and observe the result on conflictingProp
                    _editProperties(master, 'nonConflictingProp', 'modified twice');
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    originalVersion = entity.version;
                    
                    ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
                    // value ok?
                    assert.ok(entity.get("nonConflictingProp"), "Property value should be initialised.");
                    assert.strictEqual(entity.get("nonConflictingProp"), "initial", "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(entity.prop("nonConflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");
                    
                    // value validationresult?
                    assert.strictEqual(entity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
                    
                    // binding value ok?
                    assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("nonConflictingProp"), "initial", "Binding property should be string entity representation.");
                    
                    ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
                    // value ok?
                    assert.ok(entity.get("conflictingProp"), "Property value should be initialised.");
                    assert.strictEqual(entity.get("conflictingProp"), "initial", "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(entity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");
                    
                    // value validationresult?
                    assert.strictEqual(entity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
                    
                    // binding value ok?
                    assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("conflictingProp"), "initial", "Binding property should be string entity representation.");
                    
                    // ACTUAL PROPERTY CHANGE (after making the entity stale using auxiliaryMaster)
                    auxiliaryMaster._validationPromiseChanged = function (newValidationPromise, oldValidationPromise) {
                        newValidationPromise.then(function(value) {
                            auxiliaryMaster.save().then(function () {
                                // ACTUAL PROPERTY CHANGE
                                _editProperties(master, 'nonConflictingProp', 'modified');
                            });
                        });
                    };
                    
                    auxiliaryMaster.retrieve().then(function () {
                        _editProperties(auxiliaryMaster, 'conflictingProp', 'persistently modified');
                    });
                };
                
                master.retrieve();
            });
            
/*          test('works for stale entity with conflict', function (done) {
                master.entityId = '16';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(validatedEntity.version, 1, "Entity version should be increased.");
                    
                    ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
                    // value ok?
                    assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
                    assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");
                    
                    // value validationresult?
                    assert.ok(validatedEntity.prop("conflictingProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
                    assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Result");
                    assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult().message, "The property has been recently changed by other user. Please revert property value to resolve conflict.");
                    
                    // binding value ok?
                    assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("conflictingProp"), "modified", "Binding property should be correct number.");
                    
                    done();
                };
                
                master.preRetrieved = function(entity) {
                    entity.version = 0;
                    entity.set("conflictingProp", "initial");
                    return entity;
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    assert.strictEqual(entity.version, 0, "Entity version should be original.");
                    
                    ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
                    // value ok?
                    assert.ok(entity.get("conflictingProp"), "Property value should be initialised.");
                    assert.strictEqual(entity.get("conflictingProp"), "initial", "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(entity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");
                    
                    // value validationresult?
                    assert.strictEqual(entity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
                    
                    // binding value ok?
                    assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("conflictingProp"), "initial", "Binding property should be string entity representation.");
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch("conflictingProp", "modified");
                    
                    master.validate();
                };
                
                master.retrieve();
            });
            */
        });
    </script>
</body>

</html>