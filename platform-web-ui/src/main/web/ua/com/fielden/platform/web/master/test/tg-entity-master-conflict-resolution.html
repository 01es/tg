<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>entity-master conflict resolution tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    
    <script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
    <script src="/resources/polymer/web-component-tester/browser.js"></script>
    <script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
    <script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
    
    <link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
    
    <link rel="import" href="/app/tg-reflector.html">
    <link rel="import" href="/resources/reflection/tg-date-utils.html">
    <link rel="import" href="/master_ui/ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties"> <!-- Test_TgPersistentEntityWithProperties -->
</head>

<body>
    <tg-reflector id="reflector"></tg-reflector>
    <test-fixture id="MasterFixture">
        <template>
            <tg-TgPersistentEntityWithProperties-master 
                id="master" 
                entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
                entity-id="new" 
                current-state="EDIT">
            </tg-TgPersistentEntityWithProperties-master>
        </template>
    </test-fixture>
    <test-fixture id="AuxiliaryMasterFixture">
        <template>
            <tg-TgPersistentEntityWithProperties-master 
                id="auxiliaryMaster" 
                entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
                entity-id="new" 
                current-state="EDIT">
            </tg-TgPersistentEntityWithProperties-master>
        </template>
    </test-fixture>
    
    <script>
        suite('conflict resolution:', function() {
            var master, auxiliaryMaster, reflector, originalVersion;
            
            const _editProperties = function (master, property, propEditingValue) {
                master.$['editor_4_' + property]._editingValue = propEditingValue;
                master.$['editor_4_' + property].commit();
            };
            
            const _checkProperty = function (entity, bindingEntity, originalBindingEntity, propertyName, expectedValue, expectedBindingValue, expectedOriginalBindingValue, expectedChangedFromOriginal, expectedValidationMessage) {
                // value ok?
                assert.strictEqual(entity.get(propertyName), expectedValue, 'Property"s [' + propertyName + '] value should be equal to [' + expectedValue + '].');
                
                // changedFromOriginal ok?
                assert.strictEqual(entity.prop(propertyName).isChangedFromOriginal(), expectedChangedFromOriginal, 'Property"s [' + propertyName + '] changedFromOriginal should be equal to [' + expectedChangedFromOriginal + '].');
                
                // original binding value ok?
                assert.strictEqual(originalBindingEntity.get(propertyName), expectedOriginalBindingValue, 'Property"s [' + propertyName + '] original binding value should be equal to [' + expectedOriginalBindingValue + '].');
                
                // validationresult ok?
                if (expectedValidationMessage === null) {
                    assert.strictEqual(entity.prop(propertyName).validationResult(), null, 'Property"s [' + propertyName + '] validationResult should be empty, i.e. successful validation result.');
                } else if (expectedValidationMessage === 'The property has been recently changed by other user.') {
                    assert.ok(entity.prop(propertyName).validationResult(), 'Property"s [' + propertyName + '] validationResult should be non-empty, i.e. successful validation result with warning.');
                    assert.strictEqual(entity.prop(propertyName).validationResult()['@resultType'], 'ua.com.fielden.platform.error.Warning', 'Property"s [' + propertyName + '] validationResult should be non-empty, i.e. successful validation result with warning.');
                    assert.strictEqual(entity.prop(propertyName).validationResult().message, expectedValidationMessage, 'Property"s [' + propertyName + '] validationResult should be non-empty, i.e. successful validation result with warning.');
                } else { // conflicting error 'The property has been recently changed by other user. Please revert property value to resolve conflict.'
                    assert.ok(entity.prop(propertyName).validationResult(), 'Property"s [' + propertyName + '] validationResult should be non-empty, i.e. unsuccessful validation result.');
                    assert.strictEqual(entity.prop(propertyName).validationResult()['@resultType'], 'ua.com.fielden.platform.error.Result', 'Property"s [' + propertyName + '] validationResult should be non-empty, i.e. unsuccessful validation result.');
                    assert.strictEqual(entity.prop(propertyName).validationResult().message, expectedValidationMessage, 'Property"s [' + propertyName + '] validationResult should be non-empty, i.e. unsuccessful validation result.');
                }
                
                // binding value ok?
                assert.strictEqual(bindingEntity.get(propertyName), expectedBindingValue, 'Property"s [' + propertyName + '] binding value should be equal to [' + expectedBindingValue + '].');
            };
            
            const _originalBindingEntity = function () {
                return master._originalBindingEntity;
            };
            
            setup(function() {
                master = fixture('MasterFixture');
                auxiliaryMaster = fixture('AuxiliaryMasterFixture');
                reflector = document.querySelector('#reflector');
            });
            
            test('non-conflicting property resolves fully after first validation cycle and warning dissapears during consequent validation cycles', function (done) {
                master.entityId = '16';
                auxiliaryMaster.entityId = '16';
                
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(validatedEntity.version, originalVersion + 1, "Entity version should be increased.");
                    assert.strictEqual(bindingEntity.version, originalVersion + 1, "Binding entity version should be increased.");
                    
                    // 3. property state (after first validation)
                    _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'nonConflictingProp', 'modified', 'modified', 'initial', true, null);
                    _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'conflictingProp', 'persistently modified', 'persistently modified', 'persistently modified', false, 'The property has been recently changed by other user.');
                    
                    master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                        assert.strictEqual(validatedEntity.version, originalVersion + 1, "Entity version should be increased.");
                        assert.strictEqual(bindingEntity.version, originalVersion + 1, "Binding entity version should be increased.");
                        
                        // 5. property state (after second validation)
                        _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'nonConflictingProp', 'modified twice', 'modified twice', 'initial', true, null);
                        _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'conflictingProp', 'persistently modified', 'persistently modified', 'persistently modified', false, null); // warning about conflict should have been dissapeared!
                        
                        // 6. revert the state and finish the test
                        auxiliaryMaster._validationPromiseChanged = function (newValidationPromise, oldValidationPromise) {
                            newValidationPromise.then(function(value) {
                                auxiliaryMaster.save().then(function () {
                                    done();
                                });
                            });
                        };
                        auxiliaryMaster.retrieve().then(function () {
                            _editProperties(auxiliaryMaster, 'conflictingProp', 'initial');
                        });
                    };
                    
                    // 4. perform second validation and observe the result on 'conflictingProp'
                    _editProperties(master, 'nonConflictingProp', 'modified twice');
                };
                
                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    originalVersion = entity.version;
                    
                    // 1. original property state
                    _checkProperty(entity, bindingEntity, _originalBindingEntity(), 'nonConflictingProp', 'initial', 'initial', 'initial', false, null);
                    _checkProperty(entity, bindingEntity, _originalBindingEntity(), 'conflictingProp', 'initial', 'initial', 'initial', false, null);
                    
                    auxiliaryMaster._validationPromiseChanged = function (newValidationPromise, oldValidationPromise) {
                        newValidationPromise.then(function(value) {
                            auxiliaryMaster.save().then(function () {
                                // 2. actual property change (after making the entity stale using auxiliaryMaster)
                                _editProperties(master, 'nonConflictingProp', 'modified');
                            });
                        });
                    };
                    auxiliaryMaster.retrieve().then(function () {
                        _editProperties(auxiliaryMaster, 'conflictingProp', 'persistently modified');
                    });
                };
                
                master.retrieve();
            });
            
            test('conflicting property does not resolve after first validation cycle and would not be resoved during consequent validation cycles', function (done) {
                master.entityId = '16';
                auxiliaryMaster.entityId = '16';
                
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(validatedEntity.version, originalVersion, "Entity version should not be increased.");
                    assert.strictEqual(bindingEntity.version, originalVersion, "Binding entity version should not be increased.");
                    
                    // 3. property state (after first validation)
                    _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'nonConflictingProp', 'initial', 'initial', 'initial', false, null);
                    _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'conflictingProp', 'persistently modified', 'modified', 'initial', false, 'The property has been recently changed by other user. Please revert property value to resolve conflict.');
                    
                    master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                        assert.strictEqual(validatedEntity.version, originalVersion, "Entity version should not be increased.");
                        assert.strictEqual(bindingEntity.version, originalVersion, "Binding entity version should not be increased.");
                        
                        // 5. property state (after second validation)
                        _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'nonConflictingProp', 'initial', 'initial', 'initial', false, null);
                        _checkProperty(validatedEntity, bindingEntity, _originalBindingEntity(), 'conflictingProp', 'persistently modified', 'modified twice', 'initial', false, 'The property has been recently changed by other user. Please revert property value to resolve conflict.'); // error about conflict should be preserved!
                        
                        // 6. revert the state and finish the test
                        auxiliaryMaster._validationPromiseChanged = function (newValidationPromise, oldValidationPromise) {
                            newValidationPromise.then(function(value) {
                                auxiliaryMaster.save().then(function () {
                                    done();
                                });
                            });
                        };
                        auxiliaryMaster.retrieve().then(function () {
                            _editProperties(auxiliaryMaster, 'conflictingProp', 'initial');
                        });
                    };
                    
                    // 4. perform second validation and observe the result on 'conflictingProp'
                    _editProperties(master, 'conflictingProp', 'modified twice');
                };
                
                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    originalVersion = entity.version;
                    
                    // 1. original property state
                    _checkProperty(entity, bindingEntity, _originalBindingEntity(), 'nonConflictingProp', 'initial', 'initial', 'initial', false, null);
                    _checkProperty(entity, bindingEntity, _originalBindingEntity(), 'conflictingProp', 'initial', 'initial', 'initial', false, null);
                    
                    auxiliaryMaster._validationPromiseChanged = function (newValidationPromise, oldValidationPromise) {
                        newValidationPromise.then(function(value) {
                            auxiliaryMaster.save().then(function () {
                                // 2. actual property change (after making the entity stale using auxiliaryMaster)
                                _editProperties(master, 'conflictingProp', 'modified');
                            });
                        });
                    };
                    auxiliaryMaster.retrieve().then(function () {
                        _editProperties(auxiliaryMaster, 'conflictingProp', 'persistently modified');
                    });
                };
                
                master.retrieve();
            });
            
        });
    </script>
</body>

</html>