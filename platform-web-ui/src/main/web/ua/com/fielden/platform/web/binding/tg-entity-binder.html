<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/resources/serialisation/tg-serialiser.html">
<link rel="import" href="/tg-reflector">
<link rel="import" href="/resources/polymer/paper-button/paper-button.html">
<link rel="import" href="/resources/polymer/paper-dialog/paper-action-dialog.html">
<link rel="import" href="/resources/polymer/paper-toast/paper-toast.html">
<link rel="import" href="/resources/polymer/paper-spinner/paper-spinner.html">
<link rel="import" href="/resources/components/tg-toast.html">

<polymer-element name="tg-entity-binder" attributes="user onRetrieved onValidated onPreRetrieved currentState uuid">
    <template>
        <tg-reflector id="reflector"></tg-reflector>
        <tg-serialiser id="serialiser"></tg-serialiser>
        <!-- tg-entity-validator id="validator" user="{{user}}" entitytype="{{entitytype}}" onvalidateddefault="{{onValidatedDefault}}" onvalidateddefaulterror="{{onValidatedDefaultError}}" processResponse="{{processResponse}}"></tg-entity-validator -->

        <!-- core-ajax id="ajaxRetriever" url="/users/{{user}}/entity/{{entitytype}}/{{entityid}}" method="GET" handleas="json"></core-ajax -->

        <tg-toast id="toastGreeting"></tg-toast>
    </template>
    <script>
        (function () {
            
            Polymer("tg-entity-binder", {
                publish: {
                    /**
                     * The state for the entity master.
                     *
                     * The master can be only in two states: EDIT and VIEW. The state EDIT
                     * allows user to edit properties and use some actions (as it was defined in Java API with 'enabledWhen').
                     *
                     * The state VIEW allows user to review the entity properties and do some actions (as it was defined in
                     * Java API with 'enabledWhen').
                     *
                     * The initial state can be VIEW or EDIT.
                     */
                    currentState: {
                        value: null,
                        reflect: true
                    }
                },

                refreshCycleMode: null,

                currEntity: null, // represents the current entity
                currBindingEntity: {}, // represents the view of current entity for binding
                originalBindingEntity: null, // represents the view of original entity for binding.
                uuid: null,

                ///////////// toast related //////////////////
                /**
                 * Opens the toast with some message and with indication whether progress is started.
                 */
                openToast: function (entity, toastMsg, hasMoreInfo, moreInfo, showProgress) {
                    this.$.toastGreeting.text = toastMsg;
                    this.$.toastGreeting.hasMore = hasMoreInfo;
                    this.$.toastGreeting.msgText = moreInfo;
                    this.$.toastGreeting.showProgress = showProgress;
                    if (hasMoreInfo) {
                        if (!entity.isValid()) {
                            this.$.toastGreeting.msgHeading = "Error";
                        } else if (entity.isValidWithWarning()) {
                            this.$.toastGreeting.msgHeading = "Warning";
                        } else {
                            this.$.toastGreeting.msgHeading = "Info";
                        }
                    }
                    this.$.toastGreeting.opened = true;
                },

                /**
                 * Opens the toast with some error message including full 'moreInfo' message.
                 */
                openToastForError: function (toastMsg, moreInfo) {
                    this.$.toastGreeting.text = toastMsg;
                    this.$.toastGreeting.hasMore = true;
                    this.$.toastGreeting.msgText = moreInfo;
                    this.$.toastGreeting.showProgress = false;
	                this.$.toastGreeting.msgHeading = "Error";
                    this.$.toastGreeting.opened = true;
                },
                
                toastMsgForError: function (errorResult) {
                	var ex = errorResult.ex;
	                return this.$.reflector.stackTrace(ex);
                },
                
                toastMsg: function (actionName, entity) {
                    if (!entity.isValid()) {
                        return entity.firstFailure().message;
                    } else if (entity.isValidWithWarning()) {
                        return entity.firstWarning().message;
                    } else {
                        return actionName + " completed successfully.";
                    }
                },
                //////////////////////////////////////////////

                /**
                 * Initialisation block. It has all children web components already initialised.
                 */
                ready: function () {
                    var self = this;

                    // IMPORTANT: it is crucial to bind the functions, which will potentially be passed
                    //            into other contexts (for e.g. onValidatedDefault will be used in tg-entity-validator),
                    //            with its original context!
                    self.retrieve = self.retrieve.bind(self);
                    self.validate = self.validate.bind(self);
                    self.doNotValidate = self.doNotValidate.bind(self);
                    self.onValidatedDefault = self.onValidatedDefault.bind(self);
                    self.onValidatedDefaultError = self.onValidatedDefaultError.bind(self);
                    self.onRetrievedDefault = self.onRetrievedDefault.bind(self);
                    self.onRetrievedDefaultError = self.onRetrievedDefaultError.bind(self);
                    self.onSearchedDefaultError = self.onSearchedDefaultError.bind(self);
                    self.startRefreshCycleModeForEditors = self.startRefreshCycleModeForEditors.bind(self);
                    self.resetRefreshCycleModeForEditors = self.resetRefreshCycleModeForEditors.bind(self);
                    self.createModifiedPropertiesHolder = self.createModifiedPropertiesHolder.bind(self);
                    self.processResponse = self.processResponse.bind(self);

                    self.ajaxRetriever().addEventListener('core-response', function (e) {
                    	self.processResponse(e, "retrieve", function (entityAndCustomObject) {
                    		self.onRetrievedDefault(entityAndCustomObject);
                    	}, function (errorResult) {
                    		self.onRetrievedDefaultError(errorResult);
                    	});
                    });
                },
                
                /**
                 * This is the standard processor for 'core-response's and is applicable for all
                 *   responses that contain java Result inside 'e.detail.response'.
                 *
                 * In case when result is not successful (i.e. has 'ex' inside) the toast message is shown 
                 *   and 'customErrorHandlerFor(result)' is invoked.
                 *
                 * In case when result is successful -- 'customHandlerFor(result.instance)' is invoked.
                 */
                processResponse: function(e, name, customHandlerFor, customErrorHandlerFor) {
                	console.log(name, ": core-response: status = ", e.detail.xhr.status, ", e.detail.response = ", e.detail.response);
                    if (e.detail.xhr.status === 200) {
                    	var deserialisedResult = this.$.serialiser.deserialise(e.detail.response);
                    	
                    	if (this.$.reflector.isError(deserialisedResult)) {
                    		// throw the toast message about the server-side error
                            var msg = this.toastMsgForError(deserialisedResult);
                            this.openToastForError(this.$.reflector.exceptionMessage(deserialisedResult.ex), msg);
                    		// continue with custom error handling of the error result
                            customErrorHandlerFor(deserialisedResult);
                    	} else if (this.$.reflector.isWarning(deserialisedResult)) {
                    		// TODO how warnings should be handled?
                    		console.warn(this.toastMsgForError(deserialisedResult));
                    	} else {
                    		// continue with normal handling of the result's instance
    	                    customHandlerFor(deserialisedResult.instance);
                    	}
                    } else {
                    	console.warn(name, ": core-response: non-200-status = ", e.detail.xhr.status, ", e.detail.response = ", e.detail.response);
                    }
                },

                /**
                 * The core-ajax component for entity retrieval.
                 */
                ajaxRetriever: function () {
                    throw "ajaxRetriever: not implemented";
                },

                /**
                 * The tg-entity-validator component for entity validation.
                 */
                validator: function () {
                    throw "validator: not implemented";
                },

                //////////////////////////////////////// RETRIEVAL ////////////////////////////////////////
                /**
                 * Starts the process of entity retrieval (based on current entityid).
                 */
                retrieve: function (context) {
                	if (context) {
                        var ser = this.$.serialiser.serialise(context);
                        this.ajaxRetriever().body = JSON.stringify(ser);
                	}
                    this.ajaxRetriever().go();
                    this.startRefreshCycleModeForEditors();
                },

                /**
                 * Default implementation for onPreRetrieved callback.
                 */
                onPreRetrieved: function (entity) {
                    return entity;
                },
                
                onDescendantRetrieved: function(entity, newBindingEntity, customObject) {
                },
                
                /**
                 * Default implementation for onRetrieved callback.
                 */
                onRetrievedDefault: function (entityAndCustomObject) {
                    var entity = this.onPreRetrieved(entityAndCustomObject[0]);
                    var customObject = this.$.reflector.customObject(entityAndCustomObject);

                    // this.startRefreshCycleModeForEditors();
                    var newBindingEntity = this.onEntityReceived(entity);
                    
                    this.onDescendantRetrieved(entity, newBindingEntity, customObject);
                    // custom external action
                    this.onRetrieved(entity, newBindingEntity, customObject);
                },
                
                /**
                 * Default implementation for unsuccessful onRetrieved callback.
                 */
                onRetrievedDefaultError: function (errorResult) {
                	// This function will be invoked after server-side error appear.
                	// 'tg-action' will augment this function with its own 'afterExecution' logic (spinner stopping etc.).                	
                	console.warn("SERVER ERROR: ", errorResult);
                },
                
                /**
                 * Default implementation for unsuccessful onSearched callback.
                 */
                onSearchedDefaultError: function (errorResult) {
                	// This function will be invoked after server-side error appear.
                	// 'tg-action' will augment this function with its own 'afterExecution' logic (spinner stopping etc.).                	
                	console.warn("SERVER ERROR: ", errorResult);
                },

                //////////////////////////////////////// VALIDATION ////////////////////////////////////////
                /**
                 * Starts the process of entity validation (based on currBindingEntity).
                 */
                validate: function () {
                    console.log("validate");
                    var self = this;

                    var holder = self.extractModifiedPropertiesHolder(self.currBindingEntity, self.originalBindingEntity);
                    // NOTE: no need to check whether the hasModified(holder) === true -- because the error recovery should happen!
                    // (if the entity was not modified -- validate(holder) will start the error recovery process)

                    // cancel previous validation before starting new one! The results of previous validation are irrelevant!
                    self.validator().abortValidationIfAny();
                    self.validator().validate(self._reset(holder));
                },

                /**
                 * The function that explicitly says that validation is skipped.
                 */
                doNotValidate: function () {
                    console.log("do not validate");
                },

                /**
                 * Default implementation for onValidated callback.
                 */
                onValidatedDefault: function (entityAndCustomObject) {
                    var validatedEntity = entityAndCustomObject[0];
                    var customObject = this.$.reflector.customObject(entityAndCustomObject);
                	
                    var msg = this.toastMsg("Validation", validatedEntity);
                    this.openToast(validatedEntity, msg, !validatedEntity.isValid() || validatedEntity.isValidWithWarning(), msg, false);

                    var newBindingEntity = this.onEntityReceived(validatedEntity);
                    // custom external action
                    this.onValidated(validatedEntity, newBindingEntity, customObject);
                },
                
                /**
                 * Default implementation for unsuccessful onRetrieved callback.
                 */
                onValidatedDefaultError: function (errorResult) {
                	// This function will be invoked after server-side error appear.
                	// 'tg-action' will augment this function with its own 'afterExecution' logic (spinner stopping etc.).                	
                	console.warn("SERVER ERROR: ", errorResult);
                },

                _reset: function (modifiedPropertiesHolder) {
                    delete modifiedPropertiesHolder['@modified']; // remove it not to serialise this purely technical property
                    return modifiedPropertiesHolder;
                },

                /**
                 * Determines whether the specified object represents the entity.
                 */
                _isEntity: function (obj) {
                    return obj !== null && (obj instanceof this.$.reflector.getEntityType());
                },

                extractModifiedPropertiesHolder: function (bindingEntity, originalBindingEntity) {
                    var modPropHolder = {
                        "@modified": false
                    };
                    var self = this;
                    if (self._isEntity(bindingEntity)) {
                        modPropHolder["id"] = bindingEntity["id"];
                        modPropHolder["version"] = bindingEntity["version"];

                        bindingEntity.traverseProperties(function (propertyName) {
                            var value = bindingEntity.get(propertyName);
                            var originalValue = originalBindingEntity.get(propertyName);
                            // VERY IMPORTANT: the property is considered to be 'modified'
                            //                 in the case when its value does not equal to original value.
                            // 
                            //                 The "modified" property is marked by existence of "val" sub-property.
                            //
                            //                 All modified properties will be applied on the server upon the validation prototype.
                            if (!self.$.reflector.equalsEx(value, originalValue)) {
                                // the property is 'modified'
                                modPropHolder[propertyName] = {
                                    "val": value,
                                    "origVal": originalValue
                                };
                                modPropHolder["@modified"] = true;
                            } else {
                                // the property is 'unmodified'
                                modPropHolder[propertyName] = {
                                    "origVal": originalValue
                                };
                            }
                        });
                    }
                    console.log("       extractModifiedPropertiesHolder: modPropHolder", modPropHolder);
                    return modPropHolder;
                },

                createModifiedPropertiesHolder: function () {
                    var self = this;
                    var mph = self.extractModifiedPropertiesHolder(self.currBindingEntity, self.originalBindingEntity);
                    return self._reset(mph);
                },

                _idConvert: function (id) {
                    return id === null ? "new" : ("" + id);
                },

                refreshCycleModeChanged: function (oldValue, newValue) {
                    // console.log("refreshCycleModeChanged", oldValue, newValue);
                },

                /**
                 * Initialises a special state for the editors called "refresh cycle". In this state
                 * the editors promotes their values through the chain: entity => editingValue (commit) => commValue => acceptedValue.
                 *
                 * If the state is simple -- the value promotes through the next chain: editingValue (commit) => commValue => acceptedValue =>
                 * => entity prop value (validate) => new entity prop.
                 */
                startRefreshCycleModeForEditors: function () {
                    this.refreshCycleMode = "ACTIVATED";
                },

                resetRefreshCycleModeForEditors: function () {
                    this.refreshCycleMode = null;
                },

                //////////////////////////////////////// BINDING & UTILS ////////////////////////////////////////
                /**
                 * Provides default action after fresh entity has been received. Rebinds the entity.
                 */
                onEntityReceived: function (entity) {
                    var self = this;
                    // After the entity has received, potentially its id has been updated:
                    if (self._idConvert(entity.id) !== self.entityid) {
                        self.entityid = self._idConvert(entity.id);
                    }
                    // extract previous version of modified properties holder, to merge it with new version of validated entity for invalida properties!
                    var previousModifiedPropertiesHolder = self.extractModifiedPropertiesHolder(self.currBindingEntity, self.originalBindingEntity);
                    self._reset(previousModifiedPropertiesHolder);
                    // New entity should be promoted to the local cache:
                    self.currEntity = entity;
                    // before the next assignment -- the editors should be already prepared for "refresh cycle" (for Retrieve and Save actions)
                    self.currBindingEntity = self._extractBindingView(self.currEntity, previousModifiedPropertiesHolder);
                    self.originalBindingEntity = self._extractOriginalBindingView(self.currEntity);

                    this.resetRefreshCycleModeForEditors();

                    console.log("       onEntityReceived: currBindingEntity + originalBindingEntity", self.currBindingEntity, self.originalBindingEntity);
                    return self.currBindingEntity;
                },

                _extractBindingView: function (entity, previousModifiedPropertiesHolder) {
                    var self = this;
                    bindingView = self.$.reflector.newEntity(entity.type().fullClassName());
                    bindingView["id"] = entity["id"];
                    bindingView["version"] = entity["version"];
                    // this property of the bindingView will hold the reference to fully-fledged entity, 
                    //   this entity can be used effectively to process 'dot-notated' properties (for e.g. retrieving the values) 
                    bindingView["@@origin"] = entity;

                    entity.traverseProperties(function (propertyName) {
                        if (self.$.reflector.isError(entity.prop(propertyName).validationResult())) {
                            if (typeof previousModifiedPropertiesHolder[propertyName].val === 'undefined') {
                                // EDGE-CASE: if the value becomes invalid not because the action done upon this property -- 
                                //   but because the action on other property -- the previous version of modifiedPropsHolder will not hold
                                //   invalid 'attempted value' -- but originalVal exists for this case!
                                bindingView[propertyName] = previousModifiedPropertiesHolder[propertyName].origVal;
                            } else {
                                bindingView[propertyName] = previousModifiedPropertiesHolder[propertyName].val;
                            }

                            bindingView["@" + propertyName + "_error"] = entity.prop(propertyName).validationResult();
                        } else {
                            var converted = self.$.reflector.convert(entity.get(propertyName));
	                        bindingView[propertyName] = converted;

                            var value = entity.get(propertyName);
                            if (self._isEntity(value)) {
                                bindingView["@" + propertyName + "_desc"] = self.$.reflector.convert(value.get("desc"));
                            }

                            if (self.$.reflector.isWarning(entity.prop(propertyName).validationResult())) {
                                bindingView["@" + propertyName + "_warning"] = entity.prop(propertyName).validationResult();
                            }
                            if (entity.prop(propertyName).isRequired()) {
                                bindingView["@" + propertyName + "_required"] = true;
                            } else {
                                bindingView["@" + propertyName + "_required"] = false;
                            }
                            if (entity.type().prop(propertyName).isUpperCase()) {
                                bindingView["@" + propertyName + "_uppercase"] = true;
                            }
                        }
                        
                        bindingView["@" + propertyName + "_editable"] = entity.prop(propertyName).isEditable();

                        if (typeof bindingView[propertyName] === 'undefined' || bindingView[propertyName] === undefined) {
                            throw "Illegal value exception: the property [" + propertyName + "] can not be assigned as [" + bindingView[propertyName] + "].";
                        }
                    });

                    // console.log("       entity + bindingView", entity, bindingView);
                    return bindingView;
                },

                _extractOriginalBindingView: function (entity) {
                    var self = this;
                    var Entity = self.$.reflector.getEntityType();
                    var originalBindingView = new Entity();

                    originalBindingView["_type"] = entity["_type"];
                    originalBindingView["id"] = entity["id"];
                    originalBindingView["version"] = entity["version"];

                    entity.traverseProperties(function (propertyName) {
                        // if (!entity.prop(propertyName).isEditable()) {
                        	// EDGE-CASE: in case of non-editable properties -- originalBindingView should hold the value
                        	//   that is equal to bindingView value -- this makes the property 'unmodified' and 
                        	//   such property will not be applied to validationPrototype on the server.
                        //  	originalBindingView[propertyName] = self.$.reflector.convert(entity.get(propertyName));
                        // } else {
                        originalBindingView[propertyName] = self.$.reflector.convert(entity.getOriginal(propertyName));
                        // }
                    });

                    // console.log("       entity + originalBindingView", entity, bindingView);
                    return originalBindingView;
                }
            });
        })();
    </script>
</polymer-element>