<link rel="import" href="/resources/polymer/leaflet/leaflet-lib.html">
<link rel="import" href="/resources/gis/tg-gis-utils.html">
<link rel="import" href="/resources/gis/tg-base-layers.html">
<link rel="import" href="/resources/gis/tg-entity-styling.html">
<link rel="import" href="/resources/gis/tg-marker-factory.html">
<link rel="import" href="/resources/gis/tg-marker-cluster.html">
<link rel="import" href="/resources/gis/tg-select.html">
<link rel="import" href="/resources/gis/tg-controls.html">

<script>
(function() {
	var GisComponent = function(mapDiv, progressDiv, progressBarDiv, tgMap) {
		// IMPORTANT: use the following reference in cases when you need some properties of the 
		// GisComponent inside the functions or nested classes
		var self = this;
		
		tgMap.retrivedEntitiesHandler = function (newRetrievedEntities) {
            self.initReload();
            self.clearAll();

            // Shallow copy of this array is needed to be done: not to alter original array, that is bound to EGI.
            // Any added features to the shallow copy of the array will not be added to EGI's array of entities.
            // However, if the entity object in copied array will be modified, the same (literally) entity object will be modified also in original array.
            var newRetrievedEntitiesCopy = newRetrievedEntities.slice();
            
		    self.promoteEntities(newRetrievedEntitiesCopy);

            self._markerCluster.setShouldFitToBounds(true); // TODO needs to be customised? " + shouldFitToBounds() + "
            self._markerCluster.getGisMarkerClusterGroup().addLayer(self._geoJsonOverlay);
            self.finishReload();
		};
		
		// creating and configuring all layers
		self._baseLayers = new L.GIS.BaseLayers();

		self._map = L.map(mapDiv, {
			layers: [self._baseLayers.getBaseLayer("OpenStreetMap")], // only add one!
			zoomControl: false, // add it later
			loadingControl: false // add it later
		}).setView([49.841919, 24.0316], 18); // Lviv (Rynok Sq) has been centered

		// create a factory for markers
		self._markerFactory = self.createMarkerFactory();
		self._markerCluster = self.createMarkerCluster(self._map, self._markerFactory, progressDiv, progressBarDiv);
		self._controls = new L.GIS.Controls(self._map, self._markerCluster.getGisMarkerClusterGroup(), self._baseLayers);

		self._entityStyling = self.createEntityStyling();
		self._geoJsonOverlay = L.geoJson([], {
			style: function(feature) {
				return self._entityStyling.getStyle(feature);
			},

			pointToLayer: function(feature, latlng) {
				return self._markerFactory.createFeatureMarker(feature, latlng);
			},

			onEachFeature: function(feature, layer) {
				var layerId = self._geoJsonOverlay.getLayerId(layer);
				// provide leafletId of the layer directly inside corresponding entity
				feature.properties.layerId = layerId; 

				layer.on('mouseover', function() {
					// console.debug("mouseover (entered):");
					// console.debug(layer);
				});

				layer.on('mouseout', function() {
					// console.debug("mouseout (leaved):");
					// console.debug(layer);
				});

				layer.on('click', function() { // dblclick
					// console.debug("clicked:");
					// console.debug(layer);
					self._select.selectById(layerId, false);
				});
				// if (layer instanceof CoordMarker) {
				// 	layer.setOpacity(0.0);
				// }

				feature.properties.popupContent = self.createPopupContent(feature);
				layer.bindPopup(feature.properties.popupContent);
			}
		});

		var getLayerById = function (layerId) {
			return self._geoJsonOverlay.getLayer(layerId);
		}

		self._select = new L.GIS.Select(self._map, getLayerById, self._markerFactory, tgMap);

		self._map.fire('dataloading');

		self.initialise();

		self._markerCluster.getGisMarkerClusterGroup().addLayer(self._geoJsonOverlay);
		self._map.addLayer(self._markerCluster.getGisMarkerClusterGroup());

		self._map.fire('dataload');
	};
	
	GisComponent.prototype.featureType = _featureType;

	GisComponent.prototype.getTopEntityFor = function (feature) {
		if (feature) {
			if (feature.properties._parentFeature !== null) {
				return this.getTopEntityFor(feature.properties._parentFeature);
			} else {
				return feature;
			}
		} else {
			throw "GisComponent.prototype.getTopEntityFor: [" + feature + "] itself is missing.";
		}
	}

	GisComponent.prototype.initialise = function() {
		this._geoJsonOverlay.addData([]);
	};

	GisComponent.prototype.createMarkerFactory = function() {
		return new L.GIS.MarkerFactory();
	};

	GisComponent.prototype.createMarkerCluster = function(map, markerFactory, progressDiv, progressBarDiv) {
		return new L.GIS.MarkerCluster(map, markerFactory, progressDiv, progressBarDiv);
	};

	GisComponent.prototype.createEntityStyling = function() {
		return new L.GIS.EntityStyling();
	};

	GisComponent.prototype.initReload = function() {
		console.debug("initReload");
		this._map.fire('dataloading');
	};

	GisComponent.prototype.finishReload = function() {
		console.debug("finishReload");
		this._map.fire('dataload');
	};

	GisComponent.prototype.clearAll = function() {
		this._geoJsonOverlay.clearLayers();
		this._markerCluster.getGisMarkerClusterGroup().clearLayers();
	};

	GisComponent.prototype.promoteEntityCentreString = function(entityCentreString) {
		var self = this;
		console.debug("Entity centre JSON string parsing...");
		this._entityCentre = JSON.parse(entityCentreString);
		console.debug("Entity centre JSON string parsing ended.");
	};

	GisComponent.prototype.promoteEntitiesString = function (entitiesString) {
		console.debug("Entities JSON string parsing...");
		var _entities = JSON.parse(entitiesString);
		console.debug("Entities JSON string parsing ended.");
		
		self.promoteEntities(_entities);
	};
	
	GisComponent.prototype.promoteEntities = function (newEntities) {
		var self = this;
		this._entities = newEntities;

		this.traverseEntities(this._entities, null /* the parent for top-level entities is null! */, function(entity) {
			if (entity.type) {
			    console.warn('Entity already has "type" object. Cannot continue with conversion into feature.');
			}
			entity.type = "Feature";
			
			if (entity.properties) {
			    console.warn('Entity already has "properties" object. Cannot continue with conversion into feature.');
			}
			entity.properties = entity.properties || {};
			entity.properties._parentFeature = null;

			if (entity.geometry) {
			    throw 'Entity already has "geometry" object. Cannot continue with conversion into feature.';
			}
			entity.geometry = self.createGeometry(entity);

			// console.debug('entity:');
			// console.debug(entity);
			// console.debug('entity.geometry:');
			// console.debug(entity.geometry);

			if (entity.geometry) {
				self._geoJsonOverlay.addData(entity);
			} else {
				// TODO do nothing in case when the entity has no visual representation
				console.debug("entity with no visual representation: ");
				console.debug(entity);
			}				
		}, function (entities) {
			return self.createSummaryFeature(entities);
		});
	};
	
	/** 
	 * The method for creating 'summary' feature for an array of features of different types (designed for overriding).
	 * Query the type of entity with 'featureType(feature)' method.
	 *
	 */
	GisComponent.prototype.createSummaryFeature = function (features) {
		if (features.length > 0) {
			var featureType = this.featureType(features[0]);
			if (featureType === 'TgMessage') {
				var coords = [];
				var machine = features[0].machine;
				for (var i = 0; i < features.length; i++) {
					coords.push(this.createCoordinatesFromMessage(features[i]));
				}
				var summaryFeature = {
					properties: {
						_featureType: ("Summary_" + featureType),
						_coordinates: coords,
						_machine: machine
					}
				};
				return summaryFeature;
			} else {
				throw "GisComponent.prototype.createSummaryFeature: [" + features + "] have unknown type == [" + featureType + "]. Should be 'TgMessage' only.";
			}
		} else {
			throw "GisComponent.prototype.createSummaryFeature: [" + features + "] is empty.";
		}
	}

	/** 
	 * The method for creating geometry objects for features of different types (designed for overriding).
	 * Query the type of entity with 'featureType(feature)' method.
	 */
	GisComponent.prototype.createGeometry = function (feature) {
		var self = this;
		if (feature) {
		    var featureType = this.featureType(feature);
			if (featureType === 'TgMessage') {
				return {
					type: 'Point',
					coordinates: self.createCoordinatesFromMessage(feature)
				};
			} else if (featureType === 'Summary_TgMessage') {
				return {
					type: 'LineString',
					coordinates: feature.properties._coordinates
				};
			} else {
				throw "GisComponent.prototype.createGeometry: [" + feature + "] has unknown type == [" + featureType + "]. Should be 'TgMessage' or 'Summary_TgMessage'.";
			}
		} else {
			throw "GisComponent.prototype.createGeometry: [" + feature + "] is empty.";
		}
	}

	GisComponent.prototype.traverseEntities = function (entities, parentFeature, entityAction, createSummaryFeatureAction) {
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			this.traverseEntity(entity, entityAction, createSummaryFeatureAction); // entityAction converts entity to a feature form

			entity.properties._parentFeature = parentFeature;
		}
		var summaryFeature = createSummaryFeatureAction(entities);
		if (summaryFeature) {
			entities.push(summaryFeature); // the last sibling item to the entities will be summaryFeature (if any)
			entityAction(summaryFeature); // entityAction converts entity to a feature form if it is not feature already

			summaryFeature.properties._parentFeature = parentFeature;
		}
	}

	GisComponent.prototype.traverseEntity = function (entity, entityAction, createSummaryFeatureAction) {
	    var self = this;
		entityAction(entity); // entityAction converts entity to a feature form

		/* if (entity.properties) {
			for (var prop in entity.properties) {
				if (entity.properties.hasOwnProperty(prop)) { // check that the property belongs to the object and not a prototype
					var value = entity.properties[prop];
					if (value && (value instanceof Array)) { // assume that array contains only other entities
						this.traverseEntities(value, entity, entityAction, createSummaryFeatureAction);
					}
				}
			}
		} */
		
		entity.traverseProperties(function (propName) {
		    var value = entity.get(propName);
			if (value && (value instanceof Array)) { // assume that array contains only other entities
				self.traverseEntities(value, entity, entityAction, createSummaryFeatureAction);
			}
		});
	}

	GisComponent.prototype.createCoordinatesFromMessage = function (message) {
		return (message.altitude) ? [message.x, message.y, message.altitude] : [message.x, message.y]
	}

	GisComponent.prototype.createPopupContent = function (feature) {
	    var self = this;
		var popupText = '';

		feature.traverseProperties(function (propName) {
		    var propertyName = !propName ? 'key' : propName;
		    if (propertyName !== 'properties' && propertyName !== 'type' && propertyName !== 'geometry') {
		        // TODO property.title -- retrieve the title from reflector!
		        popupText = popupText + "" + property.title + ": " + self.valueToString(feature.get(propertyName)) + "<br>";
		    }
		});
		return popupText;
	}

/* 	GisComponent.prototype.getValue = function(entity, dotNotation) {
		if (dotNotation.indexOf(".") > -1) {
			// console.debug(entity.properties["" + "lastMessage.properties.gpsTime" + ""]);


			// throw "[" + dotNotation + "] contains dot. Value = [" + (entity.properties["" + "lastMessage.properties.gpsTime" + ""]) + "].";
			var firstPart = this.firstPart(dotNotation);
			var lastPartWithoutProps = this.lastPart(dotNotation);
			return this.getValue(entity.properties["" + firstPart + ""], lastPartWithoutProps);
		} else {
			return entity.properties["" + dotNotation + ""];
		}
	}

	GisComponent.prototype.firstPart = function(dotNotation) {
		return dotNotation.substring(0, dotNotation.indexOf("."));
	}

	GisComponent.prototype.lastPart = function(dotNotation) {
		var withProperties = dotNotation.substring((dotNotation.indexOf(".") + 1), dotNotation.length);
		return withProperties.substring((withProperties.indexOf(".") + 1), withProperties.length);
	} */

	GisComponent.prototype.valueToString = function(value) {
		if (value === null) {
			return '';
		} else if (typeof value === 'number') {
			return Math.round(value);
		} else if (typeof value === 'boolean') {
			return value ? "&#x2714" : "&#x2718";
		} else if (typeof value === 'string') {
			return value;
		} else if (value instanceof Object) {
			return this.valueToString(value.get('key'));
		} else if (value === undefined) {
			return '';
		} else {
			throw "unknown value:" + (typeof value);
		}
		return value;
	}

	/* GisComponent.prototype.getLayer = function (feature) {
		var layerId = feature.properties.layerId;
		return this._geoJsonOverlay.getLayer(layerId); 
	} */
	
	L.GIS = L.GIS || {};
	L.GIS.GisComponent = GisComponent;
})();
</script>