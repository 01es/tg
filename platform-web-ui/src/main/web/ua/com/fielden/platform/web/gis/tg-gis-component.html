<link rel="import" href="/resources/polymer/leaflet/leaflet-lib.html">
<link rel="import" href="/resources/gis/tg-base-layers.html">
<link rel="import" href="/resources/gis/tg-entity-styling.html">
<link rel="import" href="/resources/gis/tg-marker-factory.html">
<link rel="import" href="/resources/gis/tg-marker-cluster.html">
<link rel="import" href="/resources/gis/tg-select.html">
<link rel="import" href="/resources/gis/tg-controls.html">

<script>
(function() {
	var GisComponent = function(mapDiv, progressDiv, progressBarDiv) {
		// IMPORTANT: use the following reference in cases when you need some properties of the 
		// GisComponent inside the functions or nested classes
		var self = this;
		self._leafletIdToEntity = {};

		// creating and configuring all layers
		self._baseLayers = new L.GIS.BaseLayers();

		self._map = L.map(mapDiv, {
			layers: [self._baseLayers.getBaseLayer("OpenStreetMap")], // only add one!
			zoomControl: false, // add it later
			loadingControl: false // add it later
		}).setView([49.841919, 24.0316], 18); // Lviv (Rynok Sq) has been centered

		// create a factory for markers
		self._markerFactory = self.createMarkerFactory();
		self._markerCluster = self.createMarkerCluster(self._map, self._markerFactory, progressDiv, progressBarDiv);
		self._controls = new L.GIS.Controls(self._map, self._markerCluster.getGisMarkerClusterGroup(), self._baseLayers);

		self._entityStyling = self.createEntityStyling();
		self._geoJsonOverlay = L.geoJson([], {
			style: function(feature) {
				return self._entityStyling.getStyle(feature);
			},

			pointToLayer: function(feature, latlng) {
				return self._markerFactory.createEntityMarker(feature, latlng);
			},

			onEachFeature: function(feature, layer) {
				var layerId = self._geoJsonOverlay.getLayerId(layer);
				// provide leafletId of the layer directly inside corresponding entity

				// TODO !!! does feature id contradict with id of the entity?
				// TODO !!! does feature id contradict with id of the entity?
				// TODO !!! does feature id contradict with id of the entity?
				feature.id = layerId; 
				self.setEntityFor(layerId, feature);

				// var featureId = feature.id;
				// self._select.setLeafletIdFor(featureId, self._geoJsonOverlay.getLayerId(layer));

				// console.debug("onEachFeature featureId = " + featureId + " ");	            
				// console.debug(layer);	            

				layer.on('mouseover', function() {
					// console.debug("mouseover (entered):");
					// console.debug(layer);
				});

				layer.on('mouseout', function() {
					// console.debug("mouseout (leaved):");
					// console.debug(layer);
				});

				layer.on('click', function() { // dblclick
					// console.debug("clicked:");
					// console.debug(layer);

					// TODO !!! do we need to use feature.id here?
					// TODO !!! do we need to use feature.id here?
					// TODO !!! do we need to use feature.id here?
					self._select.selectById(featureId);
				});
				// if (layer instanceof CoordMarker) {
				// 	layer.setOpacity(0.0);
				// }

				// does this feature have a property named popupContent?
				if (feature.properties) {
					feature.properties.popupContent = self.createPopupContent(feature);
					layer.bindPopup(feature.properties.popupContent);
				}
			}
		});

		var getLayerByLeafletId = function(leafletId) {
			return self._geoJsonOverlay.getLayer(leafletId);
		}

		self._select = new L.GIS.Select(self._map, getLayerByLeafletId, self._markerFactory);

		self._map.fire('dataloading');

		self.initialise();

		self._markerCluster.getGisMarkerClusterGroup().addLayer(self._geoJsonOverlay);
		self._map.addLayer(self._markerCluster.getGisMarkerClusterGroup());

		self._map.fire('dataload');
	};

	GisComponent.prototype.setEntityFor = function(layerId, entity) {
		this._leafletIdToEntity["" + layerId + ""] = entity;
	}

	GisComponent.prototype.getEntityFor = function(layerId) {
		return this._leafletIdToEntity["" + layerId + ""];
	}

	GisComponent.prototype.getTopEntityFor = function (feature) {
		if (feature) {
			if (feature.properties._parentFeature !== null) {
				return this.getTopEntityFor(feature.properties._parentFeature);
			} else {
				return feature;
			}
		} else {
			throw "GisComponent.prototype.getTopEntityFor: [" + feature + "] itself is missing.";
		}
	}

	GisComponent.prototype.initialise = function() {
		this._geoJsonOverlay.addData([]);
	};

	GisComponent.prototype.createMarkerFactory = function() {
		return new L.GIS.MarkerFactory();
	};

	GisComponent.prototype.createMarkerCluster = function(map, markerFactory, progressDiv, progressBarDiv) {
		return new L.GIS.MarkerCluster(map, markerFactory, progressDiv, progressBarDiv);
	};

	GisComponent.prototype.createEntityStyling = function() {
		return new L.GIS.EntityStyling();
	};

	GisComponent.prototype.initReload = function() {
		console.debug("initReload");
		this._map.fire('dataloading');
	};

	GisComponent.prototype.finishReload = function() {
		console.debug("finishReload");
		this._map.fire('dataload');
	};

	GisComponent.prototype.clearAll = function() {
		this._geoJsonOverlay.clearLayers();
		this._markerCluster.getGisMarkerClusterGroup().clearLayers();
	};

	GisComponent.prototype.promoteEntityCentreString = function(entityCentreString) {
		var self = this;
		console.debug("Entity centre JSON string parsing...");
		this._entityCentre = JSON.parse(entityCentreString);
		console.debug("Entity centre JSON string parsing ended.");
	};

	GisComponent.prototype.promoteEntitiesString = function(entitiesString) {
		var self = this;
		console.debug("Entities JSON string parsing...");
		this._entities = JSON.parse(entitiesString);
		console.debug("Entities JSON string parsing ended.");

		this.traverseEntities(this._entities, null /* the parent for top-level entities is null! */, function(entity) {
			if (entity.type) {
			    throw 'Entity already has "type" object. Cannot continue with conversion into feature.';
			}
			entity.type = "Feature";
			
			if (entity.properties) {
			    throw 'Entity already has "properties" object. Cannot continue with conversion into feature.';
			}
			entity.properties = {
			    _parentFeature: null
			};

			if (entity.geometry) {
			    throw 'Entity already has "geometry" object. Cannot continue with conversion into feature.';
			}
			entity.geometry = self.createGeometry(entity);

			// console.debug('entity:');
			// console.debug(entity);
			// console.debug('entity.geometry:');
			// console.debug(entity.geometry);

			if (entity.geometry) {
				self._geoJsonOverlay.addData(entity);
			} else {
				// TODO do nothing in case when the entity has no visual representation
				console.debug("entity with no visual representation: ");
				console.debug(entity);
			}				
		}, function(entities) {
			return self.createSummaryEntity(entities);
		});
	};
	
	/**
	 * There are feautures of two types: 
	 * 1) features derived from real entities (Message etc.)
	 * 2) virtual features (Summary_Message etc.)
	 * 
	 * This method returns the feature type as a string to be able to differentiate different types of features.
	 */
	GisComponent.prototype.featureType = function (feature) {
	    return typeof feature.properties._featureType !== 'undefined' ? feature.properties._featureType : feature.type()._notEnhancedSimpleClassName();
	}

	/** 
	 * The method for creating 'summary' feature for an array of features of different types (designed for overriding).
	 * Query the type of entity with 'featureType(feature)' method.
	 *
	 * TODO rename to createSummaryFeature!
	 */
	GisComponent.prototype.createSummaryEntity = function (features) {
		if (features.length > 0) {
			var featureType = features[0].type()._notEnhancedSimpleClassName();
			if (featureType === 'Message') {
				var coords = [];
				var machine = features[0].machine;
				for (var i = 0; i < features.length; i++) {
					coords.push(this.createCoordinatesFromMessage(features[i]));
				}
				var summaryFeature = {
					properties: {
						_entityType: ("Summary_" + featureType),
						_coordinates: coords,
						_machine: machine
					}
				};
				return summaryFeature;
			} else {
				throw "GisComponent.prototype.createSummaryEntity: [" + features + "] have unknown type == [" + featureType + "]. Should be 'Message' only.";
			}
		} else {
			throw "GisComponent.prototype.createSummaryEntity: [" + features + "] is empty.";
		}
	}

	/** 
	 * The method for creating geometry objects for features of different types (designed for overriding).
	 * Query the type of entity with 'featureType(feature)' method.
	 */
	GisComponent.prototype.createGeometry = function (feature) {
		var self = this;
		if (feature) {
		    var featureType = self.featureType(feature);
			if (featureType === 'Message') {
				return {
					type: 'Point',
					coordinates: self.createCoordinatesFromMessage(feature)
				};
			} else if (featureType === 'Summary_Message') {
				return {
					type: 'LineString',
					coordinates: feature.properties._coordinates
				};
			} else {
				throw "GisComponent.prototype.createGeometry: [" + feature + "] has unknown type == [" + featureType + "]. Should be 'Message' or 'Summary_Message'.";
			}
		} else {
			throw "GisComponent.prototype.createGeometry: [" + feature + "] is empty.";
		}
	}

	GisComponent.prototype.traverseEntities = function (entities, parentFeature, entityAction, createSummaryEntityAction) {
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			this.traverseEntity(entity, entityAction, createSummaryEntityAction); // entityAction converts entity to a feature form

			entity.properties._parentFeature = parentFeature;
		}
		var summaryEntity = createSummaryEntityAction(entities);
		if (summaryEntity) {
			entities.push(summaryEntity); // the last sibling item to the entities will be summaryEntity (if any)
			entityAction(summaryEntity); // entityAction converts entity to a feature form

			summaryEntity.properties._parentFeature = parentFeature;
		}
	}

	GisComponent.prototype.traverseEntity = function (entity, entityAction, createSummaryEntityAction) {
	    var self = this;
		entityAction(entity); // entityAction converts entity to a feature form

		/* if (entity.properties) {
			for (var prop in entity.properties) {
				if (entity.properties.hasOwnProperty(prop)) { // check that the property belongs to the object and not a prototype
					var value = entity.properties[prop];
					if (value && (value instanceof Array)) { // assume that array contains only other entities
						this.traverseEntities(value, entity, entityAction, createSummaryEntityAction);
					}
				}
			}
		} */
		
		entity.traverseProperties(function (propName) {
		    var value = entity.get(propName);
			if (value && (value instanceof Array)) { // assume that array contains only other entities
				self.traverseEntities(value, entity, entityAction, createSummaryEntityAction);
			}
		});
	}

	GisComponent.prototype.createCoordinatesFromMessage = function (message) {
		return (message.altitude) ? [message.x, message.y, message.altitude] : [message.x, message.y]
	}

	GisComponent.prototype.createPopupContent = function (feature) {
		var popupText = '';

		var resultProps = this._entityCentre.centreConfig.resultProperties;
		for (var i = 0; i < resultProps.length; i++) {
			var property = resultProps[i];
			var propertyName = (!resultProps[i].propertyName) ? 'key' : resultProps[i].propertyName;

			popupText = popupText + "" + property.title + ": " + this.valueToString(feature.get(propertyName)) + "<br>";
		}
		return popupText;
	}

/* 	GisComponent.prototype.getValue = function(entity, dotNotation) {
		if (dotNotation.indexOf(".") > -1) {
			// console.debug(entity.properties["" + "lastMessage.properties.gpsTime" + ""]);


			// throw "[" + dotNotation + "] contains dot. Value = [" + (entity.properties["" + "lastMessage.properties.gpsTime" + ""]) + "].";
			var firstPart = this.firstPart(dotNotation);
			var lastPartWithoutProps = this.lastPart(dotNotation);
			return this.getValue(entity.properties["" + firstPart + ""], lastPartWithoutProps);
		} else {
			return entity.properties["" + dotNotation + ""];
		}
	}

	GisComponent.prototype.firstPart = function(dotNotation) {
		return dotNotation.substring(0, dotNotation.indexOf("."));
	}

	GisComponent.prototype.lastPart = function(dotNotation) {
		var withProperties = dotNotation.substring((dotNotation.indexOf(".") + 1), dotNotation.length);
		return withProperties.substring((withProperties.indexOf(".") + 1), withProperties.length);
	} */

	GisComponent.prototype.valueToString = function(value) {
		if (value === null) {
			return '';
		} else if (typeof value === 'number') {
			return Math.round(value);
		} else if (typeof value === 'boolean') {
			return value ? "&#x2714" : "&#x2718";
		} else if (typeof value === 'string') {
			return value;
		} else if (value instanceof Object) {
			return this.valueToString(value.get('key'));
		} else if (value === undefined) {
			return '';
		} else {
			throw "unknown value:" + (typeof value);
		}
		return value;
	}

	GisComponent.prototype.getLayer = function (feature) {
		var layerId = feature.id;
		return this._geoJsonOverlay.getLayer(layerId); 
	}
	
	L.GIS = L.GIS || {};
	L.GIS.GisComponent = GisComponent;
})();
</script>