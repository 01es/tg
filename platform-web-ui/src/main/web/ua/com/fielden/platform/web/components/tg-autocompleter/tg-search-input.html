<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/polymer/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="/resources/polymer/iron-input/iron-input.html">
<link rel="import" href="/resources/polymer/iron-icons/iron-icons.html">

<link rel="import" href="/resources/polymer/paper-button/paper-button.html">
<link rel="import" href="/resources/polymer/paper-input/paper-input-container.html">
<link rel="import" href="/resources/polymer/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/resources/polymer/paper-spinner/paper-spinner.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">
<link rel="import" href="/resources/polymer/paper-tooltip/paper-tooltip.html">

<link rel="import" href="/resources/components/tg-autocompleter/tg-search-result.html">

<dom-module id="tg-search-input">

    <style>
        .input-layout {
            @apply(--layout-horizontal);
            @apply(--layout-center);
        }
        
        .search-button {
            align-self: flex-end;
            --iron-icon-height: 16px;
            --iron-icon-width: 16px;
            padding-left: 4px;
            padding-right: 2px;
            padding-top: 2px;
            padding-bottom: 2px;
            height: 20px;
            width: 20px;
            margin: 0px;
        }
        
        paper-spinner {
            width: 16px;
            height: 16px;
            min-width: 16px;
            min-height: 16px;
            max-width: 16px;
            max-height: 16px;
            padding-right: 2px;
            margin: 0px;
            --paper-spinner-layer-1-color: var(--paper-blue-500);
            --paper-spinner-layer-2-color: var(--paper-blue-500);
            --paper-spinner-layer-3-color: var(--paper-blue-500);
            --paper-spinner-layer-4-color: var(--paper-blue-500);
        }

        paper-tooltip.custom img {
            width: 40px;
            padding-right: 10px;
            padding-bottom: 10px;
            float: left;
        }

        .custom {
            --paper-tooltip-background: black;
            --paper-tooltip-text-color: var(--paper-pink-100);
            width: 160px;
        }
    </style>

    <template>
        <div id="container">
            <paper-input-container id="decorator">
                <label>search</label>
                <div class="input-layout">
                    <input id="input" is="iron-input" type="text" on-input="_inputEventHandler" on-blur="_blurEventHandler"/>
                    <paper-icon-button hidden$="[[searchingOrOpen]]" on-tap="_search" icon="search" class="search-button" tabIndex="-1"></paper-icon-button>
                    <paper-icon-button hidden$="[[searchingOrClosed]]" on-tap="_done" icon="done" class="search-button" tabIndex="-1"></paper-icon-button>
                    <paper-spinner active hidden$="[[!searching]]" tabIndex="-1" alt="searching..."></paper-spinner>
                </div>
                        <paper-tooltip for="input" class="custom">
          <b>Description</b> with HTML.
        </paper-tooltip>
                
            </paper-input-container>
        </div>
        <tg-search-result id="result" on-iron-overlay-opened="_resultOpened" on-iron-overlay-closed="_resultClosed"></tg-search-result>
    </template>

</dom-module>

<script>
    (function () {
        /* several helper functions for string manipulation */
        function escapeRegExp(str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceAll(find, replace, str) {
            // 'g' is the flag for global match,
            // 'i' is the flag to ignore the case during matching
            return str.replace(new RegExp(escapeRegExp(find), 'g', 'i'), replace);
        }

        Polymer({
            is: 'tg-search-input',

            behaviors: [Polymer.IronResizableBehavior],

            /********************************************************
             ********************************************************
             *********************** PROPERTIES *********************
             ********************************************************
             ********************************************************/
            properties: {
            	/* Indicates whether a search is in progress. This property controls visibility of the progress indecator. */
                searching: {
                    type: Boolean,
                    value: false,
                    notify: false
                },
                
                _searchQuery: {
                    type: String,
                    value: ''
                },
                
                /*
                 * A string with comma separated property names that shoould be displayed in addition to key and desc.
                 */
                additionalProperties: {
                	type: String,
                	value: ''
                },
                
                _asyncSearchHandle: {
                	type: Object,
                	value: null
                },
                
                opened: {
                	type: Boolean,
                	value: false
                },
                
                searchingOrOpen: {
                	type: Boolean,
                	computed: '_computeSearchingOrOpened(searching, opened)'
                },
                
                searchingOrClosed: {
                	type: Boolean,
                	computed: '_computeSearchingOrClosed(searching, opened)'
                },
                
                /* Indicates whether multiple (true) or a single (false, default) value is acceptable. */
                multi: {
                	type: Boolean,
                	value: false
                },
                
                _replaceFromIndex: {
                	type: Number,
                	value: 0
                },
                
                _replaceToIndex: {
                	type: Number,
                	value: 0
                },
                
               	separator: {
               		type: String,
               		value: ","
               	}
            },

            listeners: {
                'iron-resize': '_onIronResize'
            },

            ready: function() {
            	var result = this.$.result;
            	result.multi = this.multi;
                if (this.additionalProperties) {
            		result.additionalProperties = JSON.parse(this.additionalProperties);
                }
            },
            
            attached: function () {
                this.async(this.notifyResize, 1);
            },

            _computeSearchingOrOpened: function(searching, opened) {
            	return searching === true || opened == true;
            },
            
            _computeSearchingOrClosed: function(searching, opened) {
            	return searching === true || opened == false;
            },
            
            /**
             * Cleans input text.
             */
            _prepInput: function (str) {
                if (str) {
                    return str.replace(/\*\*/g, "*");
                }
                return str;
            },

            _search: function () {
                // TODO need to implement the actuall search
                
                // What is the query string?
                var inputText = ''; // default value
                if (this.multi === false) {
                	// assign the actual search string
                	inputText = this._prepInput(this.$.input.value);
                } else {
                    // The following manipulations with indexes are required in case of multi selection
                    // in order to detremine what part of the input text should be used for search and
                    // also for later insertion of selected values (this._replaceFromIndex and this._replaceToIndex govern this).

                	var text = this.$.input.value;
                	var caretPos = this.$.input.selectionStart;
                	var toIndex = text.indexOf(this.separator, caretPos);
                
                	if (toIndex < 0) {
                		toIndex = text.length;
                	}
                	var startOfText = text.substring(0, caretPos);
                	var fromIndex = startOfText.lastIndexOf(this.separator);
                
                	if (fromIndex < 0) {
                		fromIndex = -1; // just to make sure that it is -1
                	}

                	this._replaceFromIndex = fromIndex;
                	this._replaceToIndex = toIndex;
                	
                	// assign the actual search string
                	inputText = this._prepInput(text.substring(fromIndex + 1, toIndex).trim());
                }                
               	
                // prep this.searchQuery for highlighting of the matching parts in the search result
                if (!inputText) {
                    this._searchQuery = "";
                    this.searching = false;
                } else {
                    this._searchQuery = replaceAll('*', '\\w*', inputText.toUpperCase());
                }

                // collect new matching values
                var self = this;
                var result = self.$.result;
                result.searchQuery = self._searchQuery;
                var container = self.$.container;

                if (this._searchQuery /*&& this.hasFocus === true*/ ) {
                    this.searching = true;

                    // TODO need to convert in the context of TG
                    // prepare the AJAX request based on the raw search string
                    //var serialisedSearchQuery = this.$.serialiser.serialise(this.createContextHolder(inputText));
                    //this.$.ajaxSearcher.body = JSON.stringify(serialisedSearchQuery);
                    //this.$.ajaxSearcher.generateRequest();

                    // TODO Demo only, remove when moving to the TG context

                    self.async((function () {
                        result.close();
                    }).bind(self), 1);

                    this.async((function () {
                        result.clearSelection();
                        self.searching = false;
                        var values = [{
                            key: 'KEY 1',
                            desc: "some description for key 1",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 2',
                            desc: "some description for key 2",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 3',
                            desc: "some description for key 3 some description for key 3 some description for key 3 some description for key 3",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 4',
                            desc: "some description for key 4",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 5',
                            desc: "some new word for key 5",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 6',
                            desc: "some description for key 6",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }];
                       
                       for (var index = 0; index < values.length; index++) {
                           result.pushValue(values[index]);
                       }
                       
                        self.async(function () {
                        	this.async(this.notifyResize, 1);
                            result.open();
                        });

                    }).bind(self), 700); // some delay to mimic the search time

                } else if (result.opened) { // make sure overlay is closed is no search is performed
                    result.close();
                }
            },
            
            _inputEventHandler: function(e) {
            	// clear any search request in already in progress
                this._cancelSearch();
                this._asyncSearchHandle = this.async(this._search.bind(this), 700);            	
            },
            
            _blurEventHandler: function(e) {
            	// There is no need to proceed with search if user moved out of the search field
            	this._cancelSearch();
            	
            	// However, if user typed in a new value it may need to be validated...
            	// TODO implement logic to enforce validation of the typed rather than selected value
            },
            
            _cancelSearch: function() {
            	if (this._asyncSearchHandle) {
            		this.cancelAsync(this._asyncSearchHandle);
            		this._asyncSearchHandle = null;
            	}
            },
            
            _resultOpened: function(e) {
            	this.opened = true;
            	this.$.result.highlightMatchedParts();
				this._focusInput();            	
            },
            
            _resultClosed: function(e) {
            	this.opened = false;
            },
            
            /* This method handles an explicit user action for accepting selected values from an autocompleted list.
             * However, there is no guarantee that there are actually selected values. 
             */
            _done: function() {
            	var input = this.$.input;
            	var result = this.$.result;
                var hasValuesToProcess = Object.keys(result.selectedValues).length > 0;
            	// should close automatcially, but just in case let's make sure the result overlay gets closed
            	result.close();
            	
            	// TODO implemente value accpetance logic...
            	if (hasValuesToProcess) {
            	    // compose a string value, which would be a comma separated string in case of multi
                    var selectedValuesAsStr = _.map(result.selectedValues, function (obj) {
                        console.log(obj.key);
                        return obj.key;
                    }).join(this.separator);
            		
            		if(!this.multi) {
                        // if this is a single selection config then need to simply assign the value to the input field
                        input.value = selectedValuesAsStr;
            		} else {
                        // in case of multi selection config things get a little more interesting
                        // as we need to insert the value into the right position of an existing text in the input field
                        var before = input.value.substring(0, this._replaceFromIndex + 1);
                        var after = input.value.substr(this._replaceToIndex);
                        var newEditingValue = before + selectedValuesAsStr + after;

                        // TODO the following is relevant in TG binding context and
                        //      needs to be adjusted when integrating with tg-editor
                        //      For now simply assign the value to the input field
                        input.value = newEditingValue;
                        /*if (!this.$.reflector.equalsEx(newEditingValue, this.editingValue)) {
                        	this.isAcceptingValueFromSuggestions = true;
                            this.editingValue = newEditingValue;
                        } else {
                                // EDGE-CASE: when the editing value has been already populated
                                //   and this value equals to the value that was selected from the list -- 
                                //   changing of 'this.editingValue' will not have any effect.
                                // Such situation happens if the user edits to, for e.g., 'A10184' and then
                                //   choses the entity 'A10184' from the list.
                                // TechNote: in such case, before clicking on OK button, the chain reaction 
                                //   'editingValueChanged->commValueChanged->acceptedValueChanged' has been already
                                //   performed. So there is a need to start validation only ('this.onAcceptedValueChanged()' method).
                        	if (this.isAcceptingValueFromSuggestions) {
                            	this.isAcceptingValueFromSuggestions = false;
                            }
                            this.onAcceptedValueChanged();
                        }*/

                        // let's highlight the inseted values
                        input.selectionStart = this._replaceFromIndex;
                        input.selectionEnd = input.selectionStart + selectedValuesAsStr.length + 1;
            			
            		}
            	}
            	
            	// at the end let's focus the input...
            	this._focusInput();
            },
            
            /* This method is used to make sure the input is in focus */
            _focusInput: function() {
            	// at the end let's focus the input...
            	var input = this.$.input;
            	this.async(function() {
            		input.focus();
            	}, 1);
            },
            
            get parent() {
                if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    return this.parentNode.host;
                }
                return this.parentNode;
            },

            /* Iron reseze event listener for correct resizing and positioning of an open result overlay. */
            _onIronResize: function () {
                var container = this.$.container;
                //console.log('resize event captured:', (container.offsetTop + container.clientHeight));
                var result = this.$.result;
                if (result.opened) {
                    this.async(function () {         
                        var rect = container.getClientRects()[0];
                        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
                        var top = rect.bottom + scrollTop;
                        var left = rect.left;// + scrollLeft;
                        var right = rect.right;
                        var width = rect.width;
                        
                        result.style.position = 'absolute';
                        result.style.top = top + 'px';
                        
                        // let's try to accomodate the width of the overlay so that in case 
                        // the input field is narrow, but there is additional window width available to the
                        // left or right of the input, it would be used.
                        var minWidth = 200;
                        result.style['min-width'] = minWidth + 'px'; // set mid-width, which is important for shifting overlay to the left
                        var visibleWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                        var spaceToRightWindowSide = (visibleWidth - right) + width;                        
                        result.style['max-width'] = spaceToRightWindowSide + 'px';
                        // is there sufficient space to the right?
                        if (spaceToRightWindowSide >= minWidth) {
                        	result.style.left = left + 'px';
                        	// ideally the overlay width should be the same as the intput's
                        	// but, if it gets too narrow the min-widht would fix it
	                    	result.style.width = width + 'px';
                        } else { 
                        	// otherwise, move the overlay to the left side, but not beyond
                        	var resultRect = result.getClientRects()[0];
                        	var adjustment = 5; // minor adjustment to make the overlay fully visible
                        	var newLeft = (visibleWidth - (minWidth + adjustment));
                        	if (newLeft > 0) {
                        		result.style.left = newLeft + 'px'; 
                        	} else {
                        		result.style.left = adjustment + 'px';
                        	}
                        }

                        // let's try also to determine the best height depending on the window height and 
                        // the current vertical location of the element
                        var visibleHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                        result.style['max-height'] = (visibleHeight - top - 10) + 'px'; // 10 pixels is an arbitrary adjustment
                        result.style['min-height'] = '50px'; 
                    });
                }
            }

        });
    })();
</script>