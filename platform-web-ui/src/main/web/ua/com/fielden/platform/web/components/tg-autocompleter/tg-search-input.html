<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/polymer/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="/resources/polymer/iron-input/iron-input.html">
<link rel="import" href="/resources/polymer/iron-icons/iron-icons.html">

<link rel="import" href="/resources/polymer/paper-button/paper-button.html">
<link rel="import" href="/resources/polymer/paper-input/paper-input-container.html">
<link rel="import" href="/resources/polymer/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/resources/polymer/paper-spinner/paper-spinner.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">

<link rel="import" href="/resources/components/tg-autocompleter/tg-search-result.html">

<dom-module id="tg-search-input">

    <style>
        .input-layout {
            @apply(--layout-horizontal);
            @apply(--layout-center);
        }
        
        .search-button {
            align-self: flex-end;
            --iron-icon-height: 16px;
            --iron-icon-width: 16px;
            padding-left: 4px;
            padding-right: 2px;
            padding-top: 2px;
            padding-bottom: 2px;
            height: 20px;
            width: 20px;
            margin: 0px;
        }
        
        paper-spinner {
            width: 16px;
            height: 16px;
            min-width: 16px;
            min-height: 16px;
            max-width: 16px;
            max-height: 16px;
            padding-right: 2px;
            margin: 0px;
            --paper-spinner-layer-1-color: var(--paper-blue-500);
            --paper-spinner-layer-2-color: var(--paper-blue-500);
            --paper-spinner-layer-3-color: var(--paper-blue-500);
            --paper-spinner-layer-4-color: var(--paper-blue-500);
        }
    </style>

    <template>
        <div id="container">
            <paper-input-container id="decorator">
                <label>search</label>
                <div class="input-layout">
                    <input id="input" is="iron-input" type="text" on-input="_inputEventHandler" on-blur="_blurEventHandler"/>
                    <paper-icon-button hidden$="[[searchingOrOpen]]" on-tap="_search" icon="search" class="search-button" tabIndex="-1"></paper-icon-button>
                    <paper-icon-button hidden$="[[searchingOrClosed]]" on-tap="_done" icon="done" class="search-button" tabIndex="-1"></paper-icon-button>
                    <paper-spinner active hidden$="[[!searching]]" tabIndex="-1" alt="searching..."></paper-spinner>
                </div>
            </paper-input-container>
        </div>
        <tg-search-result id="result" on-iron-overlay-opened="_resultOpened" on-iron-overlay-closed="_resultClosed"></tg-search-result>
    </template>

</dom-module>

<script>
    (function () {
        /* several helper functions for string manipulation */
        function escapeRegExp(str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceAll(find, replace, str) {
            // 'g' is the flag for global match,
            // 'i' is the flag to ignore the case during matching
            return str.replace(new RegExp(escapeRegExp(find), 'g', 'i'), replace);
        }

        Polymer({
            is: 'tg-search-input',

            behaviors: [Polymer.IronResizableBehavior],

            listeners: {
                'iron-resize': '_onIronResize'
            },

            ready: function() {
            	this.$.result.highlightDesc = this.highlightDesc;
                if (this.additionalProperties) {
            		this.$.result.additionalProperties = JSON.parse(this.additionalProperties);
                }
            },
            
            attached: function () {
                this.async(this.notifyResize, 1);
            },

            /********************************************************
             ********************************************************
             *********************** PROPERTIES *********************
             ********************************************************
             ********************************************************/
            properties: {
            	/* Indicates whether a search is in progress. This property controls visibility of the progress indecator. */
                searching: {
                    type: Boolean,
                    value: false,
                    notify: false
                },
                
                _searchQuery: {
                    type: Boolean,
                    value: ''
                },
                
                /*
                 * This property should be used as attribute highlight-desc to specify whether search pattern should 
                 * be used for highlighting desc property values in the search result.
                 * This property value gets assigned to the property with the same name of the tg-search-result element
                 * that is associated with this tg-search-input element.
                 */
                highlightDesc:  {
                    type: Boolean,
                    value: false
                },
                
                /*
                 * A sting with comma separated property names that shoould be displayed in addition to key and desc.
                 */
                additionalProperties: {
                	type: String,
                	value: ''
                },
                
                _asyncSearchHandle: {
                	type: Object,
                	value: null
                },
                
                opened: {
                	type: Boolean,
                	value: false
                },
                
                searchingOrOpen: {
                	type: Boolean,
                	computed: '_computeSearchingOrOpened(searching, opened)'
                },
                
                searchingOrClosed: {
                	type: Boolean,
                	computed: '_computeSearchingOrClosed(searching, opened)'
                }
            },

            _computeSearchingOrOpened: function(searching, opened) {
            	return searching === true || opened == true;
            },
            
            _computeSearchingOrClosed: function(searching, opened) {
            	return searching === true || opened == false;
            },
            
            /**
             * Cleans input text.
             */
            _prepInput: function (str) {
                if (str) {
                    return str.replace(/\*\*/g, "*");
                }
                return str;
            },

            _search: function () {
                // TODO need to implement the actuall search
                
                this.$.input.focus();
                
                // what is the query string?
                var inputText = this._prepInput(this.$.input.value);

                // prep this.searchQuery for highlighting of the matching parts in the search result
                if (!inputText) {
                    this._searchQuery = "";
                    this.searching = false;
                } else {
                    this._searchQuery = replaceAll('*', '\\w*', inputText.toUpperCase());
                }

                // collect new matching values
                var self = this;
                var result = self.$.result;
                result.searchQuery = self._searchQuery;
                var container = self.$.container;

                if (this._searchQuery /*&& this.hasFocus === true*/ ) {
                    this.searching = true;

                    // TODO need to convert in the context of TG
                    // prepare the AJAX request based on the raw search string
                    //var serialisedSearchQuery = this.$.serialiser.serialise(this.createContextHolder(inputText));
                    //this.$.ajaxSearcher.body = JSON.stringify(serialisedSearchQuery);
                    //this.$.ajaxSearcher.generateRequest();

                    // TODO Demo only, remove when moving to the TG context

                    self.async((function () {
                        result.close();
                    }).bind(self), 1);

                    this.async((function () {
                        result.clearSelection();
                        self.searching = false;
                        result.values = [{
                            key: 'KEY 1',
                            desc: "some description for key 1",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 2',
                            desc: "some description for key 2",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 3',
                            desc: "some description for key 3 some description for key 3 some description for key 3 some description for key 3",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 4',
                            desc: "some description for key 4",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 5',
                            desc: "some new word for key 5",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }, {
                            key: 'KEY 6',
                            desc: "some description for key 6",
                            prop1: "value of prop 1",
                          	prop2: "value of prop 2"
                        }];
                        self.async(function () {
                            result.style.position = 'absolute';
                            result.style.top = (container.offsetTop + container.clientHeight) + 'px';
                            result.style.width = container.offsetWidth + 'px';
	                       	result.style.height = '250px';
	                       	result.style['min-height'] = '250px';
                            result.open();
                        });

                    }).bind(self), 700); // some delay to mimic the search time

                } else if (result.opened) { // make sure overlay is closed is no search is performed
                    result.close();
                }
            },
            
            _inputEventHandler: function(e) {
            	// clear any search request in already in progress
                this._cancelSearch();
                this._asyncSearchHandle = this.async(this._search.bind(this), 500);            	
            },
            
            _blurEventHandler: function(e) {
            	// There is no need to proceed with search if user moved out of the search field
            	this._cancelSearch();
            	
            	// However, if user typed in a new value it may need to be validated...
            	// TODO implement logic to enforce validation of the typed rather than selected value
            },
            
            _cancelSearch: function() {
            	if (this._asyncSearchHandle) {
            		console.warn("Aboring async search...");
            		this.cancelAsync(this._asyncSearchHandle);
            		this._asyncSearchHandle = null;
            	}
            },
            
            _resultOpened: function(e) {
            	this.opened = true;
            	this.$.result.highlightMatchedParts();
            },
            
            _resultClosed: function(e) {
            	console.log('result got closed.');
            	this.opened = false;
            },
            
            /* This method handles an explicit user action for accepting selected values from an autocompleted list.
             * However, there is no guarantee that there are actually selected values. 
             */
            _done: function() {
            	var result = this.$.result;
            	var hasValuesToProcess = result.selectedValues.length > 0;
            	console.log('accepting result: ', hasValuesToProcess, ' number of selected values: ', result.selectedValues.length);
            	// should close automatcially, but just in case let's make sure the result overlay gets closed
            	result.close();
            	
            	// TODO implemente value accpetance logic...
            	if (hasValuesToProcess) {
            		// do stuff
            		console.log('need to do some work...');
            		if (result.selectedValues.length === 1) {
            			var obj = JSON.parse(result.selectedValues[0]);
            			this.$.input.value = obj.key;
            		} else {
            			
            		}
            	}
            },
            
            get parent() {
                if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    return this.parentNode.host;
                }
                return this.parentNode;
            },

            /* Iron reseze event listener for correct resizing and positioning of an open result overlay. */
            _onIronResize: function () {
                var container = this.$.container;
                //console.log('resize event captured:', (container.offsetTop + container.clientHeight));
                var result = this.$.result;
                if (result.opened) {
                    this.async(function () {
                        var rects = container.getClientRects();
                        var rect = rects[0];
                        result.style.position = 'absolute';
                        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
                        result.style.top = (rect.bottom + scrollTop) + 'px';
                        result.style.left = (rect.left + scrollLeft) + 'px';
                        result.style.width = rect.width + 'px';
                        result.style.height = '250px';
                        result.style['min-height'] = '250px';
                    });
                }
            }

        });
    })();
</script>