<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/tg-reflector">

<polymer-element name="tg-editor" attributes="entity propertyName onAcceptedValueChanged msg msgType propTitle propDesc currentState action externalRefreshCycle">
    <template>
        <tg-reflector id="reflector"></tg-reflector>
        <p>editingValue: {{editingValue}}</p>
        <p>commValue: {{commValue}}</p>
		<p>acceptedValue: {{acceptedValue}}</p>
        <p>entity.get(propertyName): {{_bindingValue(entity, propertyName)}}</p>
    </template>
    <script>
        Polymer('tg-editor', {
            publish: {
                /**
                 * The title for this editor. It normally appears as the caption for the editor.
                 *
                 * @attribute title
                 * @type string
                 * @default 'Unknown title. Please specify the title for the editor.'
                 */
                propTitle: 'Unknown title. Please specify the title for the editor.',

                /**
                 * The description for this editor.
                 *
                 * @attribute desc
                 * @type string
                 * @default 'Unknown desc. Please specify the desc for the editor.'
                 */
                propDesc: 'Unknown desc. Please specify the desc for the editor.',

                /**
                 * This published property specifies to what entity this editor should be bound.
                 */
                entity: null,
                /**
                 * This published property specifies to what property this editor should be bound.
                 */
                propertyName: null,

                /**
                 * This callback should be used for custom action after the 'acceptedValue' has been changed (for e.g. validation).
                 */
                onAcceptedValueChanged: null,

                /**
                 * The message about the state of the editor (most likely validation message).
                 */
                msg: '',

                /**
                 * The message type (ERROR validation or stale conflict, WARNING validation or staleness etc.).
                 */
                msgType: '', // NONE 'ERROR', 'WARNING', 'INFO'

                /**
                 * The state for the editor.
                 *
                 * The editor can be only in two states: EDIT and VIEW. The state EDIT 
                 * allows user to edit property.
                 *
                 * The state VIEW allows user to review the property.
                 * 
                 * The initial state can be VIEW or EDIT.
                 */
                currentState: {
                    value: null,
                    reflect: true
                },

                /**
                 * The action object that represents an action to be embedded as an icon button inside this editor.
                 *
                 * If the action attribute is not specified -- no action button should be displayed.
                 */
                action: null,

                externalRefreshCycle: null
            },

            /**
             * The value being edited (main editing capability). If there are other editing views in this editor -- maintain their editingValues separately.
             *
             * This value is of the data type for editing (main editing capability), most likely String.
             */
            editingValue: '',

            /**
             * The value being committed (main editing capability). If there are other editing views in this editor -- maintain their committedValues separately.
             *
             * This value is of the data type for editing (main editing capability), most likely String.
             */
            commValue: '',

            /**
             * The value being accepted after the editing. The commit can be done using 'TAB off' or 'Enter key pressed'.
             *
             * This value is of the data type for concrete component, for e.g. for tg-datetime-picker it is Number, tg-textfield -- String etc.
             * The type strictly conforms to the type of 'bindTo' attribute.
             */
            acceptedValue: '',

            refreshCycleStarted: false,

            ready: function () {
                this.$.decorator.labelVisible = false;
            },

            /**
             * Returns 'true' if the editor is disabled, 'false' otherwise (based on the editor's state).
             */
            _isDisabled: function(state) {
                if (state === undefined || state === 'VIEW') {
                    return true;
                } else if (state === 'EDIT') {
                    return false;                    
                } else {
                    throw "Unsupported state exception: " + state + ".";
                }
            },

            /** 
             * The function for binding property value. The argument 'entity' will be changed in future. Polymer will listen to that change.
             */
            _bindingValue: function (entity, propertyName) {
                // console.log("_bindingValue entity", entity);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                        console.log("_bindingValue prop value", entity.get(propertyName));
                        // console.log("_title entity type prop", entity.type().prop(propertyName));
                        // console.log("_title entity type prop title", entity.type().prop(propertyName).title());
                        return entity.get(propertyName);
                    } else {
                        return "Not yet initialised currBindingEntity, from which to get binding value!";
                    }
                } else {
                    return "Not yet initialised this.$!";
                }
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * This method is called during editing.
             */
            editingValueChanged: function (oldValue, newValue) {
                console.log("editingValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                this.$.decorator.updateLabelVisibility(this.editingValue);

                if (this.refreshCycleStarted) {
                    this.commit();
                }
            },

            /**
             * This method is called once the entity was changed from the outside of the component.
             */
            entityChanged: function (oldValue, newValue) {
                console.log("entityChanged", oldValue, newValue, "still refreshCycleStarted ==", this.refreshCycleStarted);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(newValue)) {
                        this.editingValue = this.convertToString(newValue.get(this.propertyName));
                    } else {
                        console.log("entityChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    console.log("entityChanged: Not yet initialised this.$!");
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             */
            commValueChanged: function (oldValue, newValue) {
                console.log("commValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);
                this.acceptedValue = this.convertFromString(newValue);
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             */
            acceptedValueChanged: function (oldValue, newValue) {
                console.log("acceptedValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                if (this.refreshCycleStarted) {
                    this.refreshCycleStarted = false;
                } else {
                    this.entity.set(this.propertyName, newValue);
                    this.onAcceptedValueChanged();
                }
            },

            /**
             * Converts the value into string representation (which is used in edititing / comm values). Please implement this method in descendant editor.
             */
            convertToString: function (value) {
                // return "" + value;
                throw "Conversion to string is not specified for this editor.";
            },

            /**
             * Converts the value from string representation (which is used in edititing / comm values) into concrete type of this editor component. Please implement this method in descendant editor.
             */
            convertFromString: function (strValue) {
                // return strValue;
                throw "Conversion from string into entity property type is not specified for this editor.";
            },

            /**
             * Commits editing value.
             */
            commit: function () {
                throw "Commit functionality is not specified for this editor.";
            },

            externalRefreshCycleChanged: function (oldValue, newValue) {
                if (newValue === "ACTIVATED") {
                    console.log("externalRefreshCycleChanged", oldValue, newValue);
                    this.refreshCycleStarted = true;
                }
            }
        });
    </script>
</polymer-element>