<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/tg-reflector">

<polymer-element name="tg-editor" attributes="entity propertyName onAcceptedValueChanged propTitle propDesc currentState action externalRefreshCycle debug">
    <template>
        <style>
            :host::shadow #input {
                width: 100%;
                box-sizing: border-box;
            }
            
            :host::shadow * /deep/ core-tooltip::shadow #tooltip {
                white-space: normal;
            }
            
            :host::shadow * /deep/ core-tooltip .span-tooltip {
                line-height: 15px;
            }
            
            :host::shadow core-tooltip.delayed:hover::shadow .core-tooltip,
            :host::shadow core-tooltip.delayed:focus::shadow .core-tooltip {
                opacity: 1;
                -webkit-transition-delay: 1s;
                transition-delay: 1s;
                transform: translate3d(0px, 0px, 0px);
            }
            
            :host::shadow #input.upper-case {
                text-transform: uppercase;
            }
            /* style requiredness */
            
            :host::shadow paper-input-decorator:not([disabled]).required /deep/ .label-text {
                color: #03A9F4;
            }
            
            :host::shadow paper-input-decorator[focused].required /deep/ .label-text {
                color: #03A9F4;
            }
            
            :host::shadow paper-input-decorator.required /deep/ .focused-underline {
                background-color: #03A9F4;
            }
            
            :host::shadow paper-input-decorator.required /deep/ .unfocused-underline {
                background-color: #03A9F4;
            }
            /* style warning */
            
            :host::shadow paper-input-decorator.warning /deep/ .error,
            :host::shadow paper-input-decorator[focused].warning /deep/ .error {
                color: #FFA000;
            }
            
            :host::shadow paper-input-decorator.invalid[focused].warning /deep/ .floated-label .label-text {
                color: #FFA000;
            }
            
            :host::shadow paper-input-decorator.invalid.warning /deep/ .floated-label .label-text {
                color: #FFA000;
            }
            
            :host::shadow paper-input-decorator.invalid.warning /deep/ .focused-underline {
                background-color: #FFA000;
            }
            
            :host::shadow paper-input-decorator.invalid.warning /deep/ .unfocused-underline {
                background-color: #FFA000;
            }
        </style>
        <tg-reflector id="reflector"></tg-reflector>

        <template if="{{debug}}">
            <p>editingValue: {{editingValue}}</p>
            <p>commValue: {{commValue}}</p>
            <p>acceptedValue: {{acceptedValue}}</p>
            <p>_bindingValue: {{_bindingValue(entity, propertyName)}}</p>
        </template>
    </template>
    <script>
        Polymer('tg-editor', {
            publish: {
                /**
                 * The title for this editor. It normally appears as the caption for the editor.
                 *
                 * @attribute title
                 * @type string
                 * @default 'Unknown title. Please specify the title for the editor.'
                 */
                propTitle: 'Unknown title. Please specify the title for the editor.',

                /**
                 * The description for this editor.
                 *
                 * @attribute desc
                 * @type string
                 * @default 'Unknown desc. Please specify the desc for the editor.'
                 */
                propDesc: 'Unknown desc. Please specify the desc for the editor.',

                /**
                 * This published property specifies to what entity this editor should be bound.
                 */
                entity: null,
                /**
                 * This published property specifies to what property this editor should be bound.
                 */
                propertyName: null,

                /**
                 * This callback should be used for custom action after the 'acceptedValue' has been changed (for e.g. validation).
                 */
                onAcceptedValueChanged: null,

                /**
                 * The message about the state of the editor (most likely validation message).
                 */
                // msg: '',

                /**
                 * The message about the editor-specific validation. If 'null' -- the validation was successfull.
                 */
                editorValidationMsg: '',

                /**
                 * The message type (ERROR validation or stale conflict, WARNING validation or staleness etc.).
                 */
                // msgType: '', // NONE 'ERROR', 'WARNING', 'INFO'

                /**
                 * The state for the editor.
                 *
                 * The editor can be only in two states: EDIT and VIEW. The state EDIT
                 * allows user to edit property.
                 *
                 * The state VIEW allows user to review the property.
                 *
                 * The initial state can be VIEW or EDIT.
                 */
                currentState: {
                    value: 'VIEW', // TODO temporal default value (please make it 'null' later)
                    reflect: true
                },

                /**
                 * The action object that represents an action to be embedded as an icon button inside this editor.
                 *
                 * If the action attribute is not specified -- no action button should be displayed.
                 */
                action: null,

                externalRefreshCycle: null
            },

            /* Controls rendering of debug information for an entity editor. */
            debug: false,
            /**
             * The value being edited (main editing capability). If there are other editing views in this editor -- maintain their editingValues separately.
             *
             * This value is of the data type for editing (main editing capability), most likely String.
             */
            editingValue: '',

            /**
             * The value being committed (main editing capability). If there are other editing views in this editor -- maintain their committedValues separately.
             *
             * This value is of the data type for editing (main editing capability), most likely String.
             */
            commValue: '',

            /**
             * The value being accepted after the editing. The commit can be done using 'TAB off' or 'Enter key pressed'.
             *
             * This value is of the data type for concrete component, for e.g. for tg-datetime-picker it is Number, tg-textfield -- String etc.
             * The type strictly conforms to the type of 'bindTo' attribute.
             */
            acceptedValue: '',

            refreshCycleStarted: false,

            ready: function () {
                var self = this;
                this.$.decorator.labelVisible = false;
            },

            /**
             * Returns 'true' if the editor is disabled, 'false' otherwise (based on the editor's state and 'editable' meta-state for the property).
             */
            _isDisabled: function (state, bindingEntity, propertyName) {
                if (state === undefined || state === 'VIEW') {
                    return true;
                } else if (state === 'EDIT') {
                    return this.$.reflector.isDotNotated(propertyName) ? true : (!(bindingEntity["@" + propertyName + "_editable"]));
                } else {
                    throw "Unsupported state exception: " + state + ".";
                }
            },

            /** 
             * The function for binding property value. The argument 'entity' will be changed in future. Polymer will listen to that change.
             */
            _bindingValue: function (entity, propertyName) {
                // console.log("_bindingValue entity", entity);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                        // console.log("_bindingValue prop value", entity.get(propertyName));
                        return this.getBindingValue(entity, propertyName);
                    } else {
                        return "Not yet initialised currBindingEntity, from which to get binding value!";
                    }
                } else {
                    return "Not yet initialised this.$!";
                }
            },

            /**
             * Returns the binding value for the specified 'bindingEntity' and 'dotNotatedName' of the property.
             *
             * This supports the retrieval of binding value for dot-notation properties with the use of bindingEntity's '@@origin'.
             */
            getBindingValue: function(bindingEntity, dotNotatedName) {
            	return this.$.reflector.isDotNotated(dotNotatedName) ? this.$.reflector.convert(this.getValueFor(bindingEntity, dotNotatedName)) : bindingEntity.get(dotNotatedName);
            },
            
            /**
             * Returns the full value for the specified 'bindingEntity' and 'dotNotatedName' of the property.
             *
             * This method does no conversion of the value to 'binding' representation.
             */
            getValueFor: function(bindingEntity, dotNotatedName) {
            	return bindingEntity["@@origin"].get(dotNotatedName);
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * This method is called during editing.
             *
             * IMPORTANT: please do override this method if needed, but only with this.super([oldValue, newValue]); invoked!
             */
            editingValueChanged: function (oldValue, newValue) {
                // console.log("editingValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                this.$.decorator.updateLabelVisibility(this.editingValue);

                if (this.refreshCycleStarted) {
                    this.commit();
                }
            },

            /**
             * This method is called once the entity was changed from the outside of the component.
             *
             * IMPORTANT: please do override this method if needed, but only with this.super([oldValue, newValue]); invoked!
             */
            entityChanged: function (oldValue, newValue) {
                // console.log("entityChanged", oldValue, newValue, "still refreshCycleStarted ==", this.refreshCycleStarted);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(newValue)) {
                    	var propValue = this.getBindingValue(newValue, this.propertyName);
                        var newEditingValue = this.convertToString(propValue);
                        if (newEditingValue === this.editingValue && this.refreshCycleStarted) {
                            this.refreshCycleStarted = false;
                        }
                        this.editingValue = newEditingValue;

                        this.bindMessages(newValue, this.propertyName, this.editorValidationMsg);
                    } else {
                        // console.log("entityChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    // console.log("entityChanged: Not yet initialised this.$!");
                }
            },

            editorValidationMsgChanged: function (oldValue, newValue) {
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(this.entity)) {
                        this.bindMessages(this.entity, this.propertyName, newValue);
                    } else {
                        console.log("editorValidationMsgChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    console.log("editorValidationMsgChanged: Not yet initialised this.$!");
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             *
             * IMPORTANT: please do not override this method.
             */
            commValueChanged: function (oldValue, newValue) {
                // console.log("commValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);
                try {
                    this.acceptedValue = this.convertFromString(newValue);
                    this.editorValidationMsg = '';
                } catch (error) {
                    // console.log("commValueChanged catched", error, this);
                    this.editorValidationMsg = error;
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             *
             * IMPORTANT: please do not override this method. This method have some additional customisation points:
             * shouldInvokeValidation() and skipValidationAction().
             */
            acceptedValueChanged: function (oldValue, newValue) {
                // console.log("acceptedValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                if (this.refreshCycleStarted) {
                    this.refreshCycleStarted = false;
                    // console.log("acceptedValueChanged should become false. refreshCycleStarted ==", this.refreshCycleStarted);
                } else {
                    this.entity.set(this.propertyName, newValue);
                    if (this.shouldInvokeValidation()) {
                        this.onAcceptedValueChanged();
                    } else {
                        this.skipValidationAction();
                    }
                }
            },

            /**
             * Please override this method in case when no validation should occur after acceptedValueChanged.
             */
            shouldInvokeValidation: function () {
                return true;
            },

            /**
             * Please override this method in case when some custom action is needed when shouldInvokeValidation() returns 'false' after acceptedValueChanged.
             */
            skipValidationAction: function () {},

            /**
             * Converts the value into string representation (which is used in editing / comm values). Please implement this method in descendant editor.
             */
            convertToString: function (value) {
                // return "" + value;
                throw "Conversion to string is not specified for this editor.";
            },

            /**
             * Converts the value from string representation (which is used in editing / comm values) into concrete type of this editor component. Please implement this method in descendant editor.
             */
            convertFromString: function (strValue) {
                // return strValue;
                throw "Conversion from string into entity property type is not specified for this editor.";
            },

            /**
             * Commits editing value.
             */
            commit: function () {
                // console.log("commit");
                this.commValue = this.editingValue;
            },

            externalRefreshCycleChanged: function (oldValue, newValue) {
                if (newValue === "ACTIVATED") {
                    // console.log("externalRefreshCycleChanged", oldValue, newValue);
                    this.refreshCycleStarted = true;
                }
            },

            bindMessages: function (entity, property, editorValidationMsg) {
                if (editorValidationMsg) {
                    this.bindError(editorValidationMsg);
                } else if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                    	// please, note that dot-notated property will not have any errors / warnings / requiredness
                    	//     - for these props it does not make sense to propagate such meta-information from
                    	//     parent property -- the parent prop (if added in master) will show that errors concisely
                        if (typeof entity["@" + property + "_error"] !== 'undefined') {
                            this.bindError(entity["@" + property + "_error"].message);
                        } else if (typeof entity["@" + property + "_warning"] !== 'undefined') {
                            this.bindWarning(entity["@" + property + "_warning"].message);
                        } else if (typeof entity["@" + property + "_required"] !== 'undefined') {
                            this.bindRequired(entity["@" + property + "_required"]);
                        } else {
                            this.resetMessages();
                        }

                        this.bindUppercase(entity, property);

                    } else {
                        this.resetMessages();
                        this.resetMetaPropDecorations();
                    }
                } else {
                    this.resetMessages();
                    this.resetMetaPropDecorations();
                }
            },

            bindUppercase: function (entity, property) {
                if (typeof entity["@" + property + "_uppercase"] !== 'undefined') {
                    this.$.input.classList.add("upper-case");
                } else {
                    this.$.input.classList.remove("upper-case");
                }
            },

            resetMetaPropDecorations: function () {
                this.$.decorator.classList.remove("required");
            },

            resetMessages: function () {
                this.$.decorator.isInvalid = false;
                this.$.decorator.error = "";
                this.$.decorator.classList.remove("warning");
            },

            bindError: function (msg) {
                this.resetMessages();
                this.$.decorator.classList.remove("required");
                this.$.decorator.classList.remove("warning");
                this.$.decorator.isInvalid = true;
                this.$.decorator.error = msg;
            },

            bindWarning: function (msg) {
                this.resetMessages();
                this.$.decorator.classList.remove("required");
                this.$.decorator.classList.add("warning");
                this.$.decorator.isInvalid = true;
                this.$.decorator.error = "" + msg;
            },

            bindRequired: function (required) {
                this.resetMessages();
                if (required) {
                    this.$.decorator.classList.add("required");
                } else {
                    this.$.decorator.classList.remove("required");
                }
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * Binding function for tooltips.
             */
            tooltip: function (propDesc) {
                return propDesc;
            },
            
            createContextHolder: function(inputText) {
            	var reflector = this.$.reflector;
                var centreContextHolder = reflector.newEntity("ua.com.fielden.platform.entity.functional.centre.CentreContextHolder");
                centreContextHolder.id = null;
                var paramsHolder = this.createModifiedPropertiesHolder();
                paramsHolder["@@searchString"] = inputText;
                centreContextHolder["modifHolder"] = paramsHolder;
                if (this.requireSelectedEntities !== null) {
                	reflector.provideSelectedEntities(this.requireSelectedEntities, centreContextHolder, this.getSelectedEntities);
                }
                if (this.requireMasterEntity !== null) {
                	reflector.provideMasterEntity(this.requireMasterEntity, centreContextHolder, this.getMasterEntity);
                }
                return centreContextHolder;
            }
        });
    </script>
</polymer-element>