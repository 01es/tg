<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/tg-reflector">

<dom-module id="tg-editor">
    <style>
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	/* TODO please, migrate the styles to new version: */
    	
        :host::shadow #input {
            width: 100%;
            box-sizing: border-box;
        }
        
        :host::shadow * /deep/ core-tooltip::shadow #tooltip {
            white-space: normal;
        }
        
        :host::shadow * /deep/ core-tooltip .span-tooltip {
            line-height: 15px;
        }
        
        :host::shadow core-tooltip.delayed:hover::shadow .core-tooltip,
        :host::shadow core-tooltip.delayed:focus::shadow .core-tooltip {
            opacity: 1;
            -webkit-transition-delay: 1s;
            transition-delay: 1s;
            transform: translate3d(0px, 0px, 0px);
        }
        
        :host::shadow #input.upper-case {
            text-transform: uppercase;
        }
        /* style requiredness */
        
        :host::shadow paper-input-decorator:not([disabled]).required /deep/ .label-text {
            color: #03A9F4;
        }
        
        :host::shadow paper-input-decorator[focused].required /deep/ .label-text {
            color: #03A9F4;
        }
        
        :host::shadow paper-input-decorator.required /deep/ .focused-underline {
            background-color: #03A9F4;
        }
        
        :host::shadow paper-input-decorator.required /deep/ .unfocused-underline {
            background-color: #03A9F4;
        }
        /* style warning */
        
        :host::shadow paper-input-decorator.warning /deep/ .error,
        :host::shadow paper-input-decorator[focused].warning /deep/ .error {
            color: #FFA000;
        }
        
        :host::shadow paper-input-decorator.invalid[focused].warning /deep/ .floated-label .label-text {
            color: #FFA000;
        }
        
        :host::shadow paper-input-decorator.invalid.warning /deep/ .floated-label .label-text {
            color: #FFA000;
        }
        
        :host::shadow paper-input-decorator.invalid.warning /deep/ .focused-underline {
            background-color: #FFA000;
        }
        
        :host::shadow paper-input-decorator.invalid.warning /deep/ .unfocused-underline {
            background-color: #FFA000;
        }
    </style>
    <template>
        <tg-reflector id="reflector"></tg-reflector>

        <template if="{{debug}}">
            <p>editingValue: {{editingValue}}</p>
            <p>commValue: {{commValue}}</p>
            <p>acceptedValue: {{acceptedValue}}</p>
            <p>_bindingValue: {{_bindingValue(entity, propertyName)}}</p>
        </template>
    </template>
</dom-module>

    <script>
        Polymer({
        	
        	is: 'tg-editor',
        	
        	// TODO PUBLIC API: attributes="entity propertyName onAcceptedValueChanged propTitle propDesc currentState action externalRefreshCycle debug"
        	
            properties: {
                /**
                 * The title for this editor. It normally appears as the caption for the editor.
                 */
                propTitle: {
                	type: String,
                	value: 'Unknown title. Please specify the title for the editor.' // TODO please remove default value, as it is necessary to specify such property from the outside
                },

                /**
                 * The description for this editor.
                 */
                propDesc: {
                	type: String,
                	value: 'Unknown desc. Please specify the desc for the editor.' // TODO please remove default value, as it is necessary to specify such property from the outside
                },

                /**
                 * This published property specifies to what binding entity this editor should be bound.
                 */
                entity: {
                	type: Object,
                	value: function() { return null; }, // TODO please remove default value, as it is necessary to specify such property from the outside
                	observer: 'entityChanged'
                },
                
                /**
                 * This published property specifies to what property this editor should be bound.
                 */
                propertyName: {
                	type: String,
                	value: null // TODO please remove default value, as it is necessary to specify such property from the outside
                },

                /**
                 * This callback should be used for custom action after the 'acceptedValue' has been changed (for e.g. validation).
                 */
                onAcceptedValueChanged: {
                	type: Object,
                	value: function() { return null; } // TODO please remove default value, as it is necessary to specify such property from the outside
                },

                /**
                 * The message about the editor-specific validation. If 'null' -- the validation was successfull.
                 */
                editorValidationMsg: {
                	type: String,
                	value: '',
                	observer: 'editorValidationMsgChanged'
                },

                /**
                 * The state for the editor.
                 *
                 * The editor can be only in two states: EDIT and VIEW. The state EDIT
                 * allows user to edit property.
                 *
                 * The state VIEW allows user to review the property.
                 *
                 * The initial state can be VIEW or EDIT.
                 */
                currentState: {
                	type: String,
                    reflectToAttribute: true, // TODO why is this needed???
                    value: 'VIEW' // TODO temporal default value (please make it 'null' later)
                },

                /**
                 * The action object that represents an action to be embedded as an icon button inside this editor.
                 *
                 * If the action attribute is not specified -- no action button should be displayed.
                 */
                action: {
                	type: Object,
                	value: function() { return null; } // TODO please remove default value, as it is necessary to specify such property from the outside
                },

                /**
                 * The switch, that turns on refresh cycle.
                 */
                externalRefreshCycle: {
                	type: String,
                	value: null
                },
                
                /**
                 * Controls rendering of debug information for an entity editor. 
                 */
                debug: {
                	type: Boolean,
                	value: false
                },
                
                /**
                 * The value being edited (main editing capability). If there are other editing views in this editor -- maintain their editingValues separately.
                 *
                 * This value is of the data type for editing (main editing capability), most likely String.
                 */
                editingValue: {
                	type: String,
                	value: '',
                	observer: 'editingValueChanged'
                },

                /**
                 * The value being committed (main editing capability). If there are other editing views in this editor -- maintain their committedValues separately.
                 *
                 * This value is of the data type for editing (main editing capability), most likely String.
                 */
                commValue: {
                	type: String,
                	value: '',
                	observer: 'commValueChanged'
                },

                /**
                 * The value being accepted after the editing. The commit can be done using 'TAB off' or 'Enter key pressed'.
                 *
                 * This value is of the data type for concrete component, for e.g. for tg-datetime-picker it is Number, tg-textfield -- String etc.
                 * The type strictly conforms to the type of 'bindTo' attribute.
                 */
                acceptedValue: {
                	type: String,
                	value: '',
                	observer: 'acceptedValueChanged'
                },

                refreshCycleStarted: {
                	type: Boolean,
                	value: false
                }
            },

            ready: function () {
                var self = this;
                this.$.decorator.labelVisible = false;
            },

            /**
             * Returns 'true' if the editor is disabled, 'false' otherwise (based on the editor's state and 'editable' meta-state for the property).
             */
            _isDisabled: function (state, bindingEntity, propertyName) {
                if (state === undefined || state === 'VIEW') {
                    return true;
                } else if (state === 'EDIT') {
                    return this.$.reflector.isDotNotated(propertyName) ? true : (!(bindingEntity["@" + propertyName + "_editable"]));
                } else {
                    throw "Unsupported state exception: " + state + ".";
                }
            },

            /** 
             * The function for binding property value. The argument 'entity' will be changed in future. Polymer will listen to that change.
             */
            _bindingValue: function (entity, propertyName) {
                // console.log("_bindingValue entity", entity);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                        // console.log("_bindingValue prop value", entity.get(propertyName));
                        return this.getBindingValue(entity, propertyName);
                    } else {
                        return "Not yet initialised currBindingEntity, from which to get binding value!";
                    }
                } else {
                    return "Not yet initialised this.$!";
                }
            },

            /**
             * Returns the binding value for the specified 'bindingEntity' and 'dotNotatedName' of the property.
             *
             * This supports the retrieval of binding value for dot-notation properties with the use of bindingEntity's '@@origin'.
             */
            getBindingValue: function(bindingEntity, dotNotatedName) {
            	return this.$.reflector.isDotNotated(dotNotatedName) ? this.$.reflector.convert(this.getValueFor(bindingEntity, dotNotatedName)) : bindingEntity.get(dotNotatedName);
            },
            
            /**
             * Returns the full value for the specified 'bindingEntity' and 'dotNotatedName' of the property.
             *
             * This method does no conversion of the value to 'binding' representation.
             */
            getValueFor: function(bindingEntity, dotNotatedName) {
            	return bindingEntity["@@origin"].get(dotNotatedName);
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * This method is called during editing.
             *
             * IMPORTANT: please do override this method if needed, but only with this.super([oldValue, newValue]); invoked!
             */
            editingValueChanged: function (newValue, oldValue) {
                // console.log("editingValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                this.$.decorator.updateLabelVisibility(this.editingValue);

                if (this.refreshCycleStarted) {
                    this.commit();
                }
            },

            /**
             * This method is called once the entity was changed from the outside of the component.
             *
             * IMPORTANT: please do override this method if needed, but only with this.super([oldValue, newValue]); invoked!
             */
            entityChanged: function (newValue, oldValue) {
                // console.log("entityChanged", oldValue, newValue, "still refreshCycleStarted ==", this.refreshCycleStarted);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(newValue)) {
                    	var propValue = this.getBindingValue(newValue, this.propertyName);
                        var newEditingValue = this.convertToString(propValue);
                        if (newEditingValue === this.editingValue && this.refreshCycleStarted) {
                            this.refreshCycleStarted = false;
                        }
                        this.editingValue = newEditingValue;

                        this.bindMessages(newValue, this.propertyName, this.editorValidationMsg);
                    } else {
                        // console.log("entityChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    // console.log("entityChanged: Not yet initialised this.$!");
                }
            },

            editorValidationMsgChanged: function (newValue, oldValue) {
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(this.entity)) {
                        this.bindMessages(this.entity, this.propertyName, newValue);
                    } else {
                        console.log("editorValidationMsgChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    console.log("editorValidationMsgChanged: Not yet initialised this.$!");
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             *
             * IMPORTANT: please do not override this method.
             */
            commValueChanged: function (newValue, oldValue) {
                // console.log("commValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);
                try {
                    this.acceptedValue = this.convertFromString(newValue);
                    this.editorValidationMsg = '';
                } catch (error) {
                    // console.log("commValueChanged catched", error, this);
                    this.editorValidationMsg = error;
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             *
             * IMPORTANT: please do not override this method. This method have some additional customisation points:
             * shouldInvokeValidation() and skipValidationAction().
             */
            acceptedValueChanged: function (newValue, oldValue) {
                // console.log("acceptedValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                if (this.refreshCycleStarted) {
                    this.refreshCycleStarted = false;
                    // console.log("acceptedValueChanged should become false. refreshCycleStarted ==", this.refreshCycleStarted);
                } else {
                    this.entity.set(this.propertyName, newValue);
                    if (this.shouldInvokeValidation()) {
                        this.onAcceptedValueChanged();
                    } else {
                        this.skipValidationAction();
                    }
                }
            },

            /**
             * Please override this method in case when no validation should occur after acceptedValueChanged.
             */
            shouldInvokeValidation: function () {
                return true;
            },

            /**
             * Please override this method in case when some custom action is needed when shouldInvokeValidation() returns 'false' after acceptedValueChanged.
             */
            skipValidationAction: function () {},

            /**
             * Converts the value into string representation (which is used in editing / comm values). Please implement this method in descendant editor.
             */
            convertToString: function (value) {
                // return "" + value;
                throw "Conversion to string is not specified for this editor.";
            },

            /**
             * Converts the value from string representation (which is used in editing / comm values) into concrete type of this editor component. Please implement this method in descendant editor.
             */
            convertFromString: function (strValue) {
                // return strValue;
                throw "Conversion from string into entity property type is not specified for this editor.";
            },

            /**
             * Commits editing value.
             */
            commit: function () {
                // console.log("commit");
                this.commValue = this.editingValue;
            },

            externalRefreshCycleChanged: function (oldValue, newValue) {
                if (newValue === "ACTIVATED") {
                    // console.log("externalRefreshCycleChanged", oldValue, newValue);
                    this.refreshCycleStarted = true;
                }
            },

            bindMessages: function (entity, property, editorValidationMsg) {
                if (editorValidationMsg) {
                    this.bindError(editorValidationMsg);
                } else if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                    	// please, note that dot-notated property will not have any errors / warnings / requiredness
                    	//     - for these props it does not make sense to propagate such meta-information from
                    	//     parent property -- the parent prop (if added in master) will show that errors concisely
                        if (typeof entity["@" + property + "_error"] !== 'undefined') {
                            this.bindError(entity["@" + property + "_error"].message);
                        } else if (typeof entity["@" + property + "_warning"] !== 'undefined') {
                            this.bindWarning(entity["@" + property + "_warning"].message);
                        } else if (typeof entity["@" + property + "_required"] !== 'undefined') {
                            this.bindRequired(entity["@" + property + "_required"]);
                        } else {
                            this.resetMessages();
                        }

                        this.bindUppercase(entity, property);

                    } else {
                        this.resetMessages();
                        this.resetMetaPropDecorations();
                    }
                } else {
                    this.resetMessages();
                    this.resetMetaPropDecorations();
                }
            },

            bindUppercase: function (entity, property) {
                if (typeof entity["@" + property + "_uppercase"] !== 'undefined') {
                    this.$.input.classList.add("upper-case");
                } else {
                    this.$.input.classList.remove("upper-case");
                }
            },

            resetMetaPropDecorations: function () {
                this.$.decorator.classList.remove("required");
            },

            resetMessages: function () {
                this.$.decorator.isInvalid = false;
                this.$.decorator.error = "";
                this.$.decorator.classList.remove("warning");
            },

            bindError: function (msg) {
                this.resetMessages();
                this.$.decorator.classList.remove("required");
                this.$.decorator.classList.remove("warning");
                this.$.decorator.isInvalid = true;
                this.$.decorator.error = msg;
            },

            bindWarning: function (msg) {
                this.resetMessages();
                this.$.decorator.classList.remove("required");
                this.$.decorator.classList.add("warning");
                this.$.decorator.isInvalid = true;
                this.$.decorator.error = "" + msg;
            },

            bindRequired: function (required) {
                this.resetMessages();
                if (required) {
                    this.$.decorator.classList.add("required");
                } else {
                    this.$.decorator.classList.remove("required");
                }
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * Binding function for tooltips.
             */
            tooltip: function (propDesc) {
                return propDesc;
            },
            
            /**
             * Create context holder with custom '@@searchString' property ('tg-entity-editor' and 'tg-entity-search-criteria' only).
             */
            createContextHolder: function(inputText) {
                var contextHolder = this.$.reflector.createContextHolder(
					this.requireSelectionCriteria, this.requireSelectedEntities, this.requireMasterEntity,
					this.createModifiedPropertiesHolder, this.getSelectedEntities, this.getMasterEntity
                );
                this.$.reflector.setCustomProperty(contextHolder, "@@searchString", inputText);
                return contextHolder;
            }
        });
    </script>