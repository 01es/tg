<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/tg-reflector">

<polymer-element name="tg-editor" attributes="entity propertyName onAcceptedValueChanged propTitle propDesc currentState action externalRefreshCycle">
    <template>
        <style>
            :host::shadow #input {
                width: 100%;
                box-sizing: border-box;
            }
            
            :host::shadow * /deep/ core-tooltip::shadow #tooltip {
                white-space: normal;
            }
            
            :host::shadow * /deep/ core-tooltip .span-tooltip {
                line-height: 15px;
            }
            
            :host::shadow core-tooltip.delayed:hover::shadow .core-tooltip,
            :host::shadow core-tooltip.delayed:focus::shadow .core-tooltip {
                opacity: 1;
                -webkit-transition-delay: 1s;
                transition-delay: 1s;
                transform: translate3d(0px, 0px, 0px);
            }
            
            :host::shadow #input.upper-case {
                text-transform: uppercase;
            }
        </style>
        <tg-reflector id="reflector"></tg-reflector>
        <p>editingValue: {{editingValue}}</p>
        <p>commValue: {{commValue}}</p>
        <p>acceptedValue: {{acceptedValue}}</p>
        <p>_bindingValue(currBindingEntity, propertyName): {{_bindingValue(entity, propertyName)}}</p>
    </template>
    <script>
        Polymer('tg-editor', {
            publish: {
                /**
                 * The title for this editor. It normally appears as the caption for the editor.
                 *
                 * @attribute title
                 * @type string
                 * @default 'Unknown title. Please specify the title for the editor.'
                 */
                propTitle: 'Unknown title. Please specify the title for the editor.',

                /**
                 * The description for this editor.
                 *
                 * @attribute desc
                 * @type string
                 * @default 'Unknown desc. Please specify the desc for the editor.'
                 */
                propDesc: 'Unknown desc. Please specify the desc for the editor.',

                /**
                 * This published property specifies to what entity this editor should be bound.
                 */
                entity: null,
                /**
                 * This published property specifies to what property this editor should be bound.
                 */
                propertyName: null,

                /**
                 * This callback should be used for custom action after the 'acceptedValue' has been changed (for e.g. validation).
                 */
                onAcceptedValueChanged: null,

                /**
                 * The message about the state of the editor (most likely validation message).
                 */
                // msg: '',

                /**
                 * The message about the editor-specific validation. If 'null' -- the validation was successfull.
                 */
                editorValidationMsg: '',

                /**
                 * The message type (ERROR validation or stale conflict, WARNING validation or staleness etc.).
                 */
                // msgType: '', // NONE 'ERROR', 'WARNING', 'INFO'

                /**
                 * The state for the editor.
                 *
                 * The editor can be only in two states: EDIT and VIEW. The state EDIT
                 * allows user to edit property.
                 *
                 * The state VIEW allows user to review the property.
                 *
                 * The initial state can be VIEW or EDIT.
                 */
                currentState: {
                    value: null,
                    reflect: true
                },

                /**
                 * The action object that represents an action to be embedded as an icon button inside this editor.
                 *
                 * If the action attribute is not specified -- no action button should be displayed.
                 */
                action: null,

                externalRefreshCycle: null
            },

            /**
             * The value being edited (main editing capability). If there are other editing views in this editor -- maintain their editingValues separately.
             *
             * This value is of the data type for editing (main editing capability), most likely String.
             */
            editingValue: '',

            /**
             * The value being committed (main editing capability). If there are other editing views in this editor -- maintain their committedValues separately.
             *
             * This value is of the data type for editing (main editing capability), most likely String.
             */
            commValue: '',

            /**
             * The value being accepted after the editing. The commit can be done using 'TAB off' or 'Enter key pressed'.
             *
             * This value is of the data type for concrete component, for e.g. for tg-datetime-picker it is Number, tg-textfield -- String etc.
             * The type strictly conforms to the type of 'bindTo' attribute.
             */
            acceptedValue: '',

            refreshCycleStarted: false,

            ready: function () {
                var self = this;
                this.$.decorator.labelVisible = false;
            },

            /**
             * Returns 'true' if the editor is disabled, 'false' otherwise (based on the editor's state).
             */
            _isDisabled: function (state) {
                if (state === undefined || state === 'VIEW') {
                    return true;
                } else if (state === 'EDIT') {
                    return false;
                } else {
                    throw "Unsupported state exception: " + state + ".";
                }
            },

            /** 
             * The function for binding property value. The argument 'entity' will be changed in future. Polymer will listen to that change.
             */
            _bindingValue: function (entity, propertyName) {
                // console.log("_bindingValue entity", entity);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                        // console.log("_bindingValue prop value", entity.get(propertyName));
                        return entity.get(propertyName);
                    } else {
                        return "Not yet initialised currBindingEntity, from which to get binding value!";
                    }
                } else {
                    return "Not yet initialised this.$!";
                }
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * This method is called during editing.
             */
            editingValueChanged: function (oldValue, newValue) {
                console.log("editingValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                this.$.decorator.updateLabelVisibility(this.editingValue);

                if (this.refreshCycleStarted) {
                    this.commit();
                }
            },

            /**
             * This method is called once the entity was changed from the outside of the component.
             */
            entityChanged: function (oldValue, newValue) {
                // console.log("entityChanged", oldValue, newValue, "still refreshCycleStarted ==", this.refreshCycleStarted);
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(newValue)) {
                        var newEditingValue = this.convertToString(newValue.get(this.propertyName));
                        if (newEditingValue === this.editingValue && this.refreshCycleStarted) {
                            this.refreshCycleStarted = false;
                        }
                        this.editingValue = newEditingValue;

                        this.bindMessages(newValue, this.propertyName, this.editorValidationMsg);
                    } else {
                        console.log("entityChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    console.log("entityChanged: Not yet initialised this.$!");
                }
            },

            editorValidationMsgChanged: function(oldValue, newValue) {
                if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(this.entity)) {
                        this.bindMessages(this.entity, this.propertyName, newValue);
                    } else {
                        console.log("editorValidationMsgChanged: Not yet initialised currBindingEntity, from which to get binding value!");
                    }
                } else {
                    console.log("editorValidationMsgChanged: Not yet initialised this.$!");
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             */
            commValueChanged: function (oldValue, newValue) {
                console.log("commValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);
                try {
                    this.acceptedValue = this.convertFromString(newValue);
                    this.editorValidationMsg = '';
                } catch (error) {
                    console.log("commValueChanged catched", error, this);
                    this.editorValidationMsg = error;
                }
            },

            /**
             * This method is called once the the accepted value was changed after the editor has commited its value.
             */
            acceptedValueChanged: function (oldValue, newValue) {
                console.log("acceptedValueChanged", oldValue, newValue, "refreshCycleStarted ==", this.refreshCycleStarted);

                if (this.refreshCycleStarted) {
                    this.refreshCycleStarted = false;
                    console.log("acceptedValueChanged should become false. refreshCycleStarted ==", this.refreshCycleStarted);
                } else {
                    this.entity.set(this.propertyName, newValue);
                    this.onAcceptedValueChanged();
                }
            },

            /**
             * Converts the value into string representation (which is used in editing / comm values). Please implement this method in descendant editor.
             */
            convertToString: function (value) {
                // return "" + value;
                throw "Conversion to string is not specified for this editor.";
            },

            /**
             * Converts the value from string representation (which is used in editing / comm values) into concrete type of this editor component. Please implement this method in descendant editor.
             */
            convertFromString: function (strValue) {
                // return strValue;
                throw "Conversion from string into entity property type is not specified for this editor.";
            },

            /**
             * Commits editing value.
             */
            commit: function () {
                console.log("commit");
                // this.$.input.commit();
                this.commValue = this.editingValue;
            },

            externalRefreshCycleChanged: function (oldValue, newValue) {
                if (newValue === "ACTIVATED") {
                    console.log("externalRefreshCycleChanged", oldValue, newValue);
                    this.refreshCycleStarted = true;
                }
            },

            bindMessages: function (entity, property, editorValidationMsg) {
                if (editorValidationMsg) {
                    this.bindError(editorValidationMsg);
                } else if (typeof this.$ !== 'undefined') {
                    if (this._isEntity(entity)) {
                        if (typeof entity["@" + property + "_error"] !== 'undefined') {
                            this.bindError(entity["@" + property + "_error"].message);
                        } else if (typeof entity["@" + property + "_warning"] !== 'undefined') {
                            this.bindWarning(entity["@" + property + "_warning"].message);
                        } else if (typeof entity["@" + property + "_required"] !== 'undefined') {
                            this.bindRequired();
                        } else {
                            this.resetMessages();
                        }
                    } else {
                        this.resetMessages();
                    }
                } else {
                    this.resetMessages();
                }
            },

            resetMessages: function () {
                this.$.decorator.classList.remove("required");
                this.$.decorator.isInvalid = false;
                this.$.decorator.error = "";
            },

            bindError: function (msg) {
                this.resetMessages();
                this.$.decorator.isInvalid = true;
                this.$.decorator.error = msg;
            },

            bindWarning: function (msg) {
                this.resetMessages();
                this.$.decorator.isInvalid = true;
                this.$.decorator.error = "WARNING :) " + msg;
            },

            bindRequired: function () {
                console.log("          !!!! BIND REQUIRED !!!!");
                this.resetMessages();
                this.$.decorator.classList.add("required");
            },

            /**
             * Determines whether the specified object represents the entity.
             */
            _isEntity: function (obj) {
                return obj !== null && (obj instanceof this.$.reflector.getEntityType());
            },

            /**
             * Binding function for tooltips.
             */
            tooltip: function (propDesc) {
                return propDesc;
            }
        });
    </script>
</polymer-element>