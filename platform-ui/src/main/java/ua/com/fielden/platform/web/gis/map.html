<!DOCTYPE html>
<html>
	<head>
		<title>Simple Leaflet Map</title>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css"/>
		<link rel="stylesheet" href="http://leaflet.github.io/Leaflet.draw/leaflet.draw.css"/>
		<link rel="stylesheet" href="MarkerCluster.css" />
		<link rel="stylesheet" href="MarkerCluster.Default.css" />
		<link rel="stylesheet" href="screen.css" />
        <link rel="stylesheet" href="Control.Loading.css" />
        <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

		<style>
			body {
				padding: 0;
				margin: 0;
			}
			html, body, #map {
				height: 100%;
				width: 100%;
			}

			/*
			 * Unlike other icons, you can style `L.divIcon` with CSS.
 			 * These styles make each marker a circle with a border and centered text.
 			*/
			.count-icon {
  				background:#ff8888;
  				border:5px solid rgba(255,255,255,0.5);
  				color:#fff;
  				font-weight:bold;
				text-align:center;
  				border-radius:50%;
  				line-height:30px;
  			}


  			.img-overlay img {
 				margin: 0;
				opacity: 1.0;
  				display: block;
			}
			.overlay {
  				position: absolute;
  				top: 0;
  				bottom: 0;
				right: 0;
  				left: 0;
  				width: 100%;
  				/* height: 100%; */

				height: 24px;
  				line-height: 24px;


  				background-color: transparent;
  				color: black;
  				font-weight: bold;
				text-align: center;
				vertical-align: middle;
				/* margin-bottom: 0px; */
				font-size: 12px; 
			}
			.img-overlay {
			    position: relative;
    			/*border: 1px #000 solid;*/
    			float: left;
    		}

			.gps-marker-cluster {
				background-color: transparent;
			}
		</style>
	</head>
	<body>
		<div id="progress"><div id="progress-bar"></div></div>
		<div id="map"></div>
 		<!-- Leaflet stuff -->
		<script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script>
		<script src="http://leaflet.github.io/Leaflet.draw/leaflet.draw.js"></script>

		<!-- Map providers: Google -->
		<script src="http://maps.google.com/maps/api/js?v=3.2&sensor=false"></script>
		<script src="Google.js"></script>
		<!-- Map providers: Yandex -->
		<script src="http://api-maps.yandex.ru/2.0/?load=package.map&lang=ru-RU"></script>		
		<script src="Yandex.js"></script>
		<script src="leaflet.markercluster-src.js"></script>

        <!-- Include the loading control -->
        <script src="easy-button.js"></script>

        <script src="Control.Loading.js"></script>

        <script src="Marker.Rotate.js"></script>


		<script src="geo0.json"></script>
		<!-- script src="geo.json"></script -->
		<!-- script src="Bing.js"></script -->
		<script> 
			var progress = document.getElementById('progress');
			var progressBar = document.getElementById('progress-bar');

			// var iteration = 1;

			function updateProgressBar(processed, total, elapsed, layersArray) {
				console.log("updateProgressBar(processed = " + processed + ", total = " + total + ", elapsed = " + elapsed + ",layersArray);");

				if (elapsed > 0) { // 1000
					// if it takes more than a second to load, display the progress bar:
					progress.style.display = 'block';
					progressBar.style.width = Math.round(processed/total*100) + '%';

					// if (elapsed > 500) {
					// 	map.fitBounds(markersClusterGroup.getBounds());												
					// }

					// if (elapsed > 1500 * iteration) {
					// 	map.fitBounds(markersClusterGroup.getBounds());						
					// 	iteration = iteration + 1;
					// }
				}

				if (processed && (processed === total)) {
					// all markers processed - hide the progress bar:
					progress.style.display = 'none';

					map.fitBounds(markersClusterGroup.getBounds());
					
					// iteration = 1;
				}
			}

			var osmLink = '<a href="http://openstreetmap.org">OpenStreetMap</a>',
				thunLink = '<a href="http://thunderforest.com/">Thunderforest</a>';

			var osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
				osmAttrib = '&copy; ' + osmLink + ' Contributors',
				landUrl = 'http://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png',
				thunAttrib = '&copy; ' + osmLink + ' Contributors & ' + thunLink;

			// initialise different layers for different tile providers
			var osmMap = L.tileLayer(osmUrl, {
				    maxZoom: 19,
				    minZoom: 0,
					attribution: osmAttrib
				});
			var	landMap = L.tileLayer(landUrl, {
				    maxZoom: 18,
				    minZoom: 0,
					attribution: thunAttrib
				});
			// var bingMap = new L.BingLayer("YOUR_BING_API_KEY"); -- need an API key to use it 
			// http://stackoverflow.com/questions/14442055/use-bing-maps-tiles-with-leaflet
			var	googleRoadMap = new L.Google('ROADMAP', {
				    maxZoom: 21,
				    minZoom: 0
				});
			var	googleSatelliteMap = new L.Google('SATELLITE', {
				    maxZoom: 19,
				    minZoom: 0
				});
			var	googleHybridMap = new L.Google('HYBRID', {
				    maxZoom: 19,
				    minZoom: 0
				});
			var	googleTerrainMap = new L.Google('TERRAIN', {
				    maxZoom: 15,
				    minZoom: 0
				});
			var yandexRoadMap = new L.Yandex('map', {
				    maxZoom: 18,
				    minZoom: 0
				});
			var yandexHybridMap = new L.Yandex('hybrid', {
				    maxZoom: 19,
				    minZoom: 0
				});
			
			var ytraffic = new L.Yandex("null", {
				traffic:true, 
				opacity:0.8, 
				overlay:true
			});
 
			var map = L.map('map', {
				layers: [osmMap], // only add one!
				zoomControl: false,
                // Tell the map to use a loading control
                loadingControl: false
			})
			.setView([49.841919, 24.0316], 18); // Lviv (Rynok Sq) has been centered
 
			map.fire('dataloading');

			var baseLayers = {
				"OpenStreetMap": osmMap,
				"Landscape": landMap,
				// "Bing": bingMap,				
				"Yandex Roadmap": yandexRoadMap,
				"Yandex Hybrid": yandexHybridMap,
				"Google Roadmap": googleRoadMap,
				"Google Sattelite": googleSatelliteMap,
				"Google Hybrid": googleHybridMap,
				"Google Terrain": googleTerrainMap				
			};

			// ADD REGULAR LAYER BASED ON SIMPLE PRIMITIVES
			var gpsTracksOverlay = new L.LayerGroup();
			L.marker([49.836163,24.067783])
				.bindPopup('Te Papa').addTo(gpsTracksOverlay),
			L.marker([49.839817,24.050446])
				.bindPopup('Embassy Theatre').addTo(gpsTracksOverlay),
			L.marker([49.838488,24.035339])
				.bindPopup('Michael Fowler Centre').addTo(gpsTracksOverlay),
			L.marker([49.844134,24.025555])
				.bindPopup('Leuven Belgin Beer Cafe').addTo(gpsTracksOverlay),
			L.polyline([
				[49.844134,24.025555],
				[49.838488,24.035339],
				[49.839817,24.050446],
				[49.836163,24.067783]
			]).addTo(gpsTracksOverlay);

			// ADD REGULAR LAYER BASED ON GEOJSON FEATURES
			// if (!geoJsonFeatures) {
			// var geoJsonFeatures = [{
			// 	    "type": "LineString",
			// 	    "coordinates": [
			// 	    	[24.03, 49.835],
			// 			[24.02, 49.84 ],
			// 			[24.05, 49.845]
			// 		],
			// 		"properties": {
			// 			"popupContent": "FIRST FEATURE"	
			// 		}					
			// 	}, {
			// 	    "type": "LineString",
			// 	    "coordinates": [
			// 	    	[24.04, 49.835],
			// 			[24.03, 49.84],
			// 			[24.06, 49.845]
			//  	   ],
			// 		"properties": {
			// 	 	    "popupContent": "SECOND FEATURE"
			// 	 	}
			//  	}
			// ];
			// }

			// var geoJsonStyle = {
			//     "color": "blue",
			//     "weight": 5,
			//     "opacity": 0.65
			// };

			function getColor(feature) {
				if (feature && feature.geometry && feature.geometry.type) {
					if (feature.geometry.type === "LineString") {
						return "blue";	
					} else if (feature.geometry.type === "Point") {
						if (feature.properties && feature.properties.vectorSpeed) {
							return (feature.properties.vectorSpeed > 0) ? "blue" : "red";	
						} 
					}
					return "white";
				}
			}

			function geoJsonStyle(feature) {
 			    return {
        			// fillColor: getColor(feature),
        			weight: 5,
			        opacity: 0.65,
        			color: getColor(feature)
			        // dashArray: '3',
			        // fillOpacity: 0.7
    			};
			}

			// var ArrowIcon = L.Icon.extend({
   // 				options: {
   //      			// shadowUrl: 'leaf-shadow.png',
   //      			// iconSize:     [38, 95],
   //      			// shadowSize:   [50, 64],
   //      			// iconAnchor:   [22, 94],
   //      			iconAnchor:   [12, 12],
   //      			// shadowAnchor: [4, 62],
   //      			// popupAnchor:  [-3, -76]
   //      			popupAnchor:  [0, 0]        			
   //  			}
			// });

			// var arrowIcon = new ArrowIcon({
			// 	iconUrl: 'arrow3.png'
			// });

			var arrowIcon = new L.Icon({
				iconUrl: 'arrow3.png',
				iconAnchor:   [12, 12],
				popupAnchor:  [0, 0]        			
			});

			var CircleIcon = L.Icon.extend({
   				options: {
        			iconAnchor:   [12, 12],
        			popupAnchor:  [0, 0]        			
    			}
			});

			var circleIcon = new CircleIcon({
				iconUrl: 'circle.png'
			});

			var CircleMarker = L.Marker.extend({
				options: {
					icon: circleIcon,
					title: "BlaBla",
					riseOnHover: true,
					zIndexOffset: 1000 // high value to make the circles always on top				
				}
			});

			var ArrowMarker = L.RotatedMarker.extend({
				options: {
		    		icon: arrowIcon,
		    		title: "BlaBla",
		    		riseOnHover: true
				}
			});

			var markersClusterGroup = L.markerClusterGroup({ 
				chunkedLoading: true, 
				chunkProgress: updateProgressBar,
				disableClusteringAtZoom: 17, // 17
				maxClusterRadius: function(zoom) {
					return 60;
				},
				iconCreateFunction: function(cluster) {
					// console.log("Creating cluster:");
					// console.log(cluster);
     				// return new L.DivIcon({ html: '<b>' + cluster.getChildCount() + '</b>' });
					var markers = cluster.getAllChildMarkers();					
					var chosenMarker; // = markers[0];
					var count = markers.length;
					for (var i = 0; i < count; i++) {
						if (markers[i] instanceof ArrowMarker) { // arrow marker
					
						} else { // circle marker
							// chosenMarker = markers[i]; // use first found circle marker as the marker for the cluster
							// return circleIcon; // new CircleMarker(chosenMarker.getLatLng());

							return L.divIcon({
								html: '<div class="img-overlay"><img src="circle.png" /><div class="overlay" >&#x2194</div></div>',
								className: 'gps-marker-cluster',
								iconSize: new L.Point(24, 24)
							});
						}
					}
					if (!chosenMarker) {
						chosenMarker = markers[Math.floor(count / 2)]; // use middle arrow marker as the marker for the cluster when no circle markers exist
					}
					// var arrowMarker = new ArrowMarker(chosenMarker.getLatLng()); // L.divIcon({ html: n, className: 'mycluster', iconSize: L.point(40, 40) });
					// console.log("arrowMarker: ");					
					// console.log(arrowMarker);					

					// var m = new L.Marker(getRandomLatLng(map), { 
					// 	icon: L.divIcon({
					// 		html: '<img src="marker-icon.png" style="-webkit-transform: rotate(39deg)" />'
					// 	})
					// });

					// return arrowIcon; // arrowMarker;

					return L.divIcon({
						html: '<div class="img-overlay"><img src="arrow3.png" style="-webkit-transform: rotate(' + 
					 					chosenMarker.options.angle + 
					 					'deg); " /><div class="overlay" style="-webkit-transform: rotate(' + 
					 					(chosenMarker.options.angle + 90) + 
					 					'deg); ">&#x2194</div></div>', // ' + cluster.getChildCount() + ' &#x21FF
						className: 'gps-marker-cluster',
						iconSize: new L.Point(24, 24)
					});

					// return L.divIcon({ // TODO consider crossbrowser rotation issues (see Marker.Rotate.js for more details)
					// 	html: '<img src="arrow3.png" style="-webkit-transform: rotate(' + 
					// 				chosenMarker.options.angle + 
					// 		'deg); position:absolute; top:-6px; left:-6px;" />',
					// 	className: 'gps-marker-cluster',
					// 	iconSize: new L.Point(80, 80)
					// }); 
    			}
			});

			// var myIcon = L.divIcon({
   //          	// Specify a class name we can refer to in CSS.
   //          	className: 'count-icon',
   //          	// Define what HTML goes in each marker.
	  //           html: i,
   //  	        // Set a markers width and height.
   //          	iconSize: [40, 40]
   //      	});

			// var geojsonMarkerOptions = {
			// 	icon: myIcon,
  	// 			radius: 8,
			//     fillColor: "#ff7800",
			//     color: "#000",
			//     weight: 1,
			//     opacity: 1,
			//     fillOpacity: 0.8
			// };

			var geoJsonOverlay = L.geoJson([], {
			    style: geoJsonStyle,

			    pointToLayer: function (feature, latlng) {
			    	if (feature.properties && feature.properties.vectorSpeed) { 
				    	return new ArrowMarker(latlng, {
				    		angle: ((feature.properties && feature.properties.vectorAngle) ? feature.properties.vectorAngle : 0)
				    	});
			    	} else {
			    		return new CircleMarker(latlng);
			    	}
			    },

// 		        pointToLayer: function (feature, latlng) {
//     			    return L.marker(latlng, {
// 						icon: L.divIcon({
//             				// Specify a class name we can refer to in CSS.
//             				className: 'count-icon',
//             				// Define what HTML goes in each marker.
// 	            			// html: ((feature.properties && feature.properties.popupContent) ? feature.properties.popupContent : "UNKNOWN"),
// 	            			html: "<svg height=&quot;210&quot; width=&quot;500&quot;>
//   <polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot;
//   style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;&quot; />
// </svg> "
//     	        			// Set a markers width and height.
//             				iconSize: [20, 20]
//         				}),
//   						radius: 8,
// 			    		fillColor: "#ff7800",
// 			    		color: "#000",
// 			    		weight: 1,
// 			    		opacity: 1,
// 			    		fillOpacity: 0.8
// 					}); // circleMarker
//     			},

			    onEachFeature: function (feature, layer) {
		            
		            layer.on('click', function() { // dblclick
    	            	// alert("Hi!");
    	            	console.log("clicked.");
	            	});

 			    	// does this feature have a property named popupContent?
				    if (feature.properties && feature.properties.popupContent) {
	       				layer.bindPopup(feature.properties.popupContent);	        			
			    	}
				}
			});
			geoJsonOverlay.addData(geoJsonFeatures);
			markersClusterGroup.addLayer(geoJsonOverlay);
			map.addLayer(markersClusterGroup);

			// fitToBounds control
			var fitToBoundsControl = new L.easyButton(
				"fa-compress",
				function() {
					map.fitBounds(markersClusterGroup.getBounds());
				},
				"Fit to bounds",
				map
			);

		    // Add our zoom control manually where we want to
            var zoomControl = L.control.zoom({
                position: 'topleft'
            });
            map.addControl(zoomControl);

            // Add our loading control in the same position and pass the
            // zoom control to attach to it
            var loadingControl = L.Control.loading({
                position: 'topleft',
                zoomControl: zoomControl
            });
            map.addControl(loadingControl);

  			// scale control on the left bottom of the map
			var scaleControl = L.control.scale({
			    imperial: false,
			    position: 'bottomleft'
			});
			map.addControl(scaleControl);

			// ADD LEAFLET.DRAW
			var drawnItems = new L.FeatureGroup();
			map.addLayer(drawnItems);

			var drawControl = new L.Control.Draw({
				position: 'bottomleft',

				edit: {
					featureGroup: drawnItems
				},

				draw: {
					polygon: {
						shapeOptions: {
							color: 'purple'
						},
						allowIntersection: false,
						drawError: {
							color: 'orange',
							timeout: 1000
						},
						showArea: true,
						metric: true
					}
				}
			});
			map.addControl(drawControl);

			map.on('draw:created', function (e) {
				var type = e.layerType,
					layer = e.layer;
				drawnItems.addLayer(layer);
			});

			// GATHER ALL LAYERS
			var overlays = {
				"GEO-json": markersClusterGroup,
				"GPS-tracks": gpsTracksOverlay,
				"Traffic": ytraffic
			};
 			
			L.control.layers(baseLayers, overlays).addTo(map); 

			map.fire('dataload');

		</script>
	</body>
</html>